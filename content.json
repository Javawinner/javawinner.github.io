{"meta":{"title":"Gorg Chen","subtitle":"","description":null,"author":"Gorg Chen","url":"http://cjwnb.top","root":"/"},"pages":[{"title":"分类","date":"2019-07-14T14:54:31.000Z","updated":"2019-07-15T18:00:03.036Z","comments":true,"path":"categories/index.html","permalink":"http://cjwnb.top/categories/index.html","excerpt":"","text":""},{"title":"链接","date":"2019-07-14T14:46:05.000Z","updated":"2019-07-15T18:00:29.456Z","comments":true,"path":"link/index.html","permalink":"http://cjwnb.top/link/index.html","excerpt":"","text":""},{"title":"","date":"2019-07-20T13:21:22.502Z","updated":"2019-07-20T13:21:22.402Z","comments":true,"path":"images/ajax.html","permalink":"http://cjwnb.top/images/ajax.html","excerpt":"","text":"多对多表三种创建方式第一种django orm自动创建 class Book(models.Model): name = models.CharField(max_length=32) authors = models.ManyToManyField(to='Author')class Author(models.Model): name = models.CharField(max_length=32) 第二种手动创建第三张表 class Book(models.Model): name = models.CharField(max_length=32) class Author(models.Model): name = models.CharField(max_length=32) class Book2Author(models.Model): book = models.ForeignKey(to='Book') author = models.ForeignKey(to='Author') info = models.CharField(max_length=32) 第三种半自动创建第三张表(可扩展性高，并且能够符合orm查询) class Book(models.Model): name = models.CharField(max_length=32) # 第三种创建表的方式 authors = models.ManyToManyField(to='Author',through='Book2Author',through_fields=('book','author'))class Author(models.Model): name = models.CharField(max_length=32) book = models.ManyToManyField(to='Book',through='Book2Author',through_fields=('author','book'))class Book2Author(models.Model): book = models.ForeignKey(to='Book') author = models.ForeignKey(to='Author') info = models.CharField(max_length=32) 案例 查询书籍对应的作者 ​ models.py from django.db import models# Create your models here.class Book(models.Model): name = models.CharField(max_length=32) authors=models.ManyToManyField(to='Author',through='Book2Author',through_fields=('book','author'))class Author(models.Model): name = models.CharField(max_length=32)class Book2Author(models.Model): book = models.ForeignKey(to='Book') author = models.ForeignKey(to='Author') info=models.CharField(max_length=64) tests.py import osif __name__ == \"__main__\": os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"ajax.settings\") import django django.setup() from app01 import models res=models.Book.objects.filter(pk=1).values('authors__name') print(res) # &lt;QuerySet [&#123;'authors__name': 'lyysb'&#125;, &#123;'authors__name': 'hhpsb'&#125;]&gt; book_obj=models.Book.objects.filter(pk=1).first() res=book_obj.authors.all() print(res) 编码格式urlencoded​ 对应的数据格式:name=jason&amp;password=666​ 后端获取数据:request.POST​ ps；django会将urlencoded编码的数据解析自动放到request.POST formdata​ form表单传输文件的编码格式​ 后端获取文件格式数据:request.FILES​ 后端获取普通键值对数据:request.POST application/json​ ajax发送json格式数据​ 需要注意的点​ 编码与数据格式要一致"},{"title":"标签","date":"2019-07-14T14:30:38.000Z","updated":"2019-07-15T18:00:40.178Z","comments":true,"path":"tags/index.html","permalink":"http://cjwnb.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Django操作session和cookie","slug":"session和cookie","date":"2019-07-21T16:26:12.563Z","updated":"2019-07-21T20:16:53.513Z","comments":true,"path":"2019/07/22/session和cookie/","link":"","permalink":"http://cjwnb.top/2019/07/22/session和cookie/","excerpt":"","text":"http协议四大特性 基于TCP/IP作用于应用层的协议 基于请求响应 无状态 无连接 Cookie和Sessioncookie 保存在客户端浏览器上的键值对 session 保存在服务端上的键值对服务端产生随机的串儿返回给客户端，服务端找一个地方将串儿与对应的信息存起来{‘随机字符串’:’敏感信息’} 没有cookie,session没有任何存在的意义，当我们在浏览器上禁用了cookie,我们就无法登陆京东或者淘宝，因为服务器并没有session,验证无法通过，就无法登入了，session的查看方式在console下的application下的cookies可以查看 设置cookieobj = HttpResponse()return objobj = render()return objobj = redirect()return obj obj.set_cookie(key,value) # 给浏览器设置cookie获取cookie: request.COOKIE.get(key) / request.COOKIE[key] 删除cookie: urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^reg/', views.reg), url(r'^login/', views.login), url(r'^index/', views.index), url(r'^home/', views.home), url(r'^xxx/', views.xxx),] views.py from django.shortcuts import render, HttpResponse, redirect# Create your views here.from django import formsfrom app01 import modelsfrom django.forms import widgets# widget=widgets.PasswordInput() 设置为密文# widget=widgets.PasswordInput(attrs=&#123;'class':'c1 form-control'&#125; 给密码框设置bootstrap样式class MyForm(forms.Form): name = forms.CharField(max_length=6, label='用户名', error_messages=&#123; 'max_length': '用户名最长6位', 'required': '用户名不能为空', &#125;) password = forms.CharField(max_length=8, min_length=3, error_messages=&#123; 'max_length': '用户名最长6位', 'required': '用户名不能为空', 'min_length': '密码最少3位' &#125;, widget=widgets.PasswordInput()) confirm_password = forms.CharField(max_length=8, min_length=3, error_messages=&#123; 'max_length': '用户名最长6位', 'required': '用户名不能为空', 'min_length': '密码最少3位' &#125;, widget=widgets.PasswordInput(attrs=&#123;'class': 'c1 form-control'&#125;)) email = forms.EmailField(error_messages=&#123; 'invalid': '邮箱格式不正确', 'required': '邮箱不能为空', &#125;) # 钩子函数是最后一步校验，前面的校验过了才会由钩子函数进行校验 # 钩子函数只能操作cleaned_data的数据 # 局部钩子函数 （单个字段的校验利用局部钩子函数） def clean_name(self): name = self.cleaned_data.get('name') if '666' in name: self.add_error('name', '666不行的') return name # 全局钩子函数 def clean(self): print(self.cleaned_data) password = self.cleaned_data.get('password') confirm_password = self.cleaned_data.get('confirm_password') if not password == confirm_password: self.add_error('confirm_password', '两次密码不一致') return self.cleaned_datadef reg(request): # 生成一个空对象 form_obj = MyForm() if request.method == 'POST': # &lt;QueryDict: &#123;'name': ['lyysb'], 'password': ['lyysb123'], 'email': ['123@qq.com']&#125;&gt; form_obj = MyForm(request.POST) if form_obj.is_valid(): print(form_obj.cleaned_data) models.User.objects.create(**form_obj.cleaned_data) else: error = form_obj.errors return render(request, 'reg.html', locals())def login(request): if request.method == 'POST': username = request.POST.get('username') password = request.POST.get('password') if username == 'lyysb' and password == '123': old_path = request.GET.get('next') if old_path: obj = redirect(old_path) else: obj = redirect('/home/') # 用户登录成功 朝浏览器设置一个cookie obj.set_cookie('name', 'lyysb') # 设置上次访问时间 import datetime now = datetime.datetime.now().strftime('%Y-%m-%d %X') obj.set_cookie('time', now) return obj return render(request, 'login.html')from functools import wrapsdef login_auth(func): @wraps(func) def inner(request, *args, **kwargs): print(request.get_full_path()) old_path = request.get_full_path() # 校验cookie if request.COOKIES.get('name'): return func(request, *args, **kwargs) return redirect('/login/?next=%s' % old_path) return inner@login_authdef index(request): # print(request.COOKIES.get('name')) # if request.COOKIES.get('name'): last_time = request.COOKIES.get('time',\"\") return render(request, 'index.html', &#123;'last_time': last_time&#125;)@login_authdef home(request): return HttpResponse('我是home页面，只有登陆了才能看')@login_authdef xxx(request): return HttpResponse('我是xxx页面，只有登陆了才能看') login.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt; &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\"&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js\" integrity=\"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"\" method=\"post\"&gt; &lt;p&gt;username&lt;input type=\"text\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;password&lt;input type=\"text\" name=\"password\"&gt;&lt;/p&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; index.html &lt;body&gt;&lt;h1&gt;index&lt;/h1&gt;&lt;p&gt;上次访问时间：&#123;&#123; last_time &#125;&#125;&lt;/p&gt;&lt;/body&gt; ​","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"前端","slug":"前端","permalink":"http://cjwnb.top/tags/前端/"}]},{"title":"模块","slug":"模块","date":"2019-07-21T12:47:43.161Z","updated":"2019-07-21T12:47:43.161Z","comments":true,"path":"2019/07/21/模块/","link":"","permalink":"http://cjwnb.top/2019/07/21/模块/","excerpt":"","text":"importlibimport importlibs='yyy.b'res=importlib.import_module(s)print(res) # &lt;module 'yyy.b' from '/Users/cjw/Desktop/Django_projects/xxx/yyy/b.py'&gt;","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"前端","slug":"前端","permalink":"http://cjwnb.top/tags/前端/"}]},{"title":"form组件","slug":"form组件","date":"2019-07-21T12:13:35.354Z","updated":"2019-07-21T16:24:12.815Z","comments":true,"path":"2019/07/21/form组件/","link":"","permalink":"http://cjwnb.top/2019/07/21/form组件/","excerpt":"","text":"更详细理论知识查看博客： https://www.cnblogs.com/Dominic-Ji/p/9240365.html 注册功能实现 1.渲染前端标签获取用户输入 &gt;&gt;&gt; 渲染标签2.获取用户输入传递到后端校验 &gt;&gt;&gt; 校验数据3.校验未通过展示错误信息 &gt;&gt;&gt; 展示信息 校验前端后端都可以做，但是前端可以不做，后端必须得做!!! 手动实现urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^reg/', views.reg),] views.py from django.shortcuts import render# Create your views here.def reg(request): errors = &#123;'username': '', 'password': ''&#125; if request.method == 'POST': username = request.POST.get('username') password = request.POST.get('password') if 'sb' in username: errors['username'] = '用户名里不能有sb,你这个dsb' if password == '123': errors['password'] = '密码太简单了，你这个bb' return render(request, 'reg.html', locals()) reg.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;注册页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;注册页面&lt;/h1&gt;&lt;form action=\"\" method=\"post\"&gt; &lt;p&gt; username:&lt;input type=\"text\" name=\"username\"&gt; &lt;span&gt;&#123;&#123; errors.username &#125;&#125;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;password:&lt;input type=\"password\" name=\"password\"&gt; &lt;span&gt;&#123;&#123; errors.password &#125;&#125;&lt;/span&gt; &lt;/p&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1.渲染标签2.校验数据3.展示信息 校验数据需要一个form类from django import formsclass MyForm(forms.Form): name = forms.CharField(max_length=6) password = forms.CharField(max_length=8,min_length=3) email = forms.EmailField(required=True) 实例化form对象form_obj = MyForm(&#123;'name':'jason'&#125;) 查看数据校验是否合法form_obj.is_valid() # 只有当所有的字段都校验通过才会返回True 查看校验错误的信息form_obj.errors # 这个里面放的是所有校验未通过的字段及错误提示 \"\"\" &#123; 'name': ['Ensure this value has at most 6 characters (it has 7).'], 'password': ['Ensure this value has at least 3 characters (it has 2).'], 'email': ['Enter a valid email address.'] &#125; \"\"\" 查看校验通过的数据form_obj.cleaned_data # 符合校验规则数据都会被放到该对象中 form组件校验数据的规则从上往下依次取值校验 校验通过的放到cleaned_data 校验失败的放到errors注意 form组件校验数据的规则从上往下依次取值校验 校验通过的放到cleaned_data 校验失败的放到errors form中所有的字段默认都是必须传值的(required=True)校验数据的时候可以都传(多传的数据不会做任何的校验&gt;&gt;&gt;不会影响form校验规则) 测试代码views.py from django import formsclass MyForm(forms.Form): name = forms.CharField(max_length=6) password = forms.CharField(max_length=8, min_length=3) email = forms.EmailField() 字段名全部传错校验不通过 &gt;&gt;&gt; from app01 import views&gt;&gt;&gt; form_obj=views.MyForm(&#123;'name':'egondsb','password':'12','email':'123'&#125;)&gt;&gt;&gt; form_obj.is_valid()False&gt;&gt;&gt; form_obj.errors&#123;'name': ['Ensure this value has at most 6 characters (it has 7).'], 'password': ['Ensure this value has at least 3 characters (it has 2).'], 'email': ['Enter &#125; 传错一个字段校验不通过 &gt;&gt;&gt; from app01 import views&gt;&gt;&gt; form_obj=views.MyForm(&#123;'name':'egon','password':'1234','email':'123'&#125;)&gt;&gt;&gt; form_obj.is_valid()False&gt;&gt;&gt; form_obj.errors&#123;'email': ['Enter a valid email address.']&#125;&gt;&gt;&gt; form_obj.cleaned_data&#123;'name': 'egon', 'password': '1234'&#125; 少传一个字段校验不通过 &gt;&gt;&gt; from app01 import views&gt;&gt;&gt; form_obj=views.MyForm(&#123;'name':'egon','password':'1234'&#125;)&gt;&gt;&gt; form_obj.is_valid()False&gt;&gt;&gt; form_obj.errors&#123;'email': ['This field is required.']&#125;&gt;&gt;&gt; form_obj.cleaned_data&#123;'name': 'egon', 'password': '1234'&#125; 字段全部传对校验通过 &gt;&gt;&gt; from app01 import views&gt;&gt;&gt; form_obj=views.MyForm(&#123;'name':'egon','password':'1234','email':'123@qq.com'&#125;)&gt;&gt;&gt; form_obj.is_valid()True&gt;&gt;&gt; form_obj.cleaned_data&#123;'name': 'egon', 'password': '1234', 'email': '123@qq.com'&#125;&gt;&gt;&gt; form_obj.errors&#123;&#125; 多传一个字段校验通过 &gt;&gt;&gt; from app01 import views&gt;&gt;&gt;form_obj=views.MyForm(&#123;'name':'egon','password':'1234','email':'123@qq.com','hobby':'read'&#125;)&gt;&gt;&gt; form_obj.is_valid()True&gt;&gt;&gt; form_obj.cleaned_data&#123;'name': 'egon', 'password': '1234', 'email': '123@qq.com'&#125;&gt;&gt;&gt; form_obj.errors&#123;&#125; 渲染标签form组件只帮你渲染获取用户输入的标签,不会帮你渲染提交按钮，需要手动添加 第一种渲染方式 (可扩展性较差) &lt;h1&gt;第一种渲染方式(可扩展性较差)&lt;/h1&gt; &#123;&#123; form_obj.as_p &#125;&#125; &#123;&#123; form_obj.as_ul &#125;&#125; urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^reg/', views.reg),] views.py from django.shortcuts import render# Create your views here.from django import formsclass MyForm(forms.Form): name = forms.CharField(max_length=6) password = forms.CharField(max_length=8, min_length=3) email = forms.EmailField()def reg(request): # 生成一个空对象 form_obj = MyForm() return render(request, 'reg.html', locals()) index.html &lt;body&gt;&lt;h1&gt;第一种渲染方式&lt;/h1&gt;&#123;&#123; form_obj.as_p &#125;&#125;&lt;/body&gt; 第二种渲染方式 form组件只帮你渲染获取用户输入的标签,不会帮你渲染提交按钮，需要手动添加 如果类名中未指定label名字，则以定义的字段名首字母大写作为lable名字展示到前端 &lt;h1&gt;第二种渲染方式&lt;/h1&gt; &lt;form action=\"\"&gt; &lt;p&gt;&#123;&#123; form_obj.name.label &#125;&#125;&#123;&#123; form_obj.name &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; form_obj.password.label &#125;&#125;&#123;&#123; form_obj.password &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; form_obj.email.label &#125;&#125;&#123;&#123; form_obj.email &#125;&#125;&lt;/p&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^reg/', views.reg),] views.py from django.shortcuts import render# Create your views here.from django import formsclass MyForm(forms.Form): name = forms.CharField(max_length=6,label='用户名') password = forms.CharField(max_length=8, min_length=3) email = forms.EmailField()def reg(request): # 生成一个空对象 form_obj = MyForm() return render(request, 'reg.html', locals()) reg.html &lt;body&gt;&lt;h1&gt;第二种渲染方式&lt;/h1&gt;&lt;form action=\"\"&gt; &lt;p&gt; &#123;&#123; form_obj.name.label &#125;&#125;&#123;&#123; form_obj.name &#125;&#125;&lt;/p&gt; &lt;p&gt; &#123;&#123; form_obj.password.label &#125;&#125;&#123;&#123; form_obj.password &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; form_obj.email.label &#125;&#125;&#123;&#123; form_obj.email &#125;&#125;&lt;/p&gt;&lt;/form&gt;&lt;/body&gt; 第三种渲染方式 &lt;h1&gt;第三种渲染标签的方式&lt;/h1&gt; &lt;form action=\"\"&gt; &#123;% for foo in form_obj %&#125; &lt;p&gt;&#123;&#123; foo.label &#125;&#125;&#123;&#123; foo &#125;&#125;&lt;/p&gt; &#123;% endfor %&#125; &lt;/form&gt; urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^reg/', views.reg),] views.py from django.shortcuts import render# Create your views here.from django import formsclass MyForm(forms.Form): name = forms.CharField(max_length=6,label='用户名') password = forms.CharField(max_length=8, min_length=3) email = forms.EmailField()def reg(request): # 生成一个空对象 form_obj = MyForm() return render(request, 'reg.html', locals()) index.html &lt;body&gt;&lt;h1&gt;第二种渲染方式&lt;/h1&gt;&lt;form action=\"\"&gt; &lt;p&gt; &#123;&#123; form_obj.name.label &#125;&#125;&#123;&#123; form_obj.name &#125;&#125;&lt;/p&gt; &lt;p&gt; &#123;&#123; form_obj.password.label &#125;&#125;&#123;&#123; form_obj.password &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; form_obj.email.label &#125;&#125;&#123;&#123; form_obj.email &#125;&#125;&lt;/p&gt;&lt;/form&gt;&lt;/body&gt; reg.html &lt;body&gt;&lt;h1&gt;第三种渲染方式&lt;/h1&gt;&lt;form action=\"\"&gt; &#123;% for foo in form_obj %&#125; &lt;p&gt;&#123;&#123; foo.label &#125;&#125; &#123;&#123; foo &#125;&#125;&lt;/p&gt; &#123;% endfor %&#125;&lt;/form&gt;&lt;/body&gt; 钩子函数 钩子函数是最后一步校验，前面的校验过了才会由钩子函数进行校验 钩子函数只能操作cleaned_data的数据 widget=widgets.PasswordInput() 设置为密文widget=widgets.PasswordInput(attrs=&#123;'class':'c1 form-control'&#125; 给密码框设置bootstrap样式 局部钩子函数 （单个字段的校验利用局部钩子函数） 全局钩子函数 （多个字段的校验利用全局钩子函数） from django.shortcuts import render, HttpResponse# Create your views here.from django import formsfrom app01 import modelsfrom django.forms import widgets# widget=widgets.PasswordInput() 设置为密文class MyForm(forms.Form): name = forms.CharField(max_length=6, label='用户名', error_messages=&#123; 'max_length': '用户名最长6位', 'required': '用户名不能为空', &#125;) password = forms.CharField(max_length=8, min_length=3, error_messages=&#123; 'max_length': '用户名最长6位', 'required': '用户名不能为空', 'min_length': '密码最少3位' &#125;,widget=widgets.PasswordInput()) confirm_password = forms.CharField(max_length=8, min_length=3, error_messages=&#123; 'max_length': '用户名最长6位', 'required': '用户名不能为空', 'min_length': '密码最少3位' &#125;,widget=widgets.PasswordInput()) email = forms.EmailField(error_messages=&#123; 'invalid': '邮箱格式不正确', 'required': '邮箱不能为空', &#125;) # 钩子函数是最后一步校验，前面的校验过了才会由钩子函数进行校验 # 钩子函数只能操作cleaned_data的数据 # 局部钩子函数 （单个字段的校验利用局部钩子函数） def clean_name(self): name = self.cleaned_data.get('name') if '666' in name: self.add_error('name', '666不行的') return name # 全局钩子函数 def clean(self): print(self.cleaned_data) password=self.cleaned_data.get('password') confirm_password=self.cleaned_data.get('confirm_password') if not password==confirm_password: self.add_error('confirm_password','两次密码不一致') return self.cleaned_datadef reg(request): # 生成一个空对象 form_obj = MyForm() if request.method == 'POST': # &lt;QueryDict: &#123;'name': ['lyysb'], 'password': ['lyysb123'], 'email': ['123@qq.com']&#125;&gt; form_obj = MyForm(request.POST) if form_obj.is_valid(): print(form_obj.cleaned_data) models.User.objects.create(**form_obj.cleaned_data) else: error = form_obj.errors return render(request, 'reg.html', locals()) 设置标签样式from django import forms from django.forms import widgets password = forms.CharField(max_length=8,min_length=3,error_messages=&#123; 'max_length': '密码最长8位', 'required': '密码不能为空', 'min_length':'密码最少3位' &#125;,widget=widgets.PasswordInput(attrs=&#123;'class':'c1 form-control'&#125;)) hobby = forms.ChoiceField( choices=((1, \"篮球\"), (2, \"足球\"), (3, \"双色球\"),), label=\"爱好\", initial=3, widget=forms.widgets.Select() ) hobby1 = forms.MultipleChoiceField( choices=((1, \"篮球\"), (2, \"足球\"), (3, \"双色球\"),), label=\"爱好\", initial=[1, 3], widget=forms.widgets.SelectMultiple() ) keep = forms.ChoiceField( label=\"是否记住密码\", initial=\"checked\", widget=forms.widgets.CheckboxInput() ) 使用form表单实现注册 前端取消校验 &lt;form action=\"\" method=\"post\" novalidate&gt;&lt;/form&gt; form组件提交数据如果数据不合法，页面上会保留之前用户输入的信息在使用form组件对模型表进行数据校验的时候，只需要保证字段一致, 那么在创建的对象的时候你就直接**form_obj.cleaned_data &lt;form action=\"\" method=\"post\" novalidate&gt; &#123;% for foo in form_obj %&#125; &lt;p&gt; &#123;&#123; foo.label &#125;&#125;&#123;&#123; foo &#125;&#125; &lt;span&gt;&#123;&#123; foo.errors.0 &#125;&#125;&lt;/span&gt; &lt;/p&gt; &#123;% endfor %&#125; &lt;input type=\"submit\"&gt; &lt;/form&gt; urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^reg/', views.reg),] views.py from django.shortcuts import render, HttpResponse# Create your views here.from django import formsfrom app01 import modelsfrom django.forms import widgets# widget=widgets.PasswordInput() 设置为密文# widget=widgets.PasswordInput(attrs=&#123;'class':'c1 form-control'&#125; 给密码框设置bootstrap样式class MyForm(forms.Form): name = forms.CharField(max_length=6, label='用户名', error_messages=&#123; 'max_length': '用户名最长6位', 'required': '用户名不能为空', &#125;) password = forms.CharField(max_length=8, min_length=3, error_messages=&#123; 'max_length': '用户名最长6位', 'required': '用户名不能为空', 'min_length': '密码最少3位' &#125;,widget=widgets.PasswordInput()) confirm_password = forms.CharField(max_length=8, min_length=3, error_messages=&#123; 'max_length': '用户名最长6位', 'required': '用户名不能为空', 'min_length': '密码最少3位' &#125;,widget=widgets.PasswordInput(attrs=&#123;'class':'c1 form-control'&#125;)) email = forms.EmailField(error_messages=&#123; 'invalid': '邮箱格式不正确', 'required': '邮箱不能为空', &#125;) # 钩子函数是最后一步校验，前面的校验过了才会由钩子函数进行校验 # 钩子函数只能操作cleaned_data的数据 # 局部钩子函数 （单个字段的校验利用局部钩子函数） def clean_name(self): name = self.cleaned_data.get('name') if '666' in name: self.add_error('name', '666不行的') return name # 全局钩子函数 def clean(self): print(self.cleaned_data) password=self.cleaned_data.get('password') confirm_password=self.cleaned_data.get('confirm_password') if not password==confirm_password: self.add_error('confirm_password','两次密码不一致') return self.cleaned_datadef reg(request): # 生成一个空对象 form_obj = MyForm() if request.method == 'POST': # &lt;QueryDict: &#123;'name': ['lyysb'], 'password': ['lyysb123'], 'email': ['123@qq.com']&#125;&gt; form_obj = MyForm(request.POST) if form_obj.is_valid(): print(form_obj.cleaned_data) models.User.objects.create(**form_obj.cleaned_data) else: error = form_obj.errors return render(request, 'reg.html', locals()) models.py from django.db import models# Create your models here.class User(models.Model): name=models.CharField(max_length=32) password=models.CharField(max_length=32) email=models.EmailField() 执行manager.py创建表 菜单-tools-Run manager.py Task$ makemigrations$ migrate reg.html &lt;body&gt;&lt;h1&gt;第三种渲染方式&lt;/h1&gt;&lt;form action=\"\" method=\"post\" novalidate&gt; &#123;% for foo in form_obj %&#125; &lt;p&gt;&#123;&#123; foo.label &#125;&#125; &#123;&#123; foo &#125;&#125;&lt;span&gt;&#123;&#123; foo.errors.0 &#125;&#125;&lt;/span&gt;&lt;/p&gt; &#123;% endfor %&#125; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt; 浏览器测试，最后去数据库查看结果 查看钩子函数是否生效","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"前端","slug":"前端","permalink":"http://cjwnb.top/tags/前端/"}]},{"title":"批量插入数据以及分页","slug":"批量插入数据以及分页","date":"2019-07-21T12:05:35.163Z","updated":"2019-07-21T12:06:01.819Z","comments":true,"path":"2019/07/21/批量插入数据以及分页/","link":"","permalink":"http://cjwnb.top/2019/07/21/批量插入数据以及分页/","excerpt":"","text":"批量插入数据l = [] for i in range(10000): l.append(models.Book2(name='第%s本书'%i)) models.Book2.objects.bulk_create(l) # 批量插入数据 urls.py rom django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^booklist/', views.book_list),] views.py from app01 import modelsdef book_list(request): # 动态插入100000条数据 l=[] for i in range(10000): l.append(models.Book2(name=\"第%s本书\"%i)) models.Book2.objects.bulk_create(l) # 查询所有的书籍展示到前端页面 book_list=models.Book2.objects.all() return render(request,'booklist.html',locals()) models.py from django.db import modelsclass Book2(models.Model): name=models.CharField(max_length=64) 执行manage.py命令创建表 菜单-tools-Run manager.py Task$ makemigrations$ migrate booklist.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;link href=\"https://cdn.bootcss.com/twitter-bootstrap/3.4.1/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;script src=\"https://cdn.bootcss.com/twitter-bootstrap/3.4.1/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-8 col-md-offset-2\"&gt; &lt;table class=\"table table-hover table-bordered table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for book in book_list %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; book.pk &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; book.name &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 分页 导入模块 from django.core.paginator import Paginator,EmptyPage Paginator 实现分页功能，跳转到那一页默认情况下需要通过浏览器手动输入 EmptyPage: 跳转到那一页默认情况下需要通过浏览器手动输入，如果输入的页数是负数或者超出范围就会有一场场EmptyPage，主要用作捕获异常 版本1urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index/', views.index),] models.py from django.db import models# Create your models here.class Book(models.Model): title = models.CharField(max_length=32) price = models.DecimalField(decimal_places=2, max_digits=8) def __str__(self): return '对象：%s'%self.title views.py from django.shortcuts import render, HttpResponse# Create your views here.from .models import Bookfrom django.core.paginator import Paginator,EmptyPagedef index(request): # book_list = [] # for i in range(100): # book = Book(title='book_%s' % i, price=i * i) # book_list.append(book) # Book.objects.bulk_create(book_list) booklist=Book.objects.all() # 分页器 paginator=Paginator(booklist,106) print(paginator.count) # 数据总数 print(paginator.num_pages) # 总页数 print(paginator.page_range) #页码的列表 page_range=paginator.page_range try: current_pag=int(request.GET.get('page',1)) page1=paginator.page(current_pag) # 第一页数据的对象列表 # 显示某一页具体数据的两种方式: print(page1.object_list) # &lt;QuerySet[ &lt; Book: 对象：book_0 &gt;, &lt; Book: 对象：book_1 &gt;, &lt; Book: 对象：book_2 &gt;, &lt; Book: 对象：book_3 &gt;, &lt; Book: 对象：book_4 &gt;] &gt; for i in page1: print(i) # 对象：book_0 # 对象：book_1 # 对象：book_2 # 对象：book_3 # 对象：book_4 except EmptyPage as e: page1=paginator.page(1) return render(request, 'index.html', &#123;'page': page1,'page_range':page_range,'current_page':current_pag&#125;) bootstrap中文网找到一个分页的样式 https://v3.bootcss.com/components/#pagination放入index.html，用户通过点击页码，就能跳转到页面 index.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;link href=\"https://cdn.bootcss.com/twitter-bootstrap/3.4.1/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;script src=\"https://cdn.bootcss.com/twitter-bootstrap/3.4.1/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-8 col-md-offset-2\"&gt; &lt;table class=\"table table-hover table-bordered table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;title&lt;/th&gt; &lt;th&gt;price&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for book in page %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; book.pk &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; book.title &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; book.price &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; &lt;nav aria-label=\"Page navigation\"&gt; &lt;ul class=\"pagination\"&gt; &lt;li&gt; &lt;a href=\"?page=&#123;&#123; current_page|add:-1 &#125;&#125;\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;上一页&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &#123;% for item in page_range %&#125; &#123;% if current_page == item %&#125; &lt;li class=\"active\"&gt;&lt;a href=\"?page=&#123;&#123; item &#125;&#125;\"&gt;&#123;&#123; item &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% else %&#125; &lt;li&gt;&lt;a href=\"?page=&#123;&#123; item &#125;&#125;\"&gt;&#123;&#123; item &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;li&gt; &lt;a href=\"?page=&#123;&#123; current_page|add:1&#125;&#125;\" aria-label=\"Next\"&gt; &lt;span aria-hidden=\"true\"&gt;下一页&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt;&lt;/body&gt;&lt;/html&gt; 最终版本urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index/', views.index),] views.py from django.shortcuts import render, HttpResponse# Create your views here.from .models import Bookfrom django.core.paginator import Paginator, EmptyPagedef index(request): # book_list = [] # for i in range(100): # book = Book(title='book_%s' % i, price=i * i) # book_list.append(book) # Book.objects.bulk_create(book_list) booklist = Book.objects.all() # 分页器 paginator = Paginator(booklist, 60) # 分页，每一页106条数据对象 print(paginator.count) # 数据总数 print(paginator.num_pages) # 总页数 print(paginator.page_range) # 页码的列表 last_page=paginator.page_range[-1] current_pag = int(request.GET.get('page', 1)) if paginator.num_pages &gt; 11: if current_pag - 5 &lt; 1: page_range = range(1, 12) elif current_pag + 5 &gt; paginator.num_pages: page_range = range(paginator.num_pages - 11, paginator.num_pages + 1) else: page_range = range(current_pag - 5, current_pag + 6) else: page_range = paginator.page_range try: page1 = paginator.page(current_pag) # 某一页数据的对象列表 print(page1.has_next) # page1这一页是否有下一页 print(page1.next_page_number) # # page1这一页的下一页的页码 print(page1.has_previous) # page1这一页是否有上一页 print(page1.previous_page_number) #page1这一页的上一页的代码 # 显示某一页具体数据的两种方式: print(page1.object_list) # &lt;QuerySet[ &lt; Book: 对象：book_0 &gt;, &lt; Book: 对象：book_1 &gt;, &lt; Book: 对象：book_2 &gt;, &lt; Book: 对象：book_3 &gt;, &lt; Book: 对象：book_4 &gt;] &gt; for i in page1: print(i) # 对象：book_0 # 对象：book_1 # 对象：book_2 # 对象：book_3 # 对象：book_4 except EmptyPage as e: page1 = paginator.page(1) return render(request, 'index.html', &#123;'page': page1, 'page_range': page_range, 'current_page': current_pag,'last_page':last_page&#125;) models.py from django.db import modelsclass Book2(models.Model): name=models.CharField(max_length=64) 执行manage.py命令创建表 菜单-tools-Run manager.py Task$ makemigrations$ migrate index.html bootstap不会提示的问题，解决方案是在本地导入bootstrap文件 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\"&gt; &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap-theme.min.css\" integrity=\"sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp\" crossorigin=\"anonymous\"&gt; &lt;script src=\"https://cdn.bootcss.com/twitter-bootstrap/3.4.1/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-8 col-md-offset-2\"&gt; &lt;table class=\"table table-hover table-bordered table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;title&lt;/th&gt; &lt;th&gt;price&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for book in page %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; book.pk &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; book.title &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; book.price &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-8 col-md-offset-2\"&gt; &lt;nav aria-label=\"Page navigation\"&gt; &lt;ul class=\"pagination center line-block\"&gt; &lt;li&gt; &lt;a href=\"?page=1\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;第一页&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &#123;% if page.has_previous %&#125; &lt;li&gt; &lt;a href=\"?page=&#123;&#123; page.previous_page_number &#125;&#125;\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;上一页&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &#123;% else %&#125; &lt;li&gt; &lt;span aria-hidden=\"true\"&gt;上一页&lt;/span&gt; &lt;/li&gt; &#123;% endif %&#125; &#123;% for item in page_range %&#125; &#123;% if current_page == item %&#125; &lt;li class=\"active\"&gt;&lt;a href=\"?page=&#123;&#123; item &#125;&#125;\"&gt;&#123;&#123; item &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% else %&#125; &lt;li class=\"disabled\"&gt;&lt;a href=\"?page=&#123;&#123; item &#125;&#125;\"&gt;&#123;&#123; item &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% if page.has_next %&#125; &lt;li&gt; &lt;a href=\"?page=&#123;&#123; page.next_page_number &#125;&#125;\" aria-label=\"Next\"&gt; &lt;span aria-hidden=\"true\"&gt;下一页&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &#123;% else %&#125; &lt;li class=\"disabled\"&gt; &lt;span aria-hidden=\"true\"&gt;下一页&lt;/span&gt; &lt;/li&gt; &#123;% endif %&#125; &lt;li&gt; &lt;a href=\"?page=&#123;&#123; last_page &#125;&#125;\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;最后一页&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"ORM","slug":"ORM","permalink":"http://cjwnb.top/tags/ORM/"},{"name":"前端","slug":"前端","permalink":"http://cjwnb.top/tags/前端/"}]},{"title":"ORM之查询","slug":"ORM之查询","date":"2019-07-20T13:56:26.691Z","updated":"2019-07-20T14:04:53.025Z","comments":true,"path":"2019/07/20/ORM之查询/","link":"","permalink":"http://cjwnb.top/2019/07/20/ORM之查询/","excerpt":"","text":"正向与反向查询一对一 正向：author—关联字段在author表里—&gt;authordetail 按字段 反向：authordetail—关联字段在author表里—&gt;author 按表名小写 查询egon作者的手机号 正向查询 查询地址是 :北京市昌平区海定校区11号 的作者名字 反向查询 一对多 正向：book—关联字段在book表里—&gt;publish 按字段 反向：publish—关联字段在book表里—&gt;book 按表名小写_set.all() 因为一个出版社对应着多个图书 多对多 正向：book—关联字段在book表里—&gt;author 按字段 反向：author—关联字段在book表里—&gt;book 按表名小写_set.all() 因为一个作者对应着多个图 基于对象的跨表查询 查询书籍是三国演义的出版社的邮箱（一对多.正向查询） book_obj=models.Book.objects.filter(pk=11).first()# 一本书只会被一个出版社出版，所以直接调用和publish表的字段就可以拿到这本书所关联的出版社的那个数据对象 print(book_obj.publish) # 出版社对象的名字 空军军医大学 print(book_obj.publish.email) # 222222@163.com 查询书籍是python开发的作者姓名（多对多.正向查询） book_obj=models.Book.objects.filter(title='python开发').first()# 一本书可以被多个作者出版，所以直接调用和author表关联的字段返回就是None，调用all()方法拿到全部作者信息 print(book_obj.author) # app01.Author.None print(book_obj.author.all()) # &lt;QuerySet [&lt;Author: 作者对象的名字 egon&gt;, &lt;Author: 作者对象的名字 lyysb&gt;, &lt;Author: 作者对象的名字 szksb&gt;, &lt;Author: 作者对象的名字 lxxsb&gt;]&gt; author_name=[] for author in book_obj.author.all(): author_name.append(author.name) print(author_name) 查询作者为egon的电话号码(一对一.正向查询) user_obj=models.Author.objects.filter(name='egon').first()print(user_obj.authordetail.phone) 查询出版社是华中师范大学出版社的书籍(一对多，反向查询，需要加_set) publish_obj=models.Publish.objects.filter(name='华中师范大学出版社').first()# AttributeError: '报错 Publish' object has no attribute 'book'# 因为publish表中并没有字段book,这个时候就要加上_set获得publish_obj关联的book对象# print(publish_obj.book)# print(publish_obj.book_set) #app01.Book.None, 因为这个publish_obj这个对象关联多本书，所以返回None，加上all()print(publish_obj.book_set.all()) # 获得了publish_obj这个对象关联的所有的book表中的对象book_list=[]for book in publish_obj.book_set.all(): book_list.append(book.title)print(book_list) 查询作者电话号码是87665454445的作者姓名(一对一反向查询，不需要加_set) authordetail_obj=models.Authordetail.objects.filter(phone='87665454445').first()print(authordetail_obj.author) 查询作者egon写过的所有的书(多对多反向查询，需要加_set) author_obj=models.Author.objects.filter(name='egon').first()book_list=[]for book in author_obj.book_set.all(): book_list.append(book.title)print(book_list) 基于双下划线的跨表查询正向查询 查询书籍为三国演义的出版社地址,并打印名字 res=models.Book.objects.filter(title='三国演义').values('publish__addr','title')print(res.first()) # &#123;'publish__addr': '西安市长乐西路17号', 'title': '三国演义'&#125;print(res.first().get('publish__addr'))print(res.first().get('titile')) 查询书籍为docker入门的作者的姓名 res=models.Book.objects.filter(title='docker入门').values('author__name')print(res.first()) # &#123;'author__name': 'egon'&#125;print(res.first().get('author__name')) 查询作者为egon的地址 res=models.Author.objects.filter(name='egon').values('authordetail__addr')print(res.first().get('authordetail__addr')) 查询华中师范大学出版社的价格大于50的书 res=models.Publish.objects.filter(name='华中师范大学出版社',book__price__gt=50).values_list('book__title','book__price')book_list=[]for book in res: book_list.append(book[0])print(book_list) 反向查询 查询华中师范大学出版社出版的书的名字 publish_obj=models.Publish.objects.filter(name='华中师范大学出版社').values_list('book__title')# &lt;QuerySet [('python开发',), ('docker入门',), ('web集群',), ('红楼梦',), ('红楼梦',), ('红楼梦',)]&gt;book_list=[]for book_name in publish_obj: book_list.append(book_name[0])print(book_list) 查询电话号码为23456321234 的作者姓名 author_detail=models.Authordetail.objects.filter(phone='23456321234').values('author__name')print(author_detail.first().get('author__name')) 查询作者为egon写过的书的名字 author_object=models.Author.objects.filter(name='egon').values_list('book__title') book_list=[] for book in author_object: book_list.append(book[0]) print(book_list) 查询书籍docker入门的作者的电话号码 book_obj=models.Book.objects.filter(title='docker入门').values('author__authordetail__phone')print(book_obj.first().get('author__authordetail__phone')) 查询egon作者的手机号 res=models.Authordetail.objects.filter(author__name='egon').values('phone')print(res.first().get('phone')) 查询出版社为 北京大学出版社的图书的名字和价格 res=models.Book.objects.filter(publish__name='北京大学出版社').values_list('title','price') print(res.first()[0],res.first()[1]) 查询华中师范大学出版社的价格大于50的书 res=models.Book.objects.filter(publish__name='华中师范大学出版社',price__gt=50).values_list('title')book_list=[]for book in res: book_list.append(book[0])print(book_list) 聚合查询 aggregate()实现 就是实现mysql里的聚合函数功能 导入模块 from django.db.models import Max,Min,Count,Avg 查询python开发这本书籍对应的作者个数 from django.db.models import Max,Min,Count,Avgres = models.Book.objects.filter(pk=3).aggregate(count_num=Count('author')) print(res) 查询所有出版社的平均价格 from django.db.models import Max,Min,Count,Avg res = models.Publish.objects.aggregate(avg_price=Avg('book__price')) print(res) 分组查询annotate()实现 统计每本书的作者个数 res=models.Book.objects.annotate(count_num=Count('author')).values('title','count_num') print(res) 统计出每个出版社卖的最便宜的书的价格 res = models.Publish.objects.annotate(min_num=Min('book__price')).values('name','min_num')print(res) 查询各个作者的书的总价格 res=models.Author.objects.annotate(sum_price=Sum('book__price')).values('name','sum_price')print(res)","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"ORM","slug":"ORM","permalink":"http://cjwnb.top/tags/ORM/"}]},{"title":"ajax","slug":"ajax","date":"2019-07-20T13:35:03.598Z","updated":"2019-07-21T05:04:02.491Z","comments":true,"path":"2019/07/20/ajax/","link":"","permalink":"http://cjwnb.top/2019/07/20/ajax/","excerpt":"","text":"编码格式contenttype urlencoded 对应的数据格式:name=jason&amp;password=666后端获取数据:request.POSTps；django会将urlencoded编码的数据解析自动放到request.POST index.html &lt;body&gt;&lt;form action=\"\" method=\"post\"&gt; &lt;input type=\"text\" name=\"name\"&gt; &lt;input type=\"text\" name=\"password\"&gt; &lt;input type=\"file\" name=\"file\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt; urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index/', views.index),] views.py from django.shortcuts import renderdef index(request): print(request.POST) return render(request,'index.html') 浏览器测试查看结果,查看到默认编码是application/x-www-form-urlencoded,并且post多个数据之间用&amp;传递 查看request.POST的输出，是以字典的形式输出，上传的文件的值最后接收到的是一个文件名 formdata form表单传输文件的编码格式 后端获取文件格式数据:request.FILES 后端获取普通键值对数据:request.POST index.html &lt;form action=\"\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"text\" name=\"name\"&gt; &lt;input type=\"text\" name=\"password\"&gt; &lt;input type=\"file\" name=\"file\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index/', views.index),] views.py from django.shortcuts import renderdef index(request): print(request.FILES) print(request.POST) return render(request,'index.html') 浏览器上查看到编码方式换成了multipart/form-data 查看request.POST,request.FILES的输出 application/json ajax发送json格式数据 需要注意的点: 编码与数据格式要一致 AJAX简介向服务器发送请求的途径 浏览器地址栏，默认get请求 form表单 get请求 post请求 a 标签 AJAX 特点：1. 异步请求 AJAX 使用Javascript技术向服务器发送异步请求2. 局部刷新 AJAX无需刷新整个页面 基本语法提交的地址(url) 提交的方式(type) 提交的数据(data) 回调函数(success) $('#d1').click(function () &#123; $.ajax(&#123; // 提交的地址 url:'/index/', // 提交的方式 type:'post', // 提交的数据 data:&#123;'name':'jason','password':'123'&#125;, // 回调函数 success:function (data) &#123; // data接收的就是异步提交返回的结果 alert(data) &#125; &#125;) &#125;) ###前端 通过ajax发送数据 test.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;this is index！&lt;/h2&gt;&lt;button class=\"Ajax\"&gt;Ajax&lt;/button&gt;&lt;p class=\"content\"&gt;&lt;/p&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script&gt; $(\".Ajax\").click(function () &#123; // 发送ajax请求 $.ajax(&#123; url:\"/test_ajax/\", //请求url type:\"get\", //请求方式get/post data:&#123;a:1,b:2&#125;, //请求的数据 success:function (data) &#123; //回调函数 console.log(data); $(\".content\").html(data); &#125; &#125;) &#125;)&lt;/script&gt;&lt;/html 后端反馈数据给前端中的ajax中的data字段 ####创建视图函数 views.py from django.shortcuts import render, HttpResponsedef index(request): return render(request, \"index.html\")def test_ajax(request): print(request.GET) return HttpResponse('hello world') 绑定视图函数url.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index/', views.index), url(r'^test_ajax/', views.test_ajax),] 客户端效果####未点击Ajax按钮的状态 点击Ajax按钮的状态 实现计算器效果 前端写ajax请求test.html 通过ajax发送请求,如果使用ajax发送请求到后端，请求数据是以键值对的方式发送给后端，并不需要在input标签中指定name属性，而如果是通过form表单进行发送，是需要指定的 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"text\" id=\"num1\"&gt;+&lt;input type=\"text\" id=\"num2\"&gt;=&lt;input type=\"text\" class=\"ret\"&gt;&lt;button class=\"cal\"&gt;计算&lt;/button&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script&gt; //计算求值 $(\".cal\").click(function () &#123; $.ajax(&#123; url: \"/cal/\", type: \"post\", //&lt;input type=\"text\" id=\"num1\"&gt;+&lt;input type=\"text\" id=\"num2\"&gt; //不需要有name,只需要找到标签,通过id或class就行 //data 前端向后端发送的数据 data: &#123; n1:$(\"#num1\").val(), n2:$(\"#num2\").val(), &#125;, //success 对后端给前端反馈的数据进行处理反馈到浏览器 success:function (data) &#123; $(\".ret\").val(data) &#125; &#125;) &#125;) &lt;/script&gt;&lt;/html&gt; 创建视图函数views.py from django.shortcuts import render, HttpResponsedef cal(request): print(request.POST) n1 = request.POST.get('n1') n2 = request.POST.get('n2') ret = int(n1) + int(n2) return HttpResponse(ret) 绑定视图函数urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index/', views.index), url(r'^test_ajax/', views.test_ajax), url(r'^cal/', views.cal),] 报错信息报错1Uncaught TypeError 原因： 前端部分 在发送ajax请求时候未取到表单输入的值,找到标签后没有加 .val取值 data: &#123; n1:$(\"#num1\"), n2:$(\"#num2\"), &#125;,# 正确写法：data: &#123; n1:$(\"#num1\").val(), n2:$(\"#num2\").val(), &#125;, 报错2Uncaught ReferenceError 原因：ajax没有接受后台传送的值 $(\".cal\").click(function () &#123; $.ajax(&#123; type: 'post', url: '/cal/', data: &#123;n1: $('.n1').val(), n2: $('.n2').val()&#125;, success: function () &#123; $('.ret').val(data); &#125; &#125;) &#125;)# 正确写法 $(\".cal\").click(function () &#123; $.ajax(&#123; type: 'post', url: '/cal/', data: &#123;n1: $('.n1').val(), n2: $('.n2').val()&#125;, success: function (data) &#123; $('.ret').val(data); &#125; &#125;) &#125;) 报错3Failed to load resource: the server responded with a status of 500 (Internal Server Error) 原因: 视图函数未返回http协议的数据 def cal(request): n1 = request.POST.get('n1') n2 = request.POST.get('n2') ret = int(n1) + int(n2) return ret# 正确写法def cal(request): n1 = request.POST.get('n1') n2 = request.POST.get('n2') ret = int(n1) + int(n2) return HttpResponse(ret) 基于AJAX的登录验证index.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"\"&gt; 用户名 &lt;input type=\"text\" class=\"user\"&gt; 密码 &lt;input type=\"password\" class=\"pwd\"&gt; &lt;input type=\"button\" value=\"submit\" class=\"login-btn\"&gt; &lt;span class=\"error\"&gt;&lt;/span&gt;&lt;/form&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script&gt;$('.login-btn').click(function () &#123; $.ajax(&#123; url:\"/login/\", type:\"post\", data:&#123; user:$(\".user\").val(), pwd:$(\".pwd\").val(), &#125;, success:function (data) &#123; console.log(data); //json字符串 console.log(typeof data); //string var return_data=JSON.parse(data); //把json字符串解析成object console.log(return_data); // &#123;'user':'lyysb','msg':None&#125; console.log(typeof return_data); //object // 判断,前端把接收到的数据转换成原来的格式 &#123;'user':'lyysb','msg':None&#125; // 后台返回的数据,如果数据数据库中有用户，则返回 &#123;'user':'lyysb','msg':None&#125;,user属性不为空 // 如果数据库中没有，则返回 &#123;'user':None,'msg':'用户名或密码错误'&#125;，msg属性不为空 // 如果数据中有user属性，则跳转 // 如果没有，则插入一条错误数据，错误数据从return_data的msg属性取值 if (return_data.user)&#123; location.href=\"http://www.cjwnb.top\" &#125; else &#123; // .html 在标签内插入文本内容，.css 为标签设置css样式 $(\".error\").html(return_data.msg).css(&#123;\"color\":\"red\",\"margin-left\":0&#125;) &#125; &#125; &#125;)&#125;)&lt;/script&gt;&lt;/html&gt; urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index/', views.index), url(r'^login/', views.login),] views.py from django.shortcuts import render, HttpResponsedef login(request): if request.method == 'POST': user = request.POST.get('user') pwd = request.POST.get('pwd') obj = User.objects.filter(name=user, pwd=pwd).first() res = &#123;'user': None, 'msg': None&#125; if obj: res['user'] = obj.name else: res['msg'] = '用户名或密码错误' import json return HttpResponse(json.dumps(res, ensure_ascii=False)) models.py from django.db import modelsclass User(models.Model): name=models.CharField(max_length=32) pwd=models.CharField(max_length=32) 随意插入几条数据 浏览器测试结果 失败的结果 成功则跳转到网页 AJAX传递JSON文件请求体中的格式不再是a=1&amp;b=2，而是一个json格式 $('.标签类名').click(function () &#123; $.ajax(&#123; url:\"\", type:\"post\", contentType:\"application/json\", // 将数据序列化成json字符串 data:JSON.stringify(&#123; a:1, b:2 &#125;), success:function (data) &#123; console.log(data) &#125; &#125; ) &#125;) test.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;基于form表单的文件上传&lt;/title&gt;&lt;/head&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;body&gt;&lt;form action=\"\" method=\"post\"&gt; 用户名 &lt;input type=\"text\" name=\"user\"&gt; &lt;input type=\"button\" class=\"btn\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;script&gt; $('.btn').click(function () &#123; $.ajax(&#123; url:\"\", type:\"post\", contentType:\"application/json\", // 将数据序列化成json字符串 data:JSON.stringify(&#123; a:1, b:2 &#125;), success:function (data) &#123; console.log(data) &#125; &#125; ) &#125;)&lt;/script&gt;&lt;/html&gt; urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^file_put/', views.file_put),] views.py def file_put(request): if request.method == 'POST': print('post',request.POST) #只有contentType=urlencoded, request.POST才有数据 # post &lt;QueryDict: &#123;&#125;&gt; print('body',request.body) # 请求报文中的请求体 # body b'&#123;\"a\":1,\"b\":2&#125;' return HttpResponse('OK') return render(request, 'file_put.html') 查看到请求体中的数据是json格式的字符串 传输文件复习基于form表单的文件上传file_put.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;基于form表单的文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;基于form表单的文件上传&lt;/h3&gt;&lt;form action=\"\" method=\"post\" enctype=\"multipart/form-data\"&gt; 用户名 &lt;input type=\"text\" name=\"user\"&gt; 头像 &lt;input type=\"file\" name=\"avatar\" class=\"avatar\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^file_put/', views.file_put),] views.py def file_put(request): if request.method == 'POST': print(request.POST) # &lt;QueryDict: &#123;'user': ['changwei']&#125;&gt; print(request.FILES) file=request.FILES # &lt;MultiValueDict: &#123;'avatar': [&lt;InMemoryUploadedFile: timg (3).jpeg (image/jpeg)&gt;]&#125;&gt; file_obj=file.get('avatar') with open(file_obj.name,'wb') as f: for line in file_obj: f.write(line) return HttpResponse('OK') return render(request, 'file_put.html') 基于ajax的文件上传利用js代码找到我们要上传的文件test.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;test&lt;/title&gt; &lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"\" method=\"post\"&gt; 用户名 &lt;input type=\"text\" name=\"user\"&gt; 头像 &lt;input type=\"file\" name=\"avatar\" class=\"avatar\"&gt; &lt;input type=\"button\" class=\"btn\" value=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 浏览器console窗口 $(\".avatar\")[0] # 拿到类名是avatar的标签$(\".avatar\")[0].files[0] # 取到标签内的文件对象 file_input.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;基于ajax的文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;基于ajax的文件上传&lt;/h3&gt;&lt;form action=\"\" method=\"post\"&gt; 用户名 &lt;input type=\"text\" id=\"user\"&gt; 头像 &lt;input type=\"file\" id=\"avatar\"&gt; &lt;input type=\"button\" id=\"btn\" value=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt; $(\"#btn\").click(function () &#123; var formdata = new FormData(); formdata.append(\"user\", $(\"#user\").val()); console.log(formdata); formdata.append(\"avatar\", $(\"#avatar\")[0].files[0]); console.log(formdata); $.ajax(&#123; url: \"\", type: \"post\", contentType: false, processData: false, data: formdata, success: function (data) &#123; console.log(data) &#125; &#125;) &#125;)&lt;/script&gt;&lt;/html&gt; urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^file_put/', views.file_put),] views.py def file_put(request): print(request.method) if request.method == 'POST': print('body', request.body) print('post',request.POST) print('files',request.FILES) file_obj=request.FILES.get('avatar') with open(file_obj.name,'wb') as f: for line in file_obj: f.write(line) return HttpResponse('OK') return render(request, 'file_put.html') 坑点在上述请求中，视图函数views.py中，如果想要看请求体的内容（request.body），又想看POST请求的内容(request.POST)，那么必须将请求体的打印信息写在POST请求之前 报错代码 def file_put(request): print(request.method) if request.method == 'POST': print('post',request.POST) print('body', request.body) print('files',request.FILES) file_obj=request.FILES.get('avatar') with open(file_obj.name,'wb') as f: for line in file_obj: f.write(line) return HttpResponse('OK') return render(request, 'file_put.html') 报错信息 django.http.request.RawPostDataException: You cannot access body after reading from request’s data stream","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"前后台交互","slug":"前后台交互","permalink":"http://cjwnb.top/tags/前后台交互/"},{"name":"AJAX","slug":"AJAX","permalink":"http://cjwnb.top/tags/AJAX/"}]},{"title":"多对多表的创建方式以及分页","slug":"多对多表的三种创建方式","date":"2019-07-20T13:21:22.402Z","updated":"2019-07-21T12:04:53.105Z","comments":true,"path":"2019/07/20/多对多表的三种创建方式/","link":"","permalink":"http://cjwnb.top/2019/07/20/多对多表的三种创建方式/","excerpt":"","text":"多对多表三种创建方式第一种django orm自动创建 class Book(models.Model): name = models.CharField(max_length=32) authors = models.ManyToManyField(to='Author')class Author(models.Model): name = models.CharField(max_length=32) 第二种手动创建第三张表 class Book(models.Model): name = models.CharField(max_length=32) class Author(models.Model): name = models.CharField(max_length=32) class Book2Author(models.Model): book = models.ForeignKey(to='Book') author = models.ForeignKey(to='Author') info = models.CharField(max_length=32) 第三种半自动创建第三张表(可扩展性高，并且能够符合orm查询) class Book(models.Model): name = models.CharField(max_length=32) # 第三种创建表的方式 authors = models.ManyToManyField(to='Author',through='Book2Author',through_fields=('book','author'))class Author(models.Model): name = models.CharField(max_length=32) book = models.ManyToManyField(to='Book',through='Book2Author',through_fields=('author','book'))class Book2Author(models.Model): book = models.ForeignKey(to='Book') author = models.ForeignKey(to='Author') info = models.CharField(max_length=32) 案例 查询书籍对应的作者 ​ models.py from django.db import models# Create your models here.class Book(models.Model): name = models.CharField(max_length=32) authors=models.ManyToManyField(to='Author',through='Book2Author',through_fields=('book','author'))class Author(models.Model): name = models.CharField(max_length=32)class Book2Author(models.Model): book = models.ForeignKey(to='Book') author = models.ForeignKey(to='Author') info=models.CharField(max_length=64) tests.py import osif __name__ == \"__main__\": os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"ajax.settings\") import django django.setup() from app01 import models res=models.Book.objects.filter(pk=1).values('authors__name') print(res) # &lt;QuerySet [&#123;'authors__name': 'lyysb'&#125;, &#123;'authors__name': 'hhpsb'&#125;]&gt; book_obj=models.Book.objects.filter(pk=1).first() res=book_obj.authors.all() print(res)","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"ORM","slug":"ORM","permalink":"http://cjwnb.top/tags/ORM/"},{"name":"模型层","slug":"模型层","permalink":"http://cjwnb.top/tags/模型层/"}]},{"title":"F查询和Q查询，事务及其他","slug":"F查询和Q查询，事务及其他","date":"2019-07-20T06:19:22.020Z","updated":"2019-07-22T01:22:52.723Z","comments":true,"path":"2019/07/20/F查询和Q查询，事务及其他/","link":"","permalink":"http://cjwnb.top/2019/07/20/F查询和Q查询，事务及其他/","excerpt":"","text":"更多资料： https://www.cnblogs.com/Dominic-Ji/p/9213887.html F与Q查询在上面所有的例子中，我们构造的过滤器都只是将字段值与某个我们自己设定的常量做比较。如果我们要对两个字段的值做比较，那该怎么做呢？ Django 提供 F() 来做这样的比较。F() 的实例可以在查询中引用字段，来比较同一个 model 实例中两个不同字段的值。 settings.py MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',]DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'ORM2', 'PORT': 3306, 'HOST': '127.0.0.1', 'USER': 'root', 'PASSWORD': 123 &#125;&#125; init.py import pymysqlpymysql.install_as_MySQLdb() models.py from django.db import models# Create your models here.class Product(models.Model): name = models.CharField(max_length=32) price = models.DecimalField(max_digits=8, decimal_places=2) maichu = models.IntegerField() kucun = models.IntegerField() def __str__(self): return '对象的名字：%s'%self.name 执行命令创建表 pycharm菜单-tools-run manage.py TASK$ makemigrations$ migrate tests.py from django.test import TestCase# Create your tests here.import osif __name__ == \"__main__\": os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"ORM2.settings\") import django django.setup() from app01 import models 初始数据 F查询 查询卖出数大于库存数的商品 from django.db.models import F,Q # F查询 给一个字段就能拿到字段的值 res=models.Product.objects.filter(maichu__gt=F('kucun')) print(res) 将所有商品的价格提高100块 models.Product.objects.update(price=F('price')+100) 将所有商品的名字后面都加上一个爆款 from django.db.models.functions import Concat from django.db.models import Value models.Product.objects.update(name=Concat(F('name'),Value('爆款'))) Q查询 查询价格是288.88并且名字是衣服同款爆款的商品 与查询 from django.db.models import Q from django.db.models import Q res = models.Product.objects.filter(Q(price='288.88'),Q(name='衣服爆款')) # 这里 第一个Q参数后面必须是传字符串，如果传数字（Q(price=288.88)），无法查询出对象 print(res) 或查询 查询价格是288.88或者名字是帽子同款爆款的商品 from django.db.models import Qres = models.Product.objects.filter(Q(price='288.88') | Q(name='裤子爆款')) # or print(res) # &lt;QuerySet [&lt;Product: 对象的名字：衣服爆款&gt;, &lt;Product: 对象的名字：裤子爆款&gt;]&gt; 混合使用 需要注意的是Q对象必须放在普通的过滤条件前面 查询价格不是288.88并且名字是裤子爆款的商品 res=models.Product.objects.filter(~Q(price='288.88'),Q(name='裤子爆款'))print(res) 查询价格不是288.88或者名字是裤子爆款的商品 res=models.Product.objects.filter(Q(name='裤子爆款')|~Q(price='288.88'))print(res) Q对象补充Q的源码 class Q(tree.Node): \"\"\" Encapsulates filters as objects that can then be combined logically (using `&amp;` and `|`). \"\"\" # Connection types AND = 'AND' OR = 'OR' default = AND def __init__(self, *args, **kwargs): super(Q, self).__init__(children=list(args) + list(kwargs.items() Q本身就是一个类，实例化一个对象，将所有的条件传入children这个属性中，而children这个属性是是列表，将条件写成一个小元组的方式作为一个整体传入children这个列表，小元组的第一个元素是字段名，第二个元素是写希望字段名符合的条件 例如 Q=q()q.children.append((‘字段名’，‘条件’)) 查询价格是288.88或者名字是帽子同款爆款的商品 from django.db.models import F, Q q = Q()q.connector = 'or'q.children.append(('price', '288.88'))q.children.append(('name', '裤子爆款'))res = models.Product.objects.filter(q) # # Q对象查询默认也是and print(res) 查询价格是288.88或者名字是衣服爆款的商品 from django.db.models import F, Q q = Q()q.children.append(('price', '288.88'))q.children.append(('name', '衣服爆款'))res = models.Product.objects.filter(q) # # Q对象查询默认也是and print(res) 事务事务的ACID 原子性一致性 隔离性持久性 id=1的商品卖出去一件 from django.db import transactionfrom django.db.models import Fwith transaction.atomic(): # 在with代码块儿写你的事务操作 models.Product.objects.filter(id=1).update(kucun=F('kucun') - 1) models.Product.objects.filter(id=1).update(maichu=F('maichu') + 1) 自定义ORM字段models.py from django.db import modelsclass MycharField(models.Field): def __init__(self,max_length,*args,**kwargs): self.max_length=max_length super().__init__(max_length=max_length,*args,**kwargs) def db_type(self,connection): return 'char(%s)'%self.max_lengthclass Product(models.Model): name = models.CharField(max_length=32) # 都是类实例化的对象 price = models.DecimalField(max_digits=8, decimal_places=2) maichu = models.IntegerField() kucun = models.IntegerField() info=MycharField(max_length=32,null=True) # 该字段可以为空 def __str__(self): return '对象的名字：%s'%self.name 执行manage.py命令 菜单-tools-Run manager.py Task$ makemigrations$ migrate only与defer res = models.Product.objects.filter(id=1).values('name').first()print(res) 这个过程中执行了3条sql语句 (0.000) SELECT @@SQL_AUTO_IS_NULL; args=None(0.000) SELECT VERSION(); args=None(0.000) SELECT `app01_product`.`name` FROM `app01_product` WHERE `app01_product`.`id` = 1 LIMIT 21; args=(1,) only 如果取only指定的字段，不去数据库取值，直接在应用程序的缓存中取值 案例1res=models.Product.objects.filter(pk=1).only('name').first()print(res.name) 这个过程执行了3条SQL语句 (0.000) SELECT @@SQL_AUTO_IS_NULL; args=None(0.000) SELECT VERSION(); args=None(0.000) SELECT `app01_product`.`id`, `app01_product`.`name` FROM `app01_product` WHERE `app01_product`.`id` = 1 ORDER BY `app01_product`.`id` ASC LIMIT 1; args=(1,) 案例2res=models.Product.objects.filter(pk=1).only('name').first()print(res.price) 这个过程中执行了4条SQL语句，因为price字段不在only里面配置，所以price字段的值是去数据库里面取 (0.000) SELECT @@SQL_AUTO_IS_NULL; args=None(0.000) SELECT VERSION(); args=None(0.000) SELECT `app01_product`.`id`, `app01_product`.`name` FROM `app01_product` WHERE `app01_product`.`id` = 1 ORDER BY `app01_product`.`id` ASC LIMIT 1; args=(1,)(0.000) SELECT `app01_product`.`id`, `app01_product`.`price` FROM `app01_product` WHERE `app01_product`.`id` = 1; args=(1,) defer 与only相反，如果取defer指定的字段，则是去数据库取值，其他的字段直接在应用程序的缓存中取值 案例1res=models.Product.objects.filter(pk=1).defer('name').first()print(res.name) 执行了4条SQL语句 (0.000) SELECT @@SQL_AUTO_IS_NULL; args=None(0.000) SELECT VERSION(); args=None(0.000) SELECT `app01_product`.`id`, `app01_product`.`price`, `app01_product`.`maichu`, `app01_product`.`kucun`, `app01_product`.`info` FROM `app01_product` WHERE `app01_product`.`id` = 1 ORDER BY `app01_product`.`id` ASC LIMIT 1; args=(1,)(0.000) SELECT `app01_product`.`id`, `app01_product`.`name` FROM `app01_product` WHERE `app01_product`.`id` = 1; args=(1,) 案例2res=models.Product.objects.filter(pk=1).defer('name').first()print(res.price) 执行了3条SQL语句 (0.000) SELECT @@SQL_AUTO_IS_NULL; args=None(0.000) SELECT VERSION(); args=None(0.001) SELECT `app01_product`.`id`, `app01_product`.`price`, `app01_product`.`maichu`, `app01_product`.`kucun`, `app01_product`.`info` FROM `app01_product` WHERE `app01_product`.`id` = 1 ORDER BY `app01_product`.`id` ASC LIMIT 1; args=(1,) 字段choicesmodels.py from django.db import modelsclass Product(models.Model): name = models.CharField(max_length=32) # 都是类实例化的对象 price = models.DecimalField(max_digits=8, decimal_places=2) maichu = models.IntegerField() kucun = models.IntegerField() info=MycharField(max_length=32,null=True) # 该字段可以为空 choices=((1,'男'),(2,'女'),(3,'其他')) gender=models.IntegerField(choices=choices,default=2) def __str__(self): return '对象的名字：%s'%self.name 更新字段操作 菜单-tools-Run manager.py Task$ makemigrations$ migrate tests.py import osif __name__ == \"__main__\": os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"ORM2.settings\") import django django.setup() from app01 import models res=models.Product.objects.filter(id=1).first() print(res.get_gender_display()) # 获取编号对应的中文注释","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"ORM","slug":"ORM","permalink":"http://cjwnb.top/tags/ORM/"}]},{"title":"ORM基础","slug":"ORM基础","date":"2019-07-18T12:14:06.052Z","updated":"2019-07-20T14:05:03.289Z","comments":true,"path":"2019/07/18/ORM基础/","link":"","permalink":"http://cjwnb.top/2019/07/18/ORM基础/","excerpt":"","text":"更多资料： https://www.cnblogs.com/Dominic-Ji/p/9203990.html Django终端打印SQL语句 如果你想知道你对数据库进行操作时，Django内部到底是怎么执行它的sql语句时可以加下面的配置来查看, 在Django项目的settings.py文件中，在最后复制粘贴如下代码： LOGGING = &#123; 'version': 1, 'disable_existing_loggers': False, 'handlers': &#123; 'console':&#123; 'level':'DEBUG', 'class':'logging.StreamHandler', &#125;, &#125;, 'loggers': &#123; 'django.db.backends': &#123; 'handlers': ['console'], 'propagate': True, 'level':'DEBUG', &#125;, &#125;&#125; 配置好之后，再执行任何对数据库进行操作的语句时，会自动将Django执行的sql语句打印到pycharm终端上 补充： 除了配置外，还可以通过.query即可查看查询语句，具体操作如下： 单表操作环境准备settings.py MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',]DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'orm', 'HOST': '127.0.0.1', 'PORT': 3306, 'USER': 'root', 'PASSWORD': 123 &#125;&#125; __init__.py import pymysqlpymysql.install_as_MySQLdb() models.py from django.db import modelsclass User(models.Model): name = models.CharField(max_length=32) pwd = models.IntegerField() register_time = models.DateTimeField() def __str__(self): return self.name tests.py 所有测试数据库操作都在这个文件里做 import osif __name__ == \"__main__\": os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"ORM.settings\") import django django.setup() from app01 import models # 必须在这里导入，如果写在上面就会报错 新增数据基于create创建from django.utils import timezone from datetime import date ctime=date.today() models.User.objects.create(name='lyysb', pwd=123, register_time=ctime) # &lt;class 'app01.models.User'&gt; 数据插入成功了，但是有如下报错 /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/django/db/models/fields/__init__.py:1393: RuntimeWarning: DateTimeField User.register_time received a naive datetime (2019-07-18 00:00:00) while time zone support is active. RuntimeWarning) 解决方案: 导入django时间模块 from django.utils import timezone ctime = date.today() 改为 ctime = timzone.now() 或者在 settings.py 文件中设置：USE_TZ = False (这个参数指的是是否用UTC时间存入数据库) from django.utils import timezonectime = timezone.now()models.User.objects.create(name='lyysb', pwd=123, register_time=ctime) 基于对象的绑定方法创建from django.utils import timezonectime = timezone.now()user_obj = models.User(name='lxxsb', pwd=123, register_time=ctime)user_obj.save() 修改数据基于对象user_obj = models.User.objects.filter(name='lyysb').first()user_obj.name = 'xxx'user_obj.save() 基于queryset对象models.User.objects.filter(name='xxx').update(pwd=456) 删除数据基于对象user_obj = models.User.objects.filter(name='xxx').first() user_obj.delete() 基于querysetmodels.User.objects.filter(name='hppsb').delete() 查询数据 queryset对象是一个集合，这个集合里面存着数据库里每一行的数据的对象 queryset对象都是通过 models.类名.objects.方法 获得 queryset 对象可以通过 models.类名.objects.方法.query 获得具体的SQL语句 all() 查询所有结果,返回queryset对象 要取出对象，使用for循环或者索引取值 注意 : 索引取值不支持负数索引 user_obj = models.User.objects.all() # queryset对象for user in user_obj: print(user.name) 不能用负数取索引 报错 AssertionError: Negative indexing is not supported. res=models.User.objects.all() print(res[-1]) filter(**kwargs) 它包含了与所给筛选条件相匹配的对象 filter内可以放多个限制条件但是需要注意的是多个条件之间是and关系 queryset对象里只有一条数据，直接用first方法取出数据 # &lt;QuerySet [&lt;User: 对象的名字: hhp&gt;]&gt;obj = models.User.objects.filter(name='hhp', pwd=11)res = obj.first()print(res, res.name, res.pwd, res.register_time) queryset对象里有两条条数据，使用for循环或者索引方式取值 obj = models.User.objects.filter(name='lvsb', pwd=66)for res in obj: print(res, res.name, res.pwd, res.register_time) get(**kwargs) 返回与所给筛选条件相匹配的对象，返回结果有且只有一个，如果符合筛选条件的对象超过一个或者没有都会抛出错误, 所以不推荐使用 查询成功的案例 obj=models.User.objects.get(name='zf1')print(obj) 查询失败的案例 出现报错 &gt;&gt;&gt; app01.models.MultipleObjectsReturned: get() returned more than one User – it returned 2! obj=models.User.objects.get(name='lvsb',pwd=66) exclude(**kwargs) 包含了与所给筛选条件不匹配的对象 res = models.User.objects.exclude(name='zf2')for user in res: if user.name == 'zf2': print('exclude失败') else: print('exclude成功') order_by(*field) 对查询结果排序 默认是升序，models.类名.objects.order_by(‘字段名’) 如果要降序，models.类名.objects.order_by(‘-字段名’) order_nor = models.User.objects.order_by('id')res_abnor = models.User.objects.order_by('-id')print(order_nor)print(res_abnor) reverse() 对查询结果反向排序 &gt;&gt; &gt; 前面要先有排序才能反向 res=models.User.objects.order_by('id').reverse() print(res) count() 返回数据库中匹配查询(QuerySet) 的对象数量, 不加filter默认查询所有 统计所有的数量 res=models.User.objects.count() # 等同于res=models.User.objects.all().count()print(res) 统计符合条件的数量 res=models.User.objects.filter(name='hhp').count() print(res) first() 返回queryset对象的第一条记录 res=models.User.objects.all().first() # 等同于 res=models.User.objects.first() print(res) last() 返回queryset对象的最后一条记录 res=models.User.objects.all().last() # 等同于 res=models.User.objects.last() print(res) exists() 如果QuerySet包含数据，就返回True，否则返回False res=models.User.objects.exists()print(res)res1=models.User.objects.filter(name='hhp',pwd=11).exists()print(res1)res2=models.User.objects.filter(name='hhp',pwd=123222).exists()print(res2) values(*field) 返回一个ValueQuerySet——一个特殊的QuerySet，运行后得到的并不是一系列model的实例化对象，而是一个可迭代的字典序列 res=models.User.objects.values('name')print(res)# &lt; QuerySet[# &#123;'name': 'hhp'&#125;, &#123;'name': 'hhp'&#125;, &#123;'name': 'hhp3'&#125;,# &#123;'name': 'zzsb1'&#125;, &#123;'name': 'zzsb2'&#125;, &#123;'name': 'lvsb'&#125;,# &#123;'name': 'lvsb'&#125;, &#123;'name': 'zf1'&#125;, &#123;'name': 'zf2'&#125;,# &#123;'name': 'ztsb'&#125;, &#123;'name': 'ztsb2'&#125;, &#123;'name': 'lxxsb'&#125;,# &#123;'name': 'lyysb'&#125;, &#123;'name': 'lzzsb'&#125;, &#123;'name': 'szksb'&#125;] &gt;res2=models.User.objects.values('name','pwd')print(res2)# &lt; QuerySet[&#123;'name': 'hhp', 'pwd': 11&#125;, &#123;'name': 'hhp', 'pwd': 22&#125;, # &#123;'name': 'hhp3', 'pwd': 33&#125;, &#123;'name': 'zzsb1','pwd': 44&#125;, # &#123;'name': 'zzsb2', 'pwd': 55&#125;, &#123;'name': 'lvsb', 'pwd': 66&#125;, # &#123;'name': 'lvsb', 'pwd': 66&#125;, &#123;'name': 'zf1', 'pwd': 88&#125;,# &#123;'name': 'zf2', 'pwd': 99&#125;, &#123;'name': 'ztsb', 'pwd': 111&#125;, # &#123; 'name': 'ztsb2', 'pwd': 222&#125;, &#123;'name': 'lxxsb', 'pwd': 333&#125;, # &#123;'name': 'lyysb', 'pwd': 444&#125;, &#123;'name': 'lzzsb', 'pwd': 555&#125;, # &#123;'name': 'szksb', 'pwd': 666&#125;] &gt; values_list(*field) 它与values() 非常相似，它返回的是一个元组序列，values返回的是一个字典序列,values_list返回的是一个元组序列 res=models.User.objects.values_list('name','pwd')print(res)# &lt; QuerySet[('hhp', 11), ('hhp', 22), ('hhp3', 33), ('zzsb1', 44),# ('zzsb2', 55), ('lvsb', 66), ('lvsb', 66), ('zf1', 88), ('zf2', 99),# ('ztsb', 111), ('ztsb2', 222), ('lxxsb', 333), ('lyysb', 444), # ('lzzsb', 555), ('szksb', 666)] &gt; distinct() 从返回结果中剔除重复纪录 去重的对象必须是完全相同的数据才能去重 res = models.User.objects.values('name', 'pwd').distinct() print(res) # &lt; QuerySet[&#123;'name': 'hhp', 'pwd': 11&#125;, &#123;'name': 'hhp3', 'pwd': 33&#125;, &#123;'name': 'zzsb1', 'pwd': 44&#125;, # &#123;'name': 'zzsb2','pwd': 55&#125;, &#123;'name': 'lvsb', 'pwd': 66&#125;, &#123;'name': 'zf1', 'pwd': 88&#125;, # &#123;'name': 'zf2', 'pwd': 99&#125;, &#123;'name': 'ztsb', 'pwd': 111&#125;, &#123; 'name': 'ztsb2', 'pwd': 222&#125;, # &#123;'name': 'lxxsb', 'pwd': 333&#125;, &#123;'name': 'lyysb', 'pwd': 444&#125;, &#123;'name': 'lzzsb', 'pwd': 555&#125;, # &#123;'name': 'szksb', 'pwd': 666&#125;, &#123;'name': 'hhp', 'pwd': 22&#125;] &gt; res2 = models.User.objects.values('name').distinct() print(res2) # &lt; QuerySet[&#123;'name': 'hhp'&#125;, &#123;'name': 'hhp3'&#125;, &#123;'name': 'zzsb1'&#125;, &#123;'name': 'zzsb2'&#125;, # &#123;'name': 'lvsb'&#125;, &#123;'name': 'zf1'&#125;, &#123;'name': 'zf2'&#125;, &#123;'name': 'ztsb'&#125;, &#123;'name': 'ztsb2'&#125;, # &#123;'name': 'lxxsb'&#125;, &#123;'name': 'lyysb'&#125;, &#123;'name': 'lzzsb'&#125;, &#123;'name': 'szksb'&#125;] &gt; 双下划线查询 查询密码大于44的用户 res=models.User.objects.filter(pwd__gt=44) print(res) 查询密码小于44的用户 res=models.User.objects.filter(pwd__lt=44)print(res) 查询密码大于等于44的用户 res=models.User.objects.filter(pwd__gte=44)print(res) 查询密码小于等于44的用户 res=models.User.objects.filter(pwd__lte=44)print(res) 查询密码是22，33，44的用户 res=models.User.objects.filter(pwd__in=[22,33,44])print(res) 查询密码在22到111之间的用户 res=models.User.objects.filter(pwd__range=[22,111]) #包头包尾print(res) 查询名字中包含字母sb的用户 res=models.User.objects.filter(name__contains='sb')print(res) 查询名字以z开头的用户 res=models.User.objects.filter(name__startswith='z')print(res) 查询名字以sb结尾的用户 res=models.User.objects.filter(name__endswith='sb') print(res) 查询注册是在2017年的用户 res=models.User.objects.filter(register_time__year=2017)print(res) 查询2.14注册的用户 res=models.User.objects.filter(register_time__year=2017,register_time__month=2,register_time__day=14)print(res) 多表操作表与表之间的关系 一对一(OneToOneField):一对一字段无论建在哪张关系表里面都可以，但是推荐建在查询频率比较高的那张表里面 一对多(ForeignKey):一对多字段建在多的那一方 多对多(ManyToManyField):多对多字段无论建在哪张关系表里面都可以，但是推荐建在查询频率比较高的那张表里面 ps:如何判断表与表之间到底是什么关系 换位思考:A能不能有多个BB能不能有多个A 一对多字段名的增删改models.py from django.db import models# Create your models here.from django.db import modelsclass Book(models.Model): title = models.CharField(max_length=32) price = models.DecimalField(max_digits=8, decimal_places=2) # 配置上auto_now=True，每次更新数据记录的时候会更新该字段 publish_date = models.DateField(auto_now=True) publish = models.ForeignKey(to='Publish') # 多对一关系 author = models.ManyToManyField(to='Author') # 多对多关系 def __str__(self): return '书籍对象的名字 %s' % self.titleclass Publish(models.Model): name = models.CharField(max_length=64) addr = models.CharField(max_length=200) email = models.EmailField() def __str__(self): return '出版社对象的名字 %s' % self.nameclass Author(models.Model): name = models.CharField(max_length=32) age = models.IntegerField() authordetail = models.OneToOneField(to='Authordetail') def __str__(self): return '作者对象的名字 %s' % self.nameclass Authordetail(models.Model): phone = models.CharField(max_length=11) addr = models.CharField(max_length=200 tests.py import osif __name__ == \"__main__\": os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"ORM.settings\") import django django.setup() from app01 import models 预先插入一些数据 # pushlish表插入数据models.Publish.objects.create(name='江苏科学技术出版社',addr='南京市湖南路1号凤凰广场18层',email='4222222@ggg.com')#authordetail表插入数据models.Authordetail.objects.create(phone='76654444444',addr='北京市昌平区海定校区11号') 新增数据 直接写id user_obj=models.Book.objects.create(title='红楼梦',price=44.56,publish_id=1) 传数据对象 publish_obj=models.Publish.objects.filter(pk=2).first()models.Book.objects.create(title='三国演义',price=111.11,publish=publish_obj) 修改数据 queryset修改 直接写id models.Book.objects.filter(pk=2).update(publish_id=5) 传数据对象 publish_object=models.Publish.objects.filter(pk=2).first() models.Book.objects.filter(pk=2).update(publish=publish_object) 对象修改 直接修改 book_obj=models.Book.objects.filter(pk=2).first() book_obj.publish_id=5 # 点表中真实存在的字段名 book_obj.save() 传数据对象重新赋值并保存 book_obj=models.Book.objects.filter(pk=2).first()publish_obj=models.Publish.objects.filter(pk=1).first()book_obj.publish=publish_obj # 点orm中字段名 传该字段对应的表的数据对象book_obj.save() 删除models.Book.objects.filter(pk=2).delete() # 删除book表中id等于2的数据models.Publish.objects.filter(pk=5).delete() # 将publish表中的id=5的数据删除，并且将book表中关联这个id的数据也删除 给书籍绑定与作者之间的关系 add() 添加关系，add支持传数字或对象，并且都可以传多个 传1个数字 book_obj=models.Book.objects.filter(pk=3).first()book_obj.author.add(1) 传多个数字 book_obj=models.Book.objects.filter(pk=3).first()book_obj.author.add(2,3,4) 传1个对象 book_obj=models.Book.objects.filter(pk=4).first()author_obj=models.Author.objects.filter(pk=1).first()book_obj.author.add(author_obj) 传多个对象 book_obj=models.Book.objects.filter(pk=4).first()author_obj=models.Author.objects.all()book_obj.author.add(*author_obj) set() 修改书籍与作者的关系 set() set传的必须是可迭代对象！！！ book_obj=models.Book.objects.filter(pk=4).first() # 必须是数据的对象，不能是queryset对象book_obj.author.set((1,)) # set()里面穿的参数必须是可迭代对象 book_obj=models.Book.objects.filter(pk=4).first()book_obj.author.set((2,3)) book_obj=models.Book.objects.filter(pk=4).first()author_list=models.Author.objects.all()book_obj.author.set(author_list) remove() 删除书籍与作者的绑定关系 book_obj=models.Book.objects.filter(pk=4).first()author_obj=models.Author.objects.filter(pk=1).first()book_obj.author.remove(author_obj) book_obj=models.Book.objects.filter(pk=4).first() author_list=models.Author.objects.all() book_obj.author.remove(*author_list) clear() 清空的是你当前这个表记录对应的绑定关系 先将数据加下看效果 book_obj=models.Book.objects.filter(pk=4).first()author_list=models.Author.objects.all()book_obj.author.add(*author_list) 清空数据 book_obj=models.Book.objects.filter(pk=4).first()book_obj.author.clear()","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"ORM","slug":"ORM","permalink":"http://cjwnb.top/tags/ORM/"}]},{"title":"模板层","slug":"模板层","date":"2019-07-17T13:25:13.623Z","updated":"2019-07-20T09:02:11.422Z","comments":true,"path":"2019/07/17/模板层/","link":"","permalink":"http://cjwnb.top/2019/07/17/模板层/","excerpt":"","text":"面向对象复习class Foo(object): def __init__(self, name, age): self.name = name self.age = age def func(self): return self.name @classmethod def cls(cls): return 'cls' @staticmethod def Bar(): return 'bar'obj=Foo(name='lyysb',age=38)print(obj.__dict__) # &#123;'name': 'lyysb', 'age': 38&#125;print(obj.cls()) # clsprint(obj.Bar()) # bar 语法传参 只需要记两种特殊符号： &#123;&#123; &#125;&#125;和 &#123;% %&#125;变量相关的用&#123;&#123;&#125;&#125;，逻辑相关的用&#123;%%&#125;。 后端朝前端页面传递数据的方式# 第一种return render(request,'index.html',&#123;'n':n&#125;)# 第二种return render(request,'index.html',locals()) # 将当前所在的名称空间中的名字全部传递给前端页面 后端传函数名到前端，会自动加括号调用，但是不支持传参后端传对象到前端，就相当于打印了这个对象前端获取后端传过来的容器类型的内部元素 统一采用句点符(.)前端能够调用python后端数据类型的一些不需要传参的内置方法,如果有参数，则前端无法调用 urls.py` from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index',views.index)] views.py from django.shortcuts import render, HttpResponse# Create your views here.def index(request): name = \"lyysb\" i = 10 l = [111, 22, 333] info = &#123;'name': 'lyysb', 'age': 38&#125; b = True def abc(): return 'abc' class Foo(object): def __init__(self, name, age): self.name = name self.age = age def func(self): return self.name @classmethod def cls(cls): return 'cls' @staticmethod def Bar(): return 'bar' obj = Foo(name='lyysb', age=38) return render(request, 'index.html', locals()) index.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&#123;&#123; name &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; i &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; l &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; info &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; b &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; abc &#125;&#125;&lt;/p&gt;&#123;# 取出类对象以及其属性 #&#125;&lt;p&gt;&#123;&#123; obj &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; obj.name &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; obj.age &#125;&#125;&lt;/p&gt;&#123;# 取出列表中的某个元素 #&#125;&lt;p&gt;&#123;&#123; l.0 &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; l.1 &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; l.2 &#125;&#125;&lt;/p&gt;&#123;# 取出字典中的key,value #&#125;&lt;p&gt;&#123;&#123; info.keys &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; info.values &#125;&#125;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 过滤器在Django的模板语言中，通过使用 过滤器 来改变变量的显示。 过滤器的语法： &#123;&#123; value|filter_name:参数 &#125;&#125;使用管道符\"|\"来应用过滤器。例如：&#123;&#123; name|lower &#125;&#125;会将name变量应用lower过滤器之后再显示它的值。lower在这里的作用是将文本全都变成小写。 注意事项 1.过滤器支持“链式”操作。即一个过滤器的输出作为另一个过滤器的输入。2.过滤器可以接受参数，例如：&#123;&#123; sss|truncatewords:30 &#125;&#125;，这将显示sss的前30个词。3.过滤器参数包含空格的话，必须用引号包裹起来。比如使用逗号和空格去连接一个列表中的元素，如：&#123;&#123; list|join:', ' &#125;&#125;4.'|'左右没有空格没有空格没有空格 Django的模板语言中提供了大约六十个内置过滤器 default 如果一个变量是false或者为空，使用给定的默认值。 否则，使用变量的值 &#123;&#123; value|default:\"nothing\"&#125;&#125; 如果value没有传值或者值为空的话就显示nothing length 返回值的长度，作用于字符串和列表。 &#123;&#123; value|length &#125;&#125; 返回value的长度，如 value=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]的话，就显示4. filesizeformat 将值格式化为一个 “人类可读的” 文件尺寸 （例如 &#39;13 KB&#39;, &#39;4.1 MB&#39;, &#39;102 bytes&#39;, 等等 &#123;&#123; value|filesizeformat &#125;&#125; 如果 value 是 123456789，输出将会是 117.7 MB slice 切片 &#123;&#123;value|slice:\"2:-1\"&#125;&#125; date 格式化 &#123;&#123; value|date:\"Y-m-d H:i:s\"&#125;&#125; safe Django的模板中会对HTML标签和JS等语法标签进行自动转义，原因显而易见，这样是为了安全。但是有的时候我们可能不希望这些HTML元素被转义，比如我们做一个内容管理系统，后台添加的文章中是经过修饰的，这些修饰可能是通过一个类似于FCKeditor编辑加注了HTML修饰符的文本，如果自动转义的话显示的就是保护HTML标签的源文件。为了在Django中关闭HTML的自动转义有两种方式，如果是一个单独的变量我们可以通过过滤器“|safe”的方式告诉Django这段代码是安全的不必转义。 &#123;&#123; value|safe&#125;&#125; truncatechars 如果字符串字符多于指定的字符数量，那么会被截断。截断的字符串将以可翻译的省略号序列（“…”）结尾。 参数：截断的字符数 &#123;&#123; value|truncatechars:9&#125;&#125; truncatewords 在一定数量的字后截断字符串。 &#123;&#123; value|truncatewords:9&#125;&#125; cut 移除value中所有的与给出的变量相同的字符串 &#123;&#123; value|cut:' ' &#125;&#125; 如果value为&#39;i love you&#39;，那么将输出&#39;iloveyou&#39;. join 使用字符串连接列表，例如Python的str.join(list) 时间模块复习from time import strptimeblog_date = strptime('2018-1-1', \"%Y-%m-%d\")comment_date = strptime('2018-1-1', \"%Y-%m-%d\")print(blog_date,comment_date)# time.struct_time(tm_year=2018, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=0, tm_yday=1, tm_isdst=-1) # time.struct_time(tm_year=2018, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=0, tm_yday=1, tm_isdst=-1)import datetimeblog_date = datetime.date(2018, 1, 1)comment_date = datetime.date(2019, 1, 1)print(blog_date,comment_date)# 2018-01-01 # 2019-01-01 timesince 将日期格式设为自该日期起的时间（例如，“4天，6小时”） 采用一个可选参数，它是一个包含用作比较点的日期的变量（不带参数，比较点为现在) 例如，如果blog_date是表示2006年6月1日午夜的日期实例，并且comment_date是2006年6月1日08:00的日期实例，则以下将返回“8小时”： &#123;&#123; blog_date|timesince:comment_date &#125;&#125;在后端blog_data,comment_data必须是日期对象,使用datetime模块中的datetime.date()生成 分钟是所使用的最小单位，对于相对于比较点的未来的任何日期，将返回“0分钟”。 timeuntil对于timesince，除了它测量从现在开始直到给定日期或日期时间的时间。 例如，如果今天是2006年6月1日，而conference_date是保留2006年6月29日的日期实例，则&#123;&#123; conference_date | timeuntil &#125;&#125;将返回“4周”。使用可选参数，它是一个包含用作比较点的日期（而不是现在）的变量。 如果from_date包含2006年6月22日，则以下内容将返回“1周”： &#123;&#123; conference_date|timeuntil:from_date &#125;&#125; 案例urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index',views.index)] views.py from django.shortcuts import render# Create your views here.def index(request): n = 6969 s = '您好 我是 23 号技 师 很高兴 为您 服务，希望您 能满意!（不带换的' file_size = 1113 from datetime import datetime ctime = datetime.now() res = 'hello big baby baby baby baby' ht = '&lt;h1&gt;我是h1标签&lt;/h1&gt;' cut = 'i love you' join_str = 'lyysupersb' join_list = [1, 2, 3, '33333'] # 返回日期格式给前端 import datetime blog_date = datetime.date(2018,1,1) comment_date = datetime.date(2019,1,1) # 后端解析为HTML格式的数据传给前端 from django.utils.safestring import mark_safe xxx = mark_safe('&lt;h1&gt;我是h1标签&lt;/h1&gt;') return render(request, 'index.html', locals()) index.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;前端统计字符串的长度 &#123;&#123; s|length &#125;&#125;&lt;/p&gt;&lt;p&gt;前端获取数据，如果是空就返回default后面默认的参数值 &#123;&#123; flag|default:'none' &#125;&#125;&lt;/p&gt;&lt;p&gt;将数字格式化成表示文件大小的单位 &#123;&#123; file_size|filesizeformat &#125;&#125;&lt;/p&gt;&lt;p&gt;格式化事件（不要加%号）&#123;&#123; ctime|date:'Y-m-d' &#125;&#125;&lt;/p&gt;&lt;p&gt;字符串的切片操作 &#123;&#123; res|slice:'0:8' &#125;&#125;&lt;/p&gt;&lt;p&gt;带步长的字符串切片操作 &#123;&#123; res|slice:'0:8:2' &#125;&#125;&lt;/p&gt;&lt;p&gt;截取固定长度的字符串 加上三个点 &#123;&#123; s|truncatechars:5 &#125;&#125;&lt;/p&gt;&lt;p&gt;按照空格截取文本内容 &#123;&#123; res|truncatewords:'4' &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; n|add:1 &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; 'hahaha'|add:'hehehehehe' &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; cut|cut:' ' &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;join_list|join:join_str&#125;&#125;&lt;/p&gt;&lt;p&gt;blog_date和comment_date两个时间的间隔&#123;&#123; blog_date|timesince:comment_date &#125;&#125;&lt;/p&gt;&lt;p&gt;blog_date和现在的时间的间隔&#123;&#123; blog_date|timesince &#125;&#125;&lt;/p&gt;&lt;p&gt;comment_date和blog_date的时间间隔&#123;&#123; comment_date | timeuntil:blog_date &#125;&#125;&lt;/p&gt;&#123;# 重点 #&#125;&lt;p&gt;渲染成HTML标签格式的字符串&#123;&#123; ht &#125;&#125;&lt;/p&gt;&lt;p&gt;渲染成HTML格式&#123;&#123; ht|safe &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; xxx &#125;&#125;&lt;/p&gt; # xxx是后端处理为HTML格式的数据传给前端，前端拿到这个数据直接 &lt;/body&gt;&lt;/html&gt; 标签views.py from django.shortcuts import renderdef index(request): emp=[] s = [111, 222, 3333, 4444] flag = None d = &#123;'name': 'jason', 'password': '222', 'hobby': ['看书', '写字', '琴棋书画']&#125; return render(request, 'index.html', locals()) urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index',views.index)] FOR 语法： &gt; &lt;body&gt;&gt; &#123;% for 自定义变量名 in 后端可迭代对象 %&#125;&gt; &gt; &lt;p&gt;&#123;&#123; 自定义变量名 &#125;&#125;&lt;/p&gt;&gt; &gt; &#123;% endfor %&#125;&gt; &lt;/body&gt;&gt; 循环可迭代对象渲染到前端循环列表index.html &lt;body&gt;&#123;% for i in s %&#125; &lt;p&gt;&#123;&#123; i &#125;&#125;&lt;/p&gt;&#123;% endfor %&#125;&lt;/body&gt; 浏览器查看结果 循环字典index.html &lt;body&gt;&#123;% for i in d.keys %&#125; &lt;p&gt;&#123;&#123; i &#125;&#125;&lt;/p&gt;&#123;% endfor %&#125;&#123;% for i in d.values %&#125; &lt;p&gt;&#123;&#123; i &#125;&#125;&lt;/p&gt;&#123;% endfor %&#125;&#123;% for i in d.items %&#125; &lt;p&gt;&#123;&#123; i &#125;&#125;&lt;/p&gt;&#123;% endfor %&#125;&lt;/body&gt; Forloopindex.html &lt;body&gt;&#123;% for i in s %&#125; &lt;p&gt;&#123;&#123; forloop &#125;&#125;&lt;/p&gt;&#123;% endfor %&#125;&lt;/body&gt; for循环了多少次，页面上就会渲染多少个forloop对象 forloop字段 first: for循环第一次得到的fooloop对象中的first字段肯定是True,其他均为flase last: for循环最后一次得到的fooloop对象中的last字段肯定是True,其他均为flase empty for循环中如果数据是空的，则走empty下面的语句 &lt;body&gt;&#123;% for foo in emp %&#125; &#123;% if forloop.first %&#125; &lt;p&gt;第一次循环&lt;/p&gt; &#123;% elif forloop.last %&#125; &lt;p&gt;第二次循环&lt;/p&gt; &#123;% else %&#125; &lt;p&gt;&#123;&#123; foo &#125;&#125;&lt;/p&gt; &#123;% endif %&#125;&#123;% empty %&#125; &lt;p&gt;数据是空的&lt;/p&gt;&#123;% endfor %&#125;&lt;/body&gt; IFindex.html &lt;body&gt;&#123;% if flag %&#125; &lt;p&gt;flag不为空&lt;/p&gt; &#123;% else %&#125; &lt;p&gt;flag是空&lt;/p&gt;&#123;% endif %&#125;&lt;/body&gt; 关联使用index.html &lt;body&gt;&#123;% for i in s %&#125; &#123;% if forloop.first %&#125; &lt;p&gt;这是第一次for循环&lt;/p&gt; &#123;% elif forloop.last %&#125; &lt;p&gt;这是最后一次for循环&lt;/p&gt; &#123;% else %&#125; &lt;p&gt;&#123;&#123; i &#125;&#125;&lt;/p&gt; &#123;% endif %&#125;&#123;% endfor %&#125;&lt;/body&gt; withindex.html &lt;body&gt;&lt;p&gt;&#123;&#123; d.hobby &#125;&#125;&lt;/p&gt;&#123;% with d.hobby as v %&#125; &lt;p&gt;&#123;&#123; v.0 &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; v.1 &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; v.2 &#125;&#125;&lt;/p&gt;&#123;% endwith %&#125;&lt;/body&gt; 自定义过滤器,标签前提 必须在应用名下新建一个名为templatetags的package文件夹（必须叫这个名字） 在该新建的文件夹内新建一个任意名称的py文件 在该py文件中需要固定写两句代码： from django import template register=template.Library() 注意 自定义过滤器和自定义标签都是来解决复用性问题 自定义过滤器最多只能传2个参数，标签随意 自定义过滤器可以写进条件语句，自定义标签不可以写进条件语句 &gt;&#123;% if 10|multi_filter:20 &gt; 100 %&#125;&gt;&lt;p&gt;100&lt;/p&gt;&gt; &#123;% else %&#125;&gt; &lt;p&gt;200&lt;/p&gt;&gt;&#123;% endif %&#125;&gt; 案例app01/templatetags/my_tag_filter.py from django import templateregister = template.Library()# 自定义过滤器@register.filterdef multi_filter(x, y): return x * y# 自定义标签@register.simple_tagdef multi_tag(x, y): return x * y index.html &lt;body&gt;&lt;h4&gt;自定义过滤器,标签&lt;/h4&gt;&#123;% load my_tag_filter %&#125;&lt;p&gt;&#123;&#123; 10|multi_filter:20 &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;% multi_tag 7 9 %&#125;&lt;/p&gt;&lt;/body&gt; 模板的继承和导入 首先需要在被继承的模板中划分多个区域 &#123;% block 给区域起的名字 %&#125;&#123;% endblock %&#125; 通常情况下一个模板中应该至少有三块 &#123;% block css %&#125;页面css代码块&#123;% endblock %&#125;&#123;% block js %&#125;页面js代码块&#123;% endblock %&#125;&#123;% block content %&#125;页面主体内容&#123;% endblock %&#125; 子板继承模板 先继承模板所有的内容 &#123;% extends 'home.html' %&#125; 然后根据block块的名字修改指定区域的内容 &#123;% block content %&#125; &lt;h1&gt;登录页面&lt;/h1&gt; &lt;form action=\"\"&gt; &lt;p&gt;username:&lt;input type=\"text\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;password:&lt;input type=\"text\" class=\"form-control\"&gt;&lt;/p&gt; &lt;input type=\"submit\" class=\"btn btn-success\"&gt; &lt;/form&gt;&#123;% endblock %&#125; 模板的导入 模板的导入:将一段html当做模块的方式导入到另一个html展示 &#123;% include '想导入的html文件名' %&#125; 静态文件配置&#123;% load static %&#125; &lt;link rel='stylesheet' href=\"&#123;% static 'css/mycss.css'%&#125;\"&gt; # 第一种方式&lt;link rel='stylesheet' href=\"&#123;% get_static_prefix %&#125;css/mycss.css\"&gt; # 第二种方式 案例urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index/', views.index), url(r'^home/',views.home), url(r'^login/',views.login), url(r'^reg/',views.reg),] views.py from django.shortcuts import renderdef home(request): return render(request,'home.html')def login(request): return render(request,'login1.html')def reg(request): return render(request,'reg.html') home.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;link href=\"https://cdn.bootcss.com/twitter-bootstrap/3.4.0/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;script src=\"https://cdn.bootcss.com/twitter-bootstrap/3.4.0/js/bootstrap.min.js\"&gt;&lt;/script&gt; &#123;% block css %&#125; &#123;% endblock %&#125;&lt;/head&gt;&lt;body&gt;&lt;nav class=\"navbar navbar-default\"&gt; &lt;div class=\"container-fluid\"&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class=\"navbar-header\"&gt; &lt;button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#bs-example-navbar-collapse-1\" aria-expanded=\"false\"&gt; &lt;span class=\"sr-only\"&gt;Toggle navigation&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=\"navbar-brand\" href=\"#\"&gt;Brand&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class=\"collapse navbar-collapse\" id=\"bs-example-navbar-collapse-1\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"#\"&gt;Link &lt;span class=\"sr-only\"&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\" role=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\"&gt;Dropdown &lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=\"separator\" class=\"divider\"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;li role=\"separator\" class=\"divider\"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;One more separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class=\"navbar-form navbar-left\"&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"Search\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\" role=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\"&gt;Dropdown &lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=\"separator\" class=\"divider\"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt;&lt;/nav&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-3\"&gt; &lt;div class=\"list-group\"&gt; &lt;a href=\"/login\" class=\"list-group-item active\"&gt; login &lt;/a&gt; &lt;a href=\"/reg\" class=\"list-group-item\"&gt;reg&lt;/a&gt; &lt;a href=\"#\" class=\"list-group-item\"&gt;Morbi leo risus&lt;/a&gt; &lt;a href=\"#\" class=\"list-group-item\"&gt;Porta ac consectetur ac&lt;/a&gt; &lt;a href=\"#\" class=\"list-group-item\"&gt;Vestibulum at eros&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-md-9\"&gt; &#123;% block content %&#125; &lt;div class=\"jumbotron\"&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;p&gt;...&lt;/p&gt; &lt;p&gt;&lt;a class=\"btn btn-primary btn-lg\" href=\"#\" role=\"button\"&gt;Learn more&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &#123;% include 'hualihushao.html' %&#125; &#123;% endblock %&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&#123;% block js %&#125;&#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; login1.html &#123;% extends 'home.html' %&#125;&#123;% block content %&#125;&lt;h1&gt;登录页面&lt;/h1&gt; &lt;form action=\"\"&gt; &lt;p&gt;username:&lt;input type=\"text\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;password:&lt;input type=\"text\" class=\"form-control\"&gt;&lt;/p&gt; &lt;input type=\"submit\" class=\"btn btn-success\"&gt; &lt;/form&gt; &#123;% include 'hualihushao.html' %&#125;&#123;% endblock %&#125; reg.html &#123;% extends 'home.html' %&#125;&#123;% block content %&#125;&lt;h1&gt;注册页面&lt;/h1&gt; &lt;form action=\"\"&gt; &lt;p&gt;username:&lt;input type=\"text\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;password:&lt;input type=\"text\" class=\"form-control\"&gt;&lt;/p&gt; &lt;input type=\"submit\" class=\"btn btn-danger pull-right\"&gt; &lt;/form&gt;&#123;% endblock %&#125; hualihushao.html &lt;h1&gt;我是这条gai最靓的仔&lt;/h1&gt;&lt;form action=\"\"&gt; &lt;p&gt;&lt;input type=\"text\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"text\"&gt;&lt;/p&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"模板层","slug":"模板层","permalink":"http://cjwnb.top/tags/模板层/"}]},{"title":"视图层","slug":"视图层","date":"2019-07-17T08:26:12.757Z","updated":"2019-07-20T09:04:28.966Z","comments":true,"path":"2019/07/17/视图层/","link":"","permalink":"http://cjwnb.top/2019/07/17/视图层/","excerpt":"","text":"FBV与CBV FBV 基于函数的视图 CBV 基于类的视图 FBVurlpatterns = [ path('admin/', admin.site.urls), path('index/&lt;yyyy:id&gt;', views.index),]def index(request, id): print(id, type(id)) # 222 &lt;class 'str'&gt; return HttpResponse('index') CBV​ 无论是FBV还是CBV路由层都是路由对应视图函数内存地址 urlpatterns = [ # url(r'^mycls/',views.view) url(r'^mycls/',views.MyCls.as_view())]class MyCls(View): def get(self,request): return render(request,'index.html') def post(self,request): return HttpResponse('post') urls.py from django.contrib import adminfrom django.urls import path, re_pathfrom app01 import viewsurlpatterns = [ url('^admin/', admin.site.urls), url('^test', views.MyCls.as_view())] views.py from django.shortcuts import render, HttpResponse# Create your views here.class MyCls(View): def get(self, request): return render(request, 'test.html') def post(self, request): return HttpResponse('post') test.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;欢迎访问&lt;/h1&gt;&lt;form action=\"/test/\" method=\"post\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 请求对象request 当一个页面被请求时，Django就会创建一个包含本次请求原信息的HttpRequest对象。Django会将这个对象自动传递给响应的视图函数，一般视图函数约定俗成地使用 request 参数承接这个对象。 请求地址格式http://127.0.0.1/index url:协议://IP:port/路径？get请求数据 request方法 常用方法request.get_full_path() 路径加参数，如果输入URL请求是http://127.0.0.1:8000/index/?a=1， 则输出为index/?a=1 request.path() 只输出路径，如果输入URL请求是http://127.0.0.1:8000/index/?a=1， 则输出为index/ urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index',views.index)] views.py from django.shortcuts import render,HttpResponse# Create your views here.def index(request): print(request) print(request.get_full_path()) # /index/?a=1 print(request.path) # /index/ return HttpResponse('ok') 响应对象response 与由Django自动创建的HttpRequest对象相比，HttpResponse对象是我们的职责范围了。我们写的每个视图都需要实例化，填充和返回一个HttpResponse。 HttpResponse类位于django.http模块中。 urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index',views.index)] views.py from django.shortcuts import render,HttpResponse# Create your views here.def index(request): print(request) print(request.get_full_path()) # /index/?a=1 print(request.path) # /index/ return HttpResponse('ok') 浏览器返回Json格式 希望在浏览器返回一个大字典，我们想到了Httpresponse({‘name’:’lyysb’,’password’:123344}) 在django中，通过JsonResponse这个类来完成 测试1urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'test',views.Test.as_view()),] views.py from django.views import Viewfrom django.shortcuts import HttpResponse, render, redirectclass Test(View): def get(self, request): data=&#123;'name': 'lyysb', 'password': 123332&#125; return HttpResponse(data) def post(self, request): pass 浏览器输入http://127.0.0.1:8000/test/ 只是返回来字典的键值 所以如果要这个字典完整在浏览器上渲染，尝试使用json格式字符串 测试2修改views.py里的代码 views.py from django.views import Viewfrom django.shortcuts import HttpResponseimport jsonclass Test(View): def get(self, request): data = &#123;'name': 'lyy傻缺', 'password': 123332&#125; return HttpResponse(json.dumps(data, ensure_ascii=False)) # ensure_ascii=False参数的作用是使得中文能够在浏览器上渲染 def post(self, request): pass 浏览器输入http://127.0.0.1:8000/test/ 测试3 使用 JsonResponse 返回json字符串 JsonResponse 源码 内部调用的也是Json模块，封装了json.dumps() 如果需要传递参数，通过 json_dumps_params 关键字传参，传参的值以字典的形式传值,因为这样 json_dumps_params的值就打散成key=value的形式为json.dumps()传递 比如说 json.dumps(data, ensure_ascii=False)，要使用JsonResponse得到同样的效果 就这么用: JsonResponse(data,json_dumps_params={‘ensure_ascii’:False}) class JsonResponse(HttpResponse): def __init__(self, data, encoder=DjangoJSONEncoder, safe=True, json_dumps_params=None, **kwargs): if safe and not isinstance(data, dict): raise TypeError( 'In order to allow non-dict objects to be serialized set the ' 'safe parameter to False.' ) if json_dumps_params is None: json_dumps_params = &#123;&#125; kwargs.setdefault('content_type', 'application/json') data = json.dumps(data, cls=encoder, **json_dumps_params) super(JsonResponse, self).__init__(content=data, **kwargs) views.py from django.http import JsonResponsefrom django.views import Viewclass Test(View): def get(self, request): data = &#123;'name': 'lyy傻缺', 'password': 123332&#125; return JsonResponse(data,json_dumps_params=&#123;'ensure_ascii':False&#125;) def post(self, request): pass urls.py from django.contrib import adminfrom django.urls import path, re_pathfrom app01 import viewsurlpatterns = [ url('^admin/', admin.site.urls), url('^test', views.MyCls.as_view())] 文件上传实现简单的文件上传 urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'upload', views.Upload_file.as_view()),] views.py from django.views import Viewfrom django.shortcuts import HttpResponse, renderclass Upload_file(View): def get(self, request): return render(request, 'test.html') def post(self, request): file_obj = request.FILES.get('myfile') with open(file_obj.name, 'wb') as f: for line in file_obj.chunks(): f.write(line) return HttpResponse('ok') test.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;上传文件&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"myfile\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"视图层","slug":"视图层","permalink":"http://cjwnb.top/tags/视图层/"}]},{"title":"虚拟环境","slug":"虚拟环境","date":"2019-07-17T06:09:46.748Z","updated":"2019-07-20T11:03:11.056Z","comments":true,"path":"2019/07/17/虚拟环境/","link":"","permalink":"http://cjwnb.top/2019/07/17/虚拟环境/","excerpt":"","text":"虚拟环境不同的项目配置不同的python解释器 django1.0与django2.0之间的区别 django2.0里面的path第一个参数不支持正则，你写什么就匹配，100%精准匹配 django2.0里面的re_path对应着django1.0里面的url urls.py from django.contrib import adminfrom django.urls import path,re_pathfrom app01 import viewsurlpatterns = [ path('admin/', admin.site.urls), re_path('^index/',views.index)] views.py from django.shortcuts import render,HttpResponse# Create your views here.def index(request): return HttpResponse('index') 虽然django2.0里面的path不支持正则表达式，但是它提供五个默认的转换器 str,匹配除了路径分隔符（/）之外的非空字符串，这是默认的形式int,匹配正整数，包含0。slug,匹配字母、数字以及横杠、下划线组成的字符串。uuid,匹配格式化的uuid，如 075194d3-6885-417e-a8a8-6c931e272f00。path,匹配任何非空字符串，包含了路径分隔符（/）（不能用？） urls.py from django.contrib import adminfrom django.urls import path,re_pathfrom app01 import viewsurlpatterns = [ path('admin/', admin.site.urls), path('index/&lt;str:id&gt;', views.index),] views.py from django.shortcuts import HttpResponsedef index(request, id): print(id, type(id)) # 222 &lt;class 'str'&gt; return HttpResponse('index') 自定义转换器 正则表达式 类 注册 class FourDigitYearConverter: regex = '[0-9]&#123;4&#125;' def to_python(self, value): return int(value) def to_url(self, value): return '%04d' % value # 占四位，不够用0填满，超了则就按超了的位数来！ register_converter(FourDigitYearConverter, 'yyyy') PS:路由匹配到的数据默认都是字符串形式 urls.py from django.contrib import adminfrom django.urls import path,re_pathfrom app01 import viewsfrom django.urls import path,re_path,register_converter# 自定义转换器，将浏览器输入路径的最后一个名字转换为4位数字，如果不够用0填充class FourDigitYearConverter: regex = '[0-9]&#123;4&#125;' def to_python(self, value): return int(value) def to_url(self, value): return '%04d' % value # 占四位，不够用0填满，超了则就按超了的位数来！register_converter(FourDigitYearConverter, 'yyyy')urlpatterns = [ path('admin/', admin.site.urls), path('index/&lt;yyyy:id&gt;', views.index),] views.py from django.shortcuts import HttpResponsedef index(request, id): print(id, type(id)) # 2222 &lt;class 'int'&gt; return HttpResponse('index') 浏览器输入http://127.0.0.1:8000/index/2222 测试","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"路由层","slug":"路由层","permalink":"http://cjwnb.top/tags/路由层/"}]},{"title":"django 路由层之反向解析","slug":"Django路由层之反向解析","date":"2019-07-17T05:01:02.257Z","updated":"2019-07-20T09:11:03.345Z","comments":true,"path":"2019/07/17/Django路由层之反向解析/","link":"","permalink":"http://cjwnb.top/2019/07/17/Django路由层之反向解析/","excerpt":"","text":"反向解析根据名字动态获取到对应的路径 可以给每一个路由与视图函数对应关系起一个名字这个名字能够唯一标识出对应的路径注意这个名字不能重复是唯一的 from django.shortcuts import reverseurl(r'^index6668888/$',views.index,name='index') 前端使用 &#123;% url 'index' %&#125;&#123;% url '你给路由与视图函数对应关系起的别名' %&#125; 后端使用 reverse('index')reverse('你给路由与视图函数对应关系起的别名') 有名分组反向解析后端使用 # 后端有名分组和无名分组都可以用这种形式 print(reverse('list',args=(10,))) # 下面这个了解即可 print(reverse('list',kwargs=&#123;'year':10&#125;)) 前端使用 # 前端有名分组和无名分组都可以用这种形式 &#123;% url 'list' 10 %&#125; # 下面这个了解即可 &#123;% url 'list' year=10 %&#125; 无名分组反向解析后端使用 reverse('list',args=(10,)) # 这里的数字通常都是数据的主键值 前端使用 &#123;% url 'list' 10 %&#125; 总结 针对有名分组与无名分组的反向解析统一采用一种格式即可 反向解析的本质:就是获取到一个能够访问名字所对应的视图函数 应用场景 通过别名来传递路径给到前端或者后端，好处是更加灵活，因为是通过别名进行传递，所以只要修改源路径，其他的层都不需要更改，否则如果直接通过源路径传递，则耦合度较高，不够灵活，维护成本太高 案例1前端通过蒙版语法&#123;% url &apos;定义的别名&apos; %&#125;取值 login.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1&gt;登录界面&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\"&gt; &lt;form action=\"&#123;% url 'log' %&#125;/\" method=\"post\"&gt; &lt;p&gt;用户名 &lt;input type=\"text\" name=\"user\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;密码 &lt;input type=\"password\" name=\"pwd\" class=\"form-control\"&gt;&lt;/p&gt; &lt;input type=\"submit\" value=\"登录\" class=\"btn btn-primary\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; views.py from django.shortcuts import render, HttpResponse# Create your views here.# 只要是和请求相关的事情，都需要用到requestdef login(request): if request.method == 'GET': return render(request, 'login.html') else: user = request.POST.get('user') pwd = request.POST.get('pwd') if user == \"lxx\" and pwd == '123': return HttpResponse('登录成功') else: return HttpResponse('用户名或者密码错误') urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login.html/', views.login,name='log'), 案例2后端通过reverse函数取值 urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login.html/', views.login, name='log'), url(r'^test/', views.test, name='t1'),] views.py from django.shortcuts import render, HttpResponse,redirect,reverse# 只要是和请求相关的事情，都需要用到requestdef login(request): if request.method == 'GET': return render(request, 'login.html') else: user = request.POST.get('user') pwd = request.POST.get('pwd') if user == \"lxx\" and pwd == '123': return HttpResponse('登录成功') else: return redirect(reverse('t1')) # 跳转到别名为t1的路径/test/def test(request): return HttpResponse('用户名或者密码错误') 案例3有名分组反向解析 urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login.html/', views.login, name='log'), url(r'^test/([0-9]+)', views.test, name='t1'),] views.py from django.shortcuts import render, HttpResponse, redirect, reversedef test(request, group): # 当输入 http://127.0.0.1:8000/test/2018/， group接收的值就是2018 print(reverse('t1', args=(group,))) # /test/2018 if request.method == 'GET': return render(request, 'group.html', &#123;'group': group&#125;) else: return HttpResponse('test') group.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1&gt;有名分组反向解析测试&lt;/h1&gt; &lt;div class=\"col-md-2 col-md-offset-4\"&gt; &lt;form action=\"&#123;% url 't1' group %&#125;/\" method=\"post\"&gt; &lt;p&gt;用户名 &lt;input type=\"text\" name=\"user\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;密码 &lt;input type=\"password\" name=\"pwd\" class=\"form-control\"&gt;&lt;/p&gt; &lt;input type=\"submit\" class=\"btn btn-success\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; 案例4无名分组反向解析, 和有名分组一模一样 urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login.html/', views.login, name='log'), url(r'^test/(?P&lt;xxx&gt;\\d+)', views.test, name='t1'),] views.py def test(request, xxx): print(reverse('t1', args=(xxx,))) if request.method == 'GET': return render(request, 'group.html', &#123;'group': xxx&#125;) else: return HttpResponse('test') group.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1&gt;无名分组反向解析测试&lt;/h1&gt; &lt;div class=\"col-md-2 col-md-offset-4\"&gt; &lt;form action=\"&#123;% url 't1' group %&#125;/\" method=\"post\"&gt; # 从后端取得url的别名和路径最后的数字 &lt;p&gt;用户名 &lt;input type=\"text\" name=\"user\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;密码 &lt;input type=\"password\" name=\"pwd\" class=\"form-control\"&gt;&lt;/p&gt; &lt;input type=\"submit\" class=\"btn btn-success\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; 名称空间即使不同的APP使用相同的URL名称，URL的命名空间模式也可以让你唯一反转命名的URL。 不使用名称空间，两个app出现同名的路由名字，则匹配到就会匹配，这样的话两个app访问的是同一个网页，并不是不同的 先创建一个新的app manage.py@dj4 &gt; startapp app02 注册app settings.py INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'app01.apps.App01Config', 'app02.apps.App02Config',] 案例1urls.py from django.conf.urls import url, includeurlpatterns = [ url(r'app01/',include('app01.urls')), url(r'app02/',include('app02.urls')),] app01.urls from django.conf.urls import urlfrom app01 import viewsurlpatterns = [ url('^index/',views.index)] app01.views def index(request): return HttpResponse('index1') app02.urls` from django.conf.urls import urlfrom app01 import viewsurlpatterns = [ url('^index/',views.index)] app02.views def index(request): return HttpResponse('index2') 测试 输入 http://127.0.0.1:8000/app01/index/ 输入 http://127.0.0.1:8000/app02/index/ 两个url访问的都是app01下的index的内容，这种是有问题的，如果需要每个app访问的都是自己的网页内容，但是路由名字又和其他app里的是一样的，这种用名称空间解决 案例2给两个app的URL路由关系创建一个名称空间 urls.py from django.conf.urls import url, includeurlpatterns = [ # 第一种写法 # url(r'app01/', include(\"app01.urls\", namespace=\"app01\")), # url(r'app02/', include(\"app02.urls\", namespace=\"app02\")), # 第二种写法 url(r'app01/', include((\"app01.urls\", \"app01\"))), url(r'app02/', include((\"app02.urls\", \"app02\"))),] app01.urls.py from django.conf.urls import urlfrom app01 import viewsurlpatterns = [ url('^index/', views.index)] app02.urls.py from django.conf.urls import urlfrom app02 import viewsurlpatterns = [ url('^index/',views.index)] app01.views.py def index(request): return HttpResponse('index1') app02.views.py def index(request): return HttpResponse('index2')","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"路由层","slug":"路由层","permalink":"http://cjwnb.top/tags/路由层/"}]},{"title":"pycharm快捷键","slug":"pycharm快捷键","date":"2019-07-16T13:40:50.273Z","updated":"2019-07-20T09:20:41.736Z","comments":true,"path":"2019/07/16/pycharm快捷键/","link":"","permalink":"http://cjwnb.top/2019/07/16/pycharm快捷键/","excerpt":"","text":"自动导入模块 默认是ctrl+alt+enter, 但是有时候没用，需要去pycharm里的快捷键配置菜单查看 默认系统配置了2个快捷键，第一个是没用的 第二个设置的快捷键才有用","categories":[{"name":"工具","slug":"工具","permalink":"http://cjwnb.top/categories/工具/"}],"tags":[{"name":"pycharm","slug":"pycharm","permalink":"http://cjwnb.top/tags/pycharm/"}]},{"title":"图书管理系统","slug":"图书管理系统","date":"2019-07-16T05:46:49.629Z","updated":"2019-07-20T10:59:14.078Z","comments":true,"path":"2019/07/16/图书管理系统/","link":"","permalink":"http://cjwnb.top/2019/07/16/图书管理系统/","excerpt":"","text":"图书管理系统表设计书籍表id title price 作者表id name age 出版社id name email 一对多映射关系一本书只能由一个出版社出版，一个出版社可以出版多本书，出版社-书籍 为一对多的关系,所以对书籍表做一个外键 id title price publish_id 多对多映射关系表id book_id author_id 代码实现连接数据库并设置pymysql来连接settings.py 配置数据库并注释中间件’django.middleware.csrf.CsrfViewMiddleware’ MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',]DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'book', 'HOST': '127.0.0.1', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123' &#125;&#125; __init__.py 告诉django用pymysql替换它默认mysql_db模块来连接数据库 import pymysqlpymysql.install_as_MySQLdb() 定义表的字段from django.db import models# Create your models here.class Book(models.Model): # id字段可以不写，默认会帮你创建一个主键id字段 title = models.CharField(max_length=32) price = models.DecimalField(max_digits=8, decimal_places=2) # 一对多外键字段的建立 publish = models.ForeignKey(to='Publish') # 默认是与publish的id字段建立关联 # 多对多外键字段建在关联的两张表的任何一张都可以，建议建在查询评率比较高的那张表里 author = models.ManyToManyField(to='Author') # django orm会自动帮你创建book与author的第三张表 # 注意： 多对多字段不会显示到表的字段中class Publish(models.Model): name = models.CharField(max_length=32) email = models.CharField(max_length=32)class Author(models.Model): name = models.CharField(max_length=32) age = models.IntegerField() 创建表命令行工具执行命令 manage.py@book_mgmt &gt; makemigrationsmanage.py@book_mgmt &gt; migrate 注意外键字段名 orm会自动在字段名后面加_id, 无论你的字段名有没有_id","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"项目","slug":"项目","permalink":"http://cjwnb.top/tags/项目/"}]},{"title":"Django 请求生命周期","slug":"Django 请求生命周期","date":"2019-07-16T03:31:49.436Z","updated":"2019-07-22T01:25:36.181Z","comments":true,"path":"2019/07/16/Django 请求生命周期/","link":"","permalink":"http://cjwnb.top/2019/07/16/Django 请求生命周期/","excerpt":"","text":"简易版本 带中间件","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"}]},{"title":"django小项目","slug":"django小项目","date":"2019-07-15T14:25:52.854Z","updated":"2019-07-17T04:28:58.307Z","comments":true,"path":"2019/07/15/django小项目/","link":"","permalink":"http://cjwnb.top/2019/07/15/django小项目/","excerpt":"","text":"最后需要实现的效果登录，注册，简单的增删改查 后端数据库models.py from django.db import models# Create your models here.class User(models.Model): # User表的主键字段名就是id id = models.AutoField(primary_key=True) # varchar(32) name字段是varchar(32) CharField在定义的时候必须要加max_length参数，不加直接报错 name = models.CharField(max_length=32) # varchar(32) password字段是varchar(32) CharField在定义的时候必须要加max_length参数，不加直接报错 password = models.CharField(max_length=32) def __str__(self): return self.name 路由分发urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login/', views.login), url(r'^reg/', views.reg), url(r'^userlist/', views.userlist), url(r'^delete_user/', views.delete_user), url(r'^edit_user/', views.edit_user), 视图函数views.py from django.shortcuts import render, HttpResponse, redirect# Create your views here.from app01 import modelsdef login(request): if request.method == 'POST': import pymysql # 获取用户输入的用户名和密码 username = request.POST.get('username') password = request.POST.get('password') conn = pymysql.connect( host='127.0.0.1', user=\"root\", password=\"123\", database='django', port=3306, charset='utf8', autocommit=True ) cursors = conn.cursor(pymysql.cursors.DictCursor) cursors.execute('select * from userinfo where name=%s and password=%s', args=(username, password)) user_info = cursors.fetchone() # 如果只查询到一个结果，fetchone直接返回一个字典，而fetchall还是返回一个列表，里面套个字典 if user_info: return HttpResponse('登录成功') return HttpResponse('用户名或密码错误') return render(request, \"login.html\")def reg(request): # 必须要加if判断，如果加的话，永远访问不了网页 # IntegrityError at /reg/ (1048, \"Column 'name' cannot be null\") if request.method == 'POST': # 接收前台通过form表单发送的数据 username = request.POST.get('username') password = request.POST.get('password') print(username, password) # 操作数据库 # 方式1 user_obj = models.User.objects.create(name=username, password=password) # User_obj=User object print(user_obj.pk) # pk获取主键字段对应的值 无论的你主键叫上面名字 print(user_obj.id) # 获取用户数据的id值,可以看到和pk的属性是一样的 print(user_obj.name) # 获取用户数据的name值 print(user_obj.password) # 获取用户数据的password值 # 方式2 # user_obj = models.User(name=username, password=password) # User_obj=User object # models.User.save(user_obj) # 对象调用save方法保存到数据库 # print(user_obj.pk) # pk获取主键字段对应的值 无论的你主键叫上面名字 # print(user_obj.id) # 获取用户数据的id值,可以看到和pk的属性是一样的 # print(user_obj.name) # 获取用户数据的name值 # print(user_obj.password) # 获取用户数据的password值 return redirect('/userlist/') return render(request, 'reg.html')def userlist(request): # 操作数据库 user_obj = models.User.objects.all() # # 获取user表所有的数据 # print(user_obj) # &lt;QuerySet [&lt;User: lyysb&gt;, &lt;User: lyysb&gt;, 。。。&gt; # 只要是QuerySet就可以点query查看获取到当前QuerySet对象的内部sql语句 # print(user_obj.query) # SELECT `app01_user`.`id`, `app01_user`.`name`, `app01_user`.`password` FROM `app01_user` return render(request, 'userlist.html', locals())def delete_user(request): # 删除时候执行的是GET请求，所以在前端提交的时候携带参数传给后端（http://127.0.0.1:8000/delete_user/?id=4） # print(request.GET) id = request.GET.get('id') # 查询操作 最后查询到的是一个queryset对象，里面是一个列表，可以通过first()方法取列表中的第一个元素 # user_obj2 = models.User.objects.filter(id=id) # print(user_obj2) #&lt;QuerySet [&lt;User: luowensg&gt;]&gt; # print(user_obj2.first()) # luowensg models.User.objects.filter(id=id).delete() return redirect('/userlist/')def edit_user(request): ''' [15/Jul/2019 13:35:26] \"GET /userlist/ HTTP/1.1\" 200 3784 访问userlist [15/Jul/2019 13:35:28] \"GET /edit_user/?id=5 HTTP/1.1\" 200 753 通过userlist.html上的修改用户按钮进入edit.html [15/Jul/2019 13:35:33] \"POST /edit_user/?id=5 HTTP/1.1\" 302 0 执行edit.html上的按钮，如果提交的话，就会重定向，因为函数里定义的返回值 return redirect('/userlist/') [15/Jul/2019 13:35:33] \"GET /userlist/ HTTP/1.1\" 200 3780 最后重定向到userlist.html上查看结果，所以是GET请求 :param request: :return: ''' # 4. 我们要操作数据库，更改一条数据，需要拿到表中的id字段的值 # 当用户点击修改用户按钮，跳转到edit.html,这个行为是GET，然后修改完数据之后提交，这个动作是POST # 我们在前端在form表单里面配置form表单中的路径参数携带?id=xx，所以可以通过request.GET.get('id')拿到id的值 # 我们也可以新建一个input标签，type设置为hidden,然后配置value这个属性，value这个属性的值由后台的数据库对象user_obj.id获得 if request.method == 'POST': username = request.POST.get('username') password = request.POST.get('password') # 方式1 新建一个input标签，type设置为hidden,然后配置value这个属性，value这个属性的值由后台的数据库对象user_obj.id获得 id=request.POST.get('id') # 方式2 在前端在form表单里面配置form表单中的路径参数携带?id=xx，通过request.GET.get('id')拿到id的值 # id = request.GET.get('id') # 操作数据库修改数据 # 方式1 # models.User.objects.filter(id=id).update(name=username,password=password) # 方式2 user_obj=models.User.objects.filter(id=id) user=user_obj.first() # lyysb 输出lyysb而不是一个对象，因为在ORM中类定义的时候定义了__str__，限定输出对象的name字段 # lxxsb &lt;class 'app01.models.User'&gt; # user_obj就是一个通过数据库查询到的一个queryset对象，queryset这个对象是一个列表，first方法就是把列表中的第一个元素user取出来了 # 这里通过id进行匹配，id这个字段在数据库中是唯一的，所以最后匹配到的就是只有一行数据对应的一个对象user # 我们可以通过user的.语法对查询到的这一行的数据库的字段进行修改 user.name=username user.password=password user.save() # 操作完数据库重定向到userlist网页查看用户列表，查看是否操作成功 return redirect('/userlist/') # 1.获取用户想要修改的id id = request.GET.get('id') # 2. 将该数据查询出来渲染到一个编辑页面 # 查询数据方式1 # filter当条件不存在的情况下会返回None # 比如说 user_obj = models.User.objects.filter(id=8888).first()，返回None user_obj = models.User.objects.filter(id=id).first() # 查询数据方式2 # 弊端: 如果查询不到数据对象就会报错，所有已不推荐使用 # 比如说 user_obj = models.User.objects.get(id=2222) # 就会报 500的错误 # app01.models.DoesNotExist: User matching query does not exist. # [15/Jul/2019 12:31:27] \"GET /edit_user/?id=5 HTTP/1.1\" 500 69867 # user_obj = models.User.objects.get(id=id) # owensb,这里直接显示name， # 因为在models类里面定义了__str__定义输出为对象的name字段的值（User object.name)， # 如果不设置，输出为对象 User object # print(user_obj) # print(type(user_obj)) # &lt;class 'app01.models.User'&gt; # 3. 将当前数据渲染到一个编辑页面上，只要是渲染页面相关的操作，就应该想到用render return render(request, 'edit.html', &#123;'user_obj': user_obj&#125;) 设置settings.py # 注册app01INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'app01.apps.App01Config',]# 暂时取消'django.middleware.csrf.CsrfViewMiddleware',MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',]# 数据库配置DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'django2', 'HOST': '127.0.0.1', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123' &#125;&#125;# 静态文件配置 (static主要存放bootstrap,css,fonts,img,js等目录)STATIC_URL = '/static/'STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static') __init__.py应用和项目目录都有这个文件，建在任何一个文件里都可以 import pymysqlpymysql.install_as_MySQLdb() # 告诉django用pymysql代替mysqldb连接数据库 前端userlist.html &lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1&gt;用户列表&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\"&gt; &lt;a href=\"/reg/\" class=\"btn btn-success\"&gt;注册用户&lt;/a&gt; &lt;a href=\"/login/\" class=\"btn btn-warning\"&gt;用户登录&lt;/a&gt; &lt;table class=\"table table-hover table-bordered table-striped table-condensed\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;password&lt;/th&gt; &lt;th&gt;action&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for user in user_obj %&#125; &lt;tr&gt; &lt;td&gt; &#123;&#123; user.pk &#125;&#125;&lt;/td&gt; &lt;td&gt; &#123;&#123; user.name &#125;&#125;&lt;/td&gt; &lt;td&gt; &#123;&#123; user.password &#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=\"/delete_user/?id=&#123;&#123; user.pk &#125;&#125;\" class=\"btn btn-danger\"&gt;删除用户&lt;/a&gt; &lt;a href=\"/edit_user/?id=&#123;&#123; user.pk &#125;&#125;\" class=\"btn btn-primary\"&gt;修改用户&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; reg.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;注册&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1&gt;注册页面&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\"&gt; &lt;form action=\"\" method=\"post\"&gt; &lt;p&gt;用户名&lt;input type=\"text\" name=\"username\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;密码&lt;input type=\"password\" name=\"password\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" class=\"btn btn-primary\"&gt;&lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; login.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1 class=\"h2\"&gt;登录页面&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\" &gt; &lt;form action=\"/login/\" method=\"post\"&gt; &lt;p&gt;用户名: &lt;input type=\"text\" class=\"form-control\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;密码: &lt;input type=\"password\" class=\"form-control\" name=\"password\"&gt; &lt;/p&gt; &lt;input type=\"submit\" value=\"登录\" class=\"btn btn-primary\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; edit.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;编辑&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1&gt;修改数据&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\"&gt; &lt;form action=\"/edit_user/?id=&#123;&#123; user_obj.id &#125;&#125;\" method=\"post\"&gt; &lt;p&gt;&lt;input type=\"hidden\" value=\"&#123;&#123; user_obj.id &#125;&#125;\" name=\"id\"&gt;&lt;/p&gt; &lt;p&gt;username&lt;input type=\"text\" name=\"username\" value=\"&#123;&#123; user_obj.name &#125;&#125;\"&gt;&lt;/p&gt; &lt;p&gt;password&lt;input type=\"password\" name=\"password\" value=\"&#123;&#123; user_obj.password&#125;&#125;\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" value=\"修改\" class=\"btn btn-warning\"&gt;&lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"}]},{"title":"django 路由层之分组","slug":"Django路由层之分组","date":"2019-07-09T16:59:06.950Z","updated":"2019-07-20T09:29:02.917Z","comments":true,"path":"2019/07/10/Django路由层之分组/","link":"","permalink":"http://cjwnb.top/2019/07/10/Django路由层之分组/","excerpt":"","text":"正则匹配urls.py urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^test', views.test), url(r'^testadd',views.testadd)] django项目目录中, 路由层就是urls.py这个文件来进行控制 urlpatterns这个变量定义的一个列表，列表中通过url这个函数进行路由分发到视图层 url函数中是通过正则匹配浏览器中输入的网址中的路径中的最后一位,最后一位的字符串就是admin,test,testadd. 证明urls.pyfrom django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url('test', views.test), url('testadd',views.testadd)] views.pydef test(request): return HttpResponse('test')def testadd(request): return HttpResponse('testadd') 浏览器测试 输入 http://127.0.0.1:8000/test/， 返回test 输入 http://127.0.0.1:8000/testadd/， 也是返回test 总结上面的结果并不是我们想要的，我们希望的结果是: 输入 http://127.0.0.1:8000/testadd/，页面返回testadd 输入 http://127.0.0.1:8000/test/，页面返回test 而从上面的结果验证可知道： 路由文件中url函数后面跟着的第一个参数是正则表达式,匹配规则按照从上往下一次匹配,匹配到一个之后立即匹配。 当我们输入 http://127.0.0.1:8000/testadd/, url(‘test’, views.test),这一个元素先匹配到了testadd,就相当于re.findall(‘test’,’testall’),这样就匹配到了test这个字符串，对应的会执行视图层中的test函数，所以最后返回来test &gt;&gt;&gt; import re&gt;&gt;&gt; re.findall('test','testall')['test'] 解决方案1:urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url('test/', views.test), url('testadd/',views.testadd)] 浏览器测试 输入 http://127.0.0.1:8000/test/， 返回test 输入 http://127.0.0.1:8000/testadd/，页面返回testadd 但是这里有个问题： 当我们输入 http://127.0.0.1:8000/test/sdsddsdsfsdf， 正常返回test 当我们输入 http://127.0.0.1:8000/dsdsdsdssdtest/sdsddsdsfsdf, 正常返回test 当我们输入 http://127.0.0.1:8000/testadd/sdsddsdsfsdf， 正常返回testadd 当我们输入 http://127.0.0.1:8000/dsdsdsdssdtestadd/sdsddsdsfsdf， 正常返回testadd 解决方案2因为路由匹配是正则匹配的规律，所以使用正则表达式进行精准匹配 urls.py urlpatterns = [ url(r'^admin/', admin.site.urls), url('^test/$', views.test), url('^testadd/$',views.testadd)] 新需求希望主页也有内容, 用户输错网址给个提示信息 urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^$',views.home), url('^test/$', views.test), url('^testadd/$',views.testadd), url(r'', views.error),] views.py from django.shortcuts import render,redirect,HttpResponse# Create your views here.def home(request): return HttpResponse('这是首页')def error(request): return HttpResponse('你输了什么鬼')def test(request): return HttpResponse('test')def testadd(request): return HttpResponse('testadd') 浏览器测试 路由分发url(&#39;正则表达式&#39;,&#39;视图函数内存地址&#39;) django每一个app下面都可以有自己的url.py 路由层，templates文件夹，static文件夹 项目名下urls.py(总路由)不再做路由与视图函数的匹配关系而是做路由的分发 from django.conf.urls import include# 路由分发 注意路由分发总路由千万不要$结尾url(r'^app01/',include(app01_urls)),url(r'^app02/',include(app02_urls))# 在应用下新建urls.py文件，在该文件内写路由与视图函数的对应关系即可from django.conf.urls import urlfrom app01 import viewsurlpatterns = [ url(r'^index/',views.index)] 案例urls.py from django.conf.urls import url, includeurlpatterns = [ url(r'app01/',include('app01.urls')), url(r'app02/',include('app02.urls')),] app01.urls from django.conf.urls import urlfrom app01 import viewsurlpatterns = [ url('^index/',views.index)] app01.views def index1(request): return HttpResponse('index1') app02.urls` from django.shortcuts import render,HttpResponse# Create your views here.def index(request): return HttpResponse('index2') app02.views def index2(request): return HttpResponse('index2') 分组无名分组将加括号的正则表达式匹配到的内容当做位置参数自动传递给对应的视图函数 默认匹配到后，默认把request一定会传给视图函数，因为url函数是采取正则匹配，正则匹配中如果匹配到分组的内容，则输出分组，所以我们可以通过正则表达式分组的特点将匹配到的分组的内容传递给视图函数，但是视图函数需要增加一个形参来接收正则匹配匹配到的分组的内容 &gt;&gt;&gt; re.findall('test/([0-9]+)','test/2018')['2018']&gt;&gt;&gt; re.findall('test/([0-9]+)','test/20183333333')['20183333333'] url(r'^test/(\\d+)/', views.test), # 匹配一个或多个数字def test(request,xxx): print(xxx) return HttpResponse('test') url.py urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^$', views.home), # url(r'^test/[0-9]&#123;4&#125;/', views.test), url(r'^test/(\\d+)/', views.test), # 匹配一个或多个数字 url(r'^testadd/', views.testadd), # url(r'',views.error)] views.py from django.shortcuts import render,HttpResponse,redirectdef test(request): return HttpResponse('test')def testadd(request): return HttpResponse('testadd')def home(request): return HttpResponse('首页')def error(request): return HttpResponse('广告位招租') 显示的页面 修改代码views.py from django.shortcuts import render,HttpResponse,redirectdef test(request,xxx): print(xxx) return HttpResponse('test') 有名分组将加括号的正则表达式的内容当做关键字参数自动传递给响应的视图函数 正则表达式复习&gt;&gt;&gt; a=re.match('test/(?P&lt;name&gt;[0-9]+)','test/123')&gt;&gt;&gt; a.group('name')'123'&gt;&gt;&gt; a=re.match('test/(?P&lt;name&gt;\\d+)','test/123')&gt;&gt;&gt; a.group('name')'123' 使用 url(r’^test/(?P\\d+)/‘, views.test) urls.py urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^$', views.home), # url(r'^test/[0-9]&#123;4&#125;/', views.test), # 无名分组 # url(r'^test/(\\d+)/', views.test), # 匹配一个或多个数字 # 有名分组 url(r'^test/(?P&lt;year&gt;\\d+)/', views.test), # 匹配一个或多个数字，并可以通过year取值 url(r'^testadd/', views.testadd), # url(r'',views.error) views.py def test(request,year): # 这里的形参year必须和路由层中正则匹配的名字是一样的 print(year) return HttpResponse('test') 注意 有名分组和无名分组不能混着用,但是多个有名分组和多个无名分组可以连用 测试 同时使用无名分组和有名分组, 报错 urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ # 测试 同时使用无名分组和有名分组 url(r'test/(?P&lt;year&gt;\\d+)/[0-9](\\d+)',views.test),] views.py def test(request,xxx,year): print(year) return HttpResponse('test') 使用多个有名分组 urls.py urlpatterns = [ # 测试 使用多个无名分组 url(r'test/(?P&lt;year&gt;\\d+)/(?P&lt;month&gt;\\d+)/(?P&lt;day&gt;\\d+)',views.test),] views.py from django.shortcuts import render,HttpResponse,redirectdef test(request,month,day,year): print(year) return HttpResponse('test')","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"路由层","slug":"路由层","permalink":"http://cjwnb.top/tags/路由层/"}]},{"title":"django基础","slug":"Django基础","date":"2019-07-09T06:13:20.537Z","updated":"2019-07-22T02:02:10.391Z","comments":true,"path":"2019/07/09/Django基础/","link":"","permalink":"http://cjwnb.top/2019/07/09/Django基础/","excerpt":"","text":"MVC M: 模型层（models.py） V: 视图层 (views.py) C:控制器（Controller） urls.py MTVDjango是一种MTV的设计模式，各组件之间保持松耦合关系 本质：Django的MTV也是MVC M 代表模型 (Model): 负责业务对象和数据库的关系映射(ORM)T 代表模板(Template): 负责如何把页面展示给用户(html)V 代表视图(View): 负责业务逻辑，并在适当时候调用Model和Template除了以上三层外，还需要一个URL分发器，它的作用是将一个个URL的页面分发给不同的view处理，View再调用响应的Model和Template 设置浏览器刷新后不读取缓存 下载Django# pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple django==1.11.10 查看Django$ python&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path['', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/lib-dynload', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages']&gt;&gt;&gt; exit()$ cd /Library/Frameworks/Python.framework/Versions$ open 3.6/ 更快速的方法django-admin $ django-adminType 'django-admin help &lt;subcommand&gt;' for help on a specific subcommand.Available subcommands:[django] check compilemessages createcachetable dbshell diffsettings dumpdata flush inspectdb loaddata makemessages makemigrations migrate runserver sendtestemail shell showmigrations sqlflush sqlmigrate sqlsequencereset squashmigrations startapp startproject test testserverNote that only Django core commands are listed as settings are not properly configured (error: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.). Django的创建和启动命令行方式# 创建项目$ cd My_pro/$ django-admin.py startproject mysites# 创建应用$ cd mysites/$ python3 manage.py startapp blog# 启动项目$ python3 manage.py runserver 访问 http://127.0.0.1:8000 pycharm Django目录介绍first_pro:&gt;&gt;&gt; app01: 应用相关的目录 migrations: 数据库迁移相关数据 admin.py: Django后台管理相关 models.py: 模型表相关（数据库） views.py: 视图函数相关&gt;&gt;&gt; first_pro: 项目相关的目录 settings.py: 包含了项目的默认配置，包括数据库信息，调试标志以及其他一些工作的变量 urls.py: 路由文件（控制器）负责把URL模式映射到应用程序 wsgi.py: 启动socket 服务端的文件&gt;&gt;&gt; templates: 项目用到的所有html文件&gt;&gt;&gt;manage.py: Django项目里面的工具，通过它可以调用Django shell和数据库等 案例通过Django查看时间的一个简单页面 后端 url.py 当执行timer函数时候，会把request都传给函数views.timer(request),所以views的函数必须加形参request urlpatterns = [ url('^admin/', admin.site.urls), url('^timer/', views.timer), ] views.py def timer(request): import time ctime = time.time() return render(request, \"timer.html\", &#123;'ctime': ctime&#125;) 前端 timer.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;当前时间:&#123;&#123; ctime &#125;&#125;&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt; Django 静态文件配置通过路径访问 http://127.0.0.1:8000/static/bootstrap.js 无法访问 配置settings.py STATIC_URL = '/static/'STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static'),] time.html &lt;script src=\"/static/bootstrap.js\"&gt;&lt;/script&gt; 地址栏 http://127.0.0.1:8000/static/bootstrap.js， 可以直接访问js文件 注意 在settings.py 中的STATIC_URL定义了什么别名，script标签中导入的路径的根就从哪里开始 # settings.py 配置STATIC_URL = '/xxx/'STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static'),]# time.html&lt;script src=\"/static/bootstrap.js\"&gt;&lt;/script&gt; 以上的情况，地址栏输入什么都会有异常信息。 输入 http://127.0.0.1:8000/static/bootstrap.js映射关系是xxx,访问static当然会报404错误，路径根本就是不存在的 输入 http://127.0.0.1:8000/xxx/bootstrap.js可以正常访问bootstrap.js，但是还是有问题的 当输入 http://127.0.0.1:8000/timer/在network中看到bootstrap.js是飘红的,因为在前端的script标签引入bootstrap的路径写错了 &lt;script src=\"/static/bootstrap.js\"&gt;&lt;/script&gt;# 这个时候映射 /static/bootstrap.js的别名是xxx,所以路径写成 &lt;script src=\"/xxx/bootstrap.js\"&gt;&lt;/script&gt; 就没问题 Django三剑客from django.shortcuts import render,HttpResponse,redirectHttpResponse 返回字符串render 返回一个HTML页面redirect 重定向到一个HTML页面 登录功能form表单触发提交数据的动作的两种方式&gt;&lt;input type=\"submit\"&gt;&gt; &lt;button type=\"submit\"&gt;&lt;/button&gt; form表单提交数据的地址如何指定及方式 action属性控制提交的地址，比如说http://127.0.0.1:8080/login 1. 全路径 &lt;form action=\"http://127.0.0.1:8000/login/\"&gt;2. 只写路径后缀 &lt;form action=\"/login\"&gt;3. 不写 &lt;form action=\"\"&gt; 默认往当前路径提交,当前路径指的是打开页面所在的路径，也就是http://127.0.0.1:8080/login） 获取用户端提交的请求方式request.method 根据客户端请求方式的不同执行不同的逻辑代码views.py def login(request): # 获取用户端提交的请求方式 print(request.method) # 拿到的请求方式是全大写的字符串 if request.method=='GET': return render(request,'login.html') return HttpResponse('接收成功') urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login/', views.login),] login.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1 class=\"h2\"&gt;登录页面&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\" &gt; &lt;form action=\"/login/\" method=\"post\"&gt; &lt;p&gt;用户名: &lt;input type=\"text\" class=\"form-control\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;密码: &lt;input type=\"password\" class=\"form-control\" name=\"password\"&gt; &lt;/p&gt; &lt;input type=\"submit\" value=\"登录\" class=\"btn btn-primary\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; 获取提交的表单的value列表里面所有的元素request.POST.getlist(key) 我们通过input标签提交的表单返回给后台的是一个字典类似于 &lt;QueryDict: &#123;'username': ['lxxsb','lyysb'], 'password': ['123']&#125;&gt;字典中的key就是input标签中name属性定义的名字而value则是用户输入的内容，value是通过一个列表的方式展现给后台默认后台通过request.POST.get 只会取到value列表的最后一个元素如果想要取到所有元素，要使用getlist views.py def login(request): # 获取用户端提交的请求方式 print(request.method) # 拿到的请求方式是全大写的字符串 if request.method == 'POST': print(request.POST) # 把它当成一个大字典，里面存放了客户端post提交的所有数据 # &lt;QueryDict: &#123;'username': ['lxxsb', 'lyysb'], 'password': ['123']&#125;&gt; print(request.POST.get('username')) # value虽然是个列表，但是获取value时候拿到的却是单个元素 # 默认只会取value里面的最后一个元素 print(request.POST.getlist('username')) #要想一次性获取value列表里面所有的数据需要用getlist() # ['lxxsb', 'lyysb'] print(request.POST['password']) # 不推荐使用该方法取数据，如果不存在就直接报错了 return HttpResponse('ok') return render(request, \"login.html\") urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login/', views.login),] login.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1 class=\"h2\"&gt;登录页面&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\" &gt; &lt;form action=\"/login/\" method=\"post\"&gt; &lt;p&gt;用户名: &lt;input type=\"text\" class=\"form-control\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;用户名: &lt;input type=\"text\" class=\"form-control\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;密码: &lt;input type=\"password\" class=\"form-control\" name=\"password\"&gt; &lt;/p&gt; &lt;input type=\"submit\" value=\"登录\" class=\"btn btn-primary\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; 获取get 请求的数据规则和POST请求一模一样 浏览器输入 http://127.0.0.1:8000/login/?username=lyysb&amp;password=123&amp;password=456 views.py (其他文件如上) def login(request): # 获取用户端提交的请求方式 print(request.method) # 拿到的请求方式是全大写的字符串 print(request.GET) # &lt;QueryDict: &#123;'username': ['lyysb'], 'password': ['123', '456']&#125;&gt; print(request.GET.get('password')) # 456 print(request.GET.getlist('password')) # ['123', '456'] return render(request, \"login.html\") pymysql 完成登录功能urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login/', views.login),] views.py from django.shortcuts import render, HttpResponse, redirect# Create your views here.def login(request): if request.method == 'POST': import pymysql # 获取用户输入的用户名和密码 username = request.POST.get('username') password = request.POST.get('password') conn = pymysql.connect( host='127.0.0.1', user=\"root\", password=\"123\", database='django', port=3306, charset='utf8', autocommit=True ) cursors = conn.cursor(pymysql.cursors.DictCursor) cursors.execute('select * from userinfo where name=%s and password=%s', args=(username, password)) user_info = cursors.fetchone() # 如果只查询到一个结果，fetchone直接返回一个字典，而fetchall还是返回一个列表，里面套个字典 if user_info: return HttpResponse('登录成功') return HttpResponse('用户名或密码错误') return render(request, \"login.html\") login.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1 class=\"h2\"&gt;登录页面&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\" &gt; &lt;form action=\"/login/\" method=\"post\"&gt; &lt;p&gt;用户名: &lt;input type=\"text\" class=\"form-control\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;密码: &lt;input type=\"password\" class=\"form-control\" name=\"password\"&gt; &lt;/p&gt; &lt;input type=\"submit\" value=\"登录\" class=\"btn btn-primary\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; pycharm 连接数据库 查看pycharm支持的数据库 下载驱动 测试用户名是否正确 勾选需要显示的库 查看到MYSQL数据库已经在pycharm的数据库列表中 添加数据后同步到数据库 Django 连接数据库 需要修改配置文件settings.py DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': os.path.join(BASE_DIR, 'app01'), 'HOST': '127.0.0.1', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123' &#125;&#125; 告诉django用pymysql替换它默认mysql_db模块来连接数据库 方式1: 在项目文件夹下面的init.py方式2: 在应用文件夹下面的init.py __init__.py import pymysqlpymysql.install_as_MySQLdb() # 告诉django用pymysql代替mysqldb连接数据库","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"}]},{"title":"模拟一个简单的web请求","slug":"模拟一个简单的web请求","date":"2019-07-08T14:42:06.275Z","updated":"2019-07-16T05:03:37.373Z","comments":true,"path":"2019/07/08/模拟一个简单的web请求/","link":"","permalink":"http://cjwnb.top/2019/07/08/模拟一个简单的web请求/","excerpt":"","text":"引子描述下当我们在浏览器输入一个url网址，比如说www,jd.com, 然后显示整个页面的过程1. 当输入http://www.jd.com的时候，先把请求发送到本地DNS服务器里找www.jd.com对应的Ip地址和端口，如果有，返回ip地址和端口，2. 如果本地DNS服务器里面没有字符串 www.jd.com对应的ip地址和端口，则会去DNS根域服务器去找（root-server.net）,根域会把字符串交给顶级域服务器.com DNS服务器，然后会 将字符串交个权威DNS服务器找到jd.com,然后再去二级域名服务器找到www.jd.com3. 当客户端(浏览器)获得了ip地址和端口，客户端发送请求到响应的服务器，服务器响应需求，客户端拿到响应结果，渲染页面。 字符串和字节的转换\\&gt;&gt;&gt; s=\"hello\"\\&gt;&gt;&gt; s'hello'\\&gt;&gt;&gt; bytes(s,encoding=\"utf-8\")b'hello'\\&gt;&gt;&gt; b=bytes(s,encoding=\"utf-8\")\\&gt;&gt;&gt; bb'hello'\\&gt;&gt;&gt; str(b,encoding='utf-8')'hello' 模拟一个简单的web请求from socket import *sock = socket(AF_INET, SOCK_STREAM)sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)sock.bind(('127.0.0.1', 8800))sock.listen(5)while True: # 不断地等待接收客户端的链接,保证服务器不中断 print('\\033[32mserver waiting...\\033[0m') client, addr = sock.accept() # 客户端套接字对象，客户端地址端口 data = client.recv(1024) print('data', data) # client.send(b'hello world') # 浏览器端会显示 127.0.0.1 发送的响应无效 # 浏览器要访问数据必须加上HTTP/1.1 状态码 # HTTP/1.1 200 OK 响应首行 hello world 响应体 响应首行和响应体之前用\\r\\n\\r\\n，否则响应体无法渲染显示 with open('index.html','rb') as f: data=f.read() client.send(b'HTTP/1.1 200 OK\\r\\n\\r\\n%s'%data) client.close() # index.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 style=\"color: red;\"&gt;宝贝 我来了&lt;/h1&gt;&lt;img src=\"http://s14.sinaimg.cn/middle/4b955cd7xcb1739815c4d&amp;690\" alt=\"\"&gt;&lt;a href=\"http://www.w3school.com.cn/\"&gt;click&lt;/a&gt;&lt;div style=\"height: 200px\"&gt;&lt;/div&gt;&lt;div&gt; &lt;h1 style=\"color: yellow; background-color: gray\"&gt;张帆喜欢的类型&lt;/h1&gt; &lt;img src=\"http://s8.sinaimg.cn/bmiddle/005DIuBKgy6KewCX5iv97&amp;690\" alt=\"\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; /usr/local/bin/python3.6 /Users/cjw/Desktop/pycharm_project/Django/Weby应用程序/JDserver.pyserver waiting...data b'GET / HTTP/1.1\\r\\nHost: 127.0.0.1:8800\\r\\nConnection: keep-alive\\r\\nCache-Control: max-age=0\\r\\nUpgrade-Insecure-Requests: 1\\r\\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36\\r\\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\\r\\nAccept-Encoding: gzip, deflate, br\\r\\nAccept-Language: zh-CN,zh;q=0.9\\r\\n\\r\\n'server waiting...data b'GET /favicon.ico HTTP/1.1\\r\\nHost: 127.0.0.1:8800\\r\\nConnection: keep-alive\\r\\nPragma: no-cache\\r\\nCache-Control: no-cache\\r\\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36\\r\\nAccept: image/webp,image/apng,image/*,*/*;q=0.8\\r\\nReferer: http://127.0.0.1:8800/\\r\\nAccept-Encoding: gzip, deflate, br\\r\\nAccept-Language: zh-CN,zh;q=0.9\\r\\n\\r\\n'server waiting... 浏览器会解释url请求发生了什么response: 从客户端接收过来的一堆HTML字符串(要放到页面的一堆字符串)Preview: 浏览器解析服务端发送的的HTML字符串，将这些字符串解析成用户能看到的格式，preview能够看到一个这样的结果所以浏览器也可以看成一个解释期，解释HTML标记语言 HTTP协议主要由请求协议和响应协议构成 请求协议：浏览器给服务器发的格式的限定 响应协议：服务器给浏览器发的格式的限定 HTTP请求协议结构：请求首行+请求头+\\r\\n\\r\\n+请求体服务器通过\\r\\n来识别请求首行，请求头以及请求体请求首行和请求头之间，多个请求体之间用一个\\r\\n分割，最后一个请求头和请求体之间用两个\\r\\n分割请求方法主要分get和postget 没有请求体 post 有请求体 get 和 post请求1. GET请求提交的数据会放在url之后，以？分割URL和传输的数据，参数之间用&amp;相连，比如http://127.0.0.1:8800/?name=changwei&amp;pwd=GET2. GET 提交的数据大小有限制(因为浏览器对URL长度有限制)，而POST方法提交的数据没有限制3. GET与POST都是提交数据的方式，当需要对服务器所在的数据库的数据进行查询的时候提交GET请求，添加或删除提交POST请求 案例1 （get请求）'GET / HTTP/1.1\\r\\nHost: 127.0.0.1:8800\\r\\nConnection: keep-alive\\r\\nCache-Control: max-age=0\\r\\nUpgrade-Insecure-Requests: 1\\r\\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36\\r\\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\\r\\nAccept-Encoding: gzip, deflate, br\\r\\nAccept-Language: zh-CN,zh;q=0.9\\r\\n\\r\\n' 请求首行GET / HTTP/1.1\\r\\nHost: 127.0.0.1:8800格式： 方法(get/post)+发送请求的服务器的路径（URI /form/entry)+协议版本(HTTP/1.1) 请求头请求头 Connection: keep-alive请求头 Pragma: no-cache请求头 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36请求头 Accept: image/webp,image/apng,image/*,*/*;q=0.8请求头 Referer: http://127.0.0.1:8800请求头 Accept-Encoding: gzip, deflate, br请求头 Accept-Language: zh-CN,zh;q=0.9 请求体1. get请求没有请求体 所以最后的请求体部分是空的2. get请求提交的数据会放在url之后，以？分割URL和传输的数据，参数之间用&amp;相连，比如http://127.0.0.1:8800/?name=changwei&amp;pwd=123'GET /?name=changwei&amp;pwd=123 HTTP/1.1\\r\\nHost: 127.0.0.1:8800\\r\\nConnection: keep-alive\\r\\nUpgrade-Insecure-Requests: 1\\r\\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36\\r\\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\\r\\nAccept-Encoding: gzip, deflate, br\\r\\nAccept-Language: zh-CN,zh;q=0.9\\r\\n\\r\\n' 案例2 （post请求）# 服务端from socket import *sock = socket(AF_INET, SOCK_STREAM)sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)sock.bind(('127.0.0.1', 8800))sock.listen(5)while True: # 不断地等待接收客户端的链接,保证服务器不中断 print('\\033[32mserver waiting...\\033[0m') client, addr = sock.accept() # 客户端套接字对象，客户端地址端口 data = client.recv(1024) print('data', data) # client.send(b'hello world') # 浏览器端会显示 127.0.0.1 发送的响应无效 # 浏览器要访问数据必须加上HTTP/1.1 状态码 # HTTP/1.1 200 OK 响应首行 hello world 响应体 响应首行和响应体之前用\\r\\n\\r\\n，否则响应体无法渲染显示 with open('login.html','rb') as f: data=f.read() client.send(b'HTTP/1.1 200 OK\\r\\n\\r\\n%s'%data) client.close()# index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"http://127.0.0.1:8800/\" method=\"post\"&gt; 用户名 &lt;input type=\"text\" name=\"user\"&gt; 密码 &lt;input type=\"password\" name=\"pwd\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 'POST / HTTP/1.1\\r\\nHost: 127.0.0.1:8800\\r\\nConnection: keep-alive\\r\\nContent-Length: 21\\r\\nCache-Control: max-age=0\\r\\nOrigin: http://127.0.0.1:8800\\r\\nUpgrade-Insecure-Requests: 1\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36\\r\\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\\r\\nReferer: http://127.0.0.1:8800/\\r\\nAccept-Encoding: gzip, deflate, br\\r\\nAccept-Language: zh-CN,zh;q=0.9\\r\\n\\r\\nuser=changwei&amp;pwd=123' 请求首行POST / HTTP/1.1\\r\\nHost: 127.0.0.1:8800Cache-Control: max-age=0\\r\\nOrigin: http://127.0.0.1:8800Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Referer: http://127.0.0.1:8800/\\r\\nAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9 请求头Connection: keep-alive\\r\\nContent-Length: 21 请求体user=changwei&amp;pwd=123 HTTP响应协议和请求协议一样，主要由响应首行，响应头，响应体组成 常见的响应状态码1xx Informational(信息性状态码) 接受的请求正在处理2xx Success(成功状态码) 请求正常处理完毕3xx Redirection(重定向状态码) 需要进行附加操作以完成请求 (域名地址变了了,跳转到新的域名地址，这种情况浏览器发2次请求)4xx Client Error (客户端错误状态码) 服务器无法处理请求 404 (not found) 403(forbidden 禁止访问) 5xx Server Error(服务器错误状态码) 服务器处理请求出错 500(服务端代码错误) 502(网关错误 bad gateway) 通过socket实现web框架server.pyimport timefrom socket import *def f1(): # 静态网站 fp = open('index.html', 'r', encoding='utf-8') data = fp.read() fp.close() return bytes(data, encoding='utf-8')def f2(): fp = open('article.html', 'r', encoding='utf-8') data = fp.read() ctime = time.time() data = data.replace(\"@@content@@\", str(ctime)) fp.close() return bytes(data, encoding='utf-8')def f3(): import pymysql conn = pymysql.connect(host='127.0.0.1', user='root', password='123', db='youku', charset='utf8') cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) sql = \"select id,name,password,register_time from user\" cursor.execute(sql) res = cursor.fetchall() print(res) ''' [&#123;'id': 1, 'name': 'lxx', 'password': '202cb962ac59075b964b07152d234b70', 'register_time': '2019-06-26 21:48:47'&#125;, &#123;'id': 2, 'name': '111', 'password': '698d51a19d8a121ce581499d7b701668', 'register_time': '2019-06-26 21:49:10'&#125;] ''' res_list = [] for user in res: res_str = '&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;' % ( user['id'], user['name'], user['password'], user['register_time']) res_list.append(res_str) s = ''.join(res_list) fp = open('content.html', 'r', encoding='utf-8') data = fp.read() data = data.replace(\"@@content@@\", s) return bytes(data, encoding='utf-8') ### 需要将html代码和mysql结果融合def f4(): pass# 路由系统routes = [ ('/xxx', f1), ('/ooo', f2), ('/hhh', f3), ('/kkk', f4)]def run(): sk = socket() sk.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) sk.bind(('127.0.0.1', 8081)) sk.listen(5) while True: conn, addr = sk.accept() buf = conn.recv(8096) data = str(buf, encoding='utf-8') header_list = data.split('\\r\\n\\r\\n')[0].split('\\r\\n')[0] print(header_list) uri = header_list.split(' ')[1] func_name = None for items in routes: if items[0] == uri: func_name = items[1] break if func_name: res = func_name() else: res = b'404 not found' conn.send(b'HTTP/1.1 200 OK\\r\\nCache-Control: private\\r\\n\\r\\n') conn.send(res)if __name__ == '__main__': run() index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;this is index&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; content.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=\"1px\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;password&lt;/th&gt; &lt;th&gt;register_time&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; @@content@@ &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; article.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; @@content@@&lt;/body&gt;&lt;/html&gt; 通过wsgiref实现web框架step 1访问不同的url路径可以跳转到不同的网页from wsgiref.simple_server import make_serverdef application(environ, start_response): # 按着httpd协议解析数据（将所有请求存到一个字典里）: environ # 按着httpd协议组装数据（生成数据 响应首行，响应头）： start_response # 当前的请求路径 path = environ.get('PATH_INFO') start_response('200 OK', [('Content-Type', 'text/html')]) # 生成数据 请求首行，请求头，请求体 if path == \"/login\": with open('login.html', 'rb') as f: global data data = f.read() if path == '/index': with open('index.html', 'rb') as f: data = f.read() return [data]# 封装sockethttped = make_server(\"127.0.0.1\", 8060, application)# 等待客户连接: conn,addr=sock.accept()httped.serve_forever()# login.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"http://127.0.0.1:8800/\" method=\"post\"&gt; 用户名 &lt;input type=\"text\" name=\"user\"&gt; 密码 &lt;input type=\"password\" name=\"pwd\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;# index.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 style=\"color: red;\"&gt;宝贝 我来了&lt;/h1&gt;&lt;img src=\"http://s14.sinaimg.cn/middle/4b955cd7xcb1739815c4d&amp;690\" alt=\"\"&gt;&lt;a href=\"http://www.w3school.com.cn/\"&gt;click&lt;/a&gt;&lt;div style=\"height: 200px\"&gt;&lt;/div&gt;&lt;div&gt; &lt;h1 style=\"color: yellow; background-color: gray\"&gt;张帆喜欢的类型&lt;/h1&gt; &lt;img src=\"http://s8.sinaimg.cn/bmiddle/005DIuBKgy6KewCX5iv97&amp;690\" alt=\"\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 设置页面图标为京东图标from wsgiref.simple_server import make_serverdef application(environ: dict, start_response): start_response('200 ok', [('Content-Type','text/html')]) print(\"PATH\",environ.get('PATH_INFO')) path=environ.get('PATH_INFO') if path=='/favicon.ico': with open('favicon.ico','rb') as f: data=f.read() return [data] return [b'&lt;h1&gt;Hello,web!&lt;/h1&gt;']httped = make_server(\"127.0.0.1\", 8080, application)httped.serve_forever() step 2通过列表的映射来使得访问不同的url路径可以跳转到不同的网页 from wsgiref.simple_server import make_serverdef login(): with open('login.html', 'rb') as f: data = f.read() return datadef index(): with open('index.html', 'rb') as f: data = f.read() return datadef favi(): with open('favicon.ico', 'rb') as f: data = f.read() return datadef application(environ: dict, start_response): start_response('200 ok', [('Content-Type', 'text/html')]) print(\"PATH\", environ.get('PATH_INFO')) # 当前请求路径 global path path = environ.get('PATH_INFO') url_patterns = [ (\"/login\", login), (\"/index\", index), (\"/favicon.ico\", favi) ] func = None for item in url_patterns: print(item) if path == item[0]: func = item[1] break print(func) if func: return [func()] else: return [b'404!']httped = make_server(\"127.0.0.1\", 8080, application)httped.serve_forever()# login.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;登录页面&lt;/h4&gt;&lt;form action=\"http://127.0.0.1:8080/\" method=\"post\"&gt; 用户名 &lt;input type=\"text\" name=\"user\"&gt; 密码&lt;input type=\"password\" name=\"pwd\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;# index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;welcome to here&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"前端","slug":"前端","permalink":"http://cjwnb.top/tags/前端/"}]}]}