{"meta":{"title":"Gorg Chen","subtitle":"","description":null,"author":"Gorg Chen","url":"http://cjwnb.top","root":"/"},"pages":[{"title":"分类","date":"2019-07-14T14:54:31.000Z","updated":"2019-07-15T18:00:03.036Z","comments":true,"path":"categories/index.html","permalink":"http://cjwnb.top/categories/index.html","excerpt":"","text":""},{"title":"链接","date":"2019-07-14T14:46:05.000Z","updated":"2019-07-15T18:00:29.456Z","comments":true,"path":"link/index.html","permalink":"http://cjwnb.top/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-14T14:30:38.000Z","updated":"2019-07-15T18:00:40.178Z","comments":true,"path":"tags/index.html","permalink":"http://cjwnb.top/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-07-20T13:21:22.502Z","updated":"2019-07-20T13:21:22.402Z","comments":true,"path":"images/ajax.html","permalink":"http://cjwnb.top/images/ajax.html","excerpt":"","text":"多对多表三种创建方式第一种django orm自动创建 class Book(models.Model): name = models.CharField(max_length=32) authors = models.ManyToManyField(to='Author')class Author(models.Model): name = models.CharField(max_length=32) 第二种手动创建第三张表 class Book(models.Model): name = models.CharField(max_length=32) class Author(models.Model): name = models.CharField(max_length=32) class Book2Author(models.Model): book = models.ForeignKey(to='Book') author = models.ForeignKey(to='Author') info = models.CharField(max_length=32) 第三种半自动创建第三张表(可扩展性高，并且能够符合orm查询) class Book(models.Model): name = models.CharField(max_length=32) # 第三种创建表的方式 authors = models.ManyToManyField(to='Author',through='Book2Author',through_fields=('book','author'))class Author(models.Model): name = models.CharField(max_length=32) book = models.ManyToManyField(to='Book',through='Book2Author',through_fields=('author','book'))class Book2Author(models.Model): book = models.ForeignKey(to='Book') author = models.ForeignKey(to='Author') info = models.CharField(max_length=32) 案例 查询书籍对应的作者 ​ models.py from django.db import models# Create your models here.class Book(models.Model): name = models.CharField(max_length=32) authors=models.ManyToManyField(to='Author',through='Book2Author',through_fields=('book','author'))class Author(models.Model): name = models.CharField(max_length=32)class Book2Author(models.Model): book = models.ForeignKey(to='Book') author = models.ForeignKey(to='Author') info=models.CharField(max_length=64) tests.py import osif __name__ == \"__main__\": os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"ajax.settings\") import django django.setup() from app01 import models res=models.Book.objects.filter(pk=1).values('authors__name') print(res) # &lt;QuerySet [&#123;'authors__name': 'lyysb'&#125;, &#123;'authors__name': 'hhpsb'&#125;]&gt; book_obj=models.Book.objects.filter(pk=1).first() res=book_obj.authors.all() print(res) 编码格式urlencoded​ 对应的数据格式:name=jason&amp;password=666​ 后端获取数据:request.POST​ ps；django会将urlencoded编码的数据解析自动放到request.POST formdata​ form表单传输文件的编码格式​ 后端获取文件格式数据:request.FILES​ 后端获取普通键值对数据:request.POST application/json​ ajax发送json格式数据​ 需要注意的点​ 编码与数据格式要一致"}],"posts":[{"title":"CMDB(一)","slug":"CMDB","date":"2019-08-22T00:46:45.209Z","updated":"2019-08-22T11:30:07.029Z","comments":true,"path":"2019/08/22/CMDB/","link":"","permalink":"http://cjwnb.top/2019/08/22/CMDB/","excerpt":"","text":"自动化运维的目的和愿景将人工介入的所有操作, 全部变成各类系统,降低人力成本 为什么要做CMDB场景1项目上线 流程 产品经理调研需求 ====&gt; 定一个时间开发 ====&gt; 测试(开发自己测试+测试人员专业测试 ) ====&gt; 产品项目上线(运维) 传统运维流程 解压文件 ====&gt; 部署到响应的服务器目录下 传统运维存在问题 效率不高 不能实现覆盖有bug的代码, 只能全局覆盖 解决方案 代码上线系统 必要条件 服务器的IP地址, 硬盘空间, CPU的使用率,内存等 场景2监控服务器 传统运维流程 shell脚本去做 问题 不能实时监控 不能自动化 现在的流程 后台用python做, 手机服务器的元信息 ( IP地址, 硬盘大小, 内存) 前台配合kibana 场景3装机服务( 服务器操作系统 centos) 自动装机服务 服务器的元信息( IP地址) 场景4年底统计 传统运维流程 ​ 使用excel统计 存在问题 不能实时记录, 需要对变更进行记录 现在的流程 统计资产的系统 ​ 还得需要收集服务器的各种信息, 需要实时的汇报变更记录 CMDB资产管理系统 本质上就是收集服务器的各种信息 开发CMDB的思路和大概做法 使用python代码执行linux命令去获取服务器上的对应信息 使用http协议发送命令的执行结果 CMDB的四套方案第一套方案agent方案 其本质上就是在各个服务器上执行subprocess.getoutput()命令，然后将每台机器上执行的结果，返回给主机API，然后主机API收到这些数据之后，放入到数据库中，最终通过web界面展现给用户 API代码 import jsonimport subprocessres = subprocess.getoutput(\"ip a\")print(res[30:50])data= json.dumps(res[30:50])print(data)import requestsret = requests.post(\"http://127.0.0.1:8000/test/\", data=data)print(ret) Django服务 urls.py from django.conf.urls import urlfrom app01 import viewsurlpatterns = [ url(r'^test/', views.test),] views.py from django.shortcuts import HttpResponse# Create your views here.def test(request): print(request.body) return HttpResponse('ok') 第二套方案ssh类模式 中控机通过Paramiko（py模块）登录到各个服务器上，然后执行命令的方式去获取各个服务器上的信息 API代码 import paramiko# 创建ssh对象ssh = paramiko.SSHClient()# 允许连接不再known_hosts文件中的主机ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())# 连接服务器ssh.connect(hostname='test1', port=22, username='root', password='1')# 执行命令stdin, stdout, stderr = ssh.exec_command('ls')# 获取命令结果result = stdout.read().decode('utf-8')# print(result)# print(type(result))# 关闭连接ssh.close()import jsondata = json.dumps(result)import requestsret = requests.post(\"http://127.0.0.1:8000/test/\", data=data)print(ret) Django服务 urls.py from django.conf.urls import urlfrom app01 import viewsurlpatterns = [ url(r'^test/', views.test),] views.py from django.shortcuts import HttpResponse# Create your views here.def test(request): print(request.body) return HttpResponse('ok') 第三类方案saltstack类方案 此方案本质上和第二种方案大致是差不多的流程，中控机发送命令给服务器执行。服务器将结果放入另一个队列中，中控机获取将服务信息发送到API进而录入数据库。 # 安装 salt-master salt-minionroot@test1: ~ # cd /etc/yum.repos.d/root@test1: /etc/yum.repos.d # wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.reporoot@test1: /etc/yum.repos.d # yum install -y salt-master salt-minion# 获取ip地址root@test1: ~ # hostname -i172.16.240.128# 配置root@test1: ~ # vim /etc/salt/master 15 interface: 172.16.240.128root@test1: ~ # vim /etc/salt/minion 17 master: 172.16.240.128 80 id: c2.salt # 查看权限root@test1: ~ # salt-key -LAccepted Keys:Denied Keys:Unaccepted Keys:c2.saltRejected Keys:Redirecting to /bin/systemctl start salt-master.service# 加入权限root@test1: ~ # salt-key -a c2.saltThe following keys are going to be accepted:Unaccepted Keys:c2.saltProceed? [n/Y] YKey for minion c2.salt accepted.# 重启服务root@test1: ~ # service salt-master startroot@test1: /etc/yum.repos.d # service salt-minion start# 执行命令root@test1: ~ # salt 'c2.salt' cmd.run 'ifconfig' 对比 第一套方案 第二套方案 第三套方案 优点 速度快 每次新上线服务器, 都需要在新的服务器上部署 不用写python代码 缺点 不需要部署agent脚本 使用paramiko模块登录服务器的话, 速度比较慢 适用场景 服务器数量比较少 ( 小于100台) 服务器数量比较多 ( 大于100台) 服务器上已经部署了salt-stack或者想要使用salt-stack 第四类方案基本不用 代码实现客户端 clent- bin: 启动文件- src: 源文件- conf: 配置文件- lib: 全局的一些方法和配置- tests: 测试的文件(脚本) 实现第一个功能 集成自定制配置文件和全局配置文件 /conf/customer_settings.py #### 自定制配置USER = 'root' /lib/config/global_settings.py #### 全局配置EMAIL_USER = 'test' /lib/config/config.py from conf import customer_settingsfrom lib.config import global_settingsclass Settings(object): def __init__(self): ''' 集成全局配置 ''' for key in dir(global_settings): if key.isupper(): # 获取key所对应的值 v = getattr(global_settings, key) # 设置key,v设置到构造函数的数据初始化方法中 setattr(self, key, v) ''' 集成全自定制配置 ''' for key in dir(customer_settings): if key.isupper(): # 获取key所对应的值 v = getattr(customer_settings, key) # 设置key,v设置到构造函数的数据初始化方法中 setattr(self, key, v)settings = Settings() bin/start.py from lib.config.config import settingsif __name__ == '__main__': print(settings.EMAIL_USER)","categories":[{"name":"项目","slug":"项目","permalink":"http://cjwnb.top/categories/项目/"}],"tags":[{"name":"CMDB","slug":"CMDB","permalink":"http://cjwnb.top/tags/CMDB/"}]},{"title":"中间件","slug":"中间件","date":"2019-08-20T17:17:44.319Z","updated":"2019-08-21T16:52:51.820Z","comments":true,"path":"2019/08/21/中间件/","link":"","permalink":"http://cjwnb.top/2019/08/21/中间件/","excerpt":"","text":"中间件的理解作为浏览器和视图层之间的桥梁, 负责传递request( 请求信息)到视图函数 和 传递response( 响应信息) 到浏览器 中间件的执行流程 案例settings.py` MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', 'md.M1', 'md.M2',] middleware/md.py from django.utils.deprecation import MiddlewareMixinfrom django.shortcuts import HttpResponseclass M1(MiddlewareMixin): def process_request(self, request): print('M1.process_request') # return HttpResponse('M1.httpresponse') def process_view(self, request, callback, callback_args, callback_kwargs): print('M1.process_view',callback) # return callback(request, *callback_args, **callback_kwargs) def process_template_response(self, request, response): ''' 视图函数的返回值中,如果有render方法,这个方法才被调用 :param request: :param response: :return: ''' print('M1.process_template_response', response) return response def process_response(self, request, response): print('M1.process_response', response) return response def process_exception(self, request, exception): print('m1.process_exception',exception) return HttpResponse('M1返回的报错')class M2(MiddlewareMixin): def process_request(self, request): print('M2.process_request') def process_view(self, request, callback, callback_args, callback_kwargs): print('M2.process_view') def process_template_response(self, request, response): ''' 视图函数的返回值中,如果有render方法,这个方法才被调用 :param request: :param response: :return: ''' print('M2.process_template_response', response) return response def process_response(self, request, response): print('M2.process_response',response) return response def process_exception(self, request, exception): print('m2.process_exception',exception) return HttpResponse('M2返回的报错') /middleware/middleware/urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^test/', views.test), /app01/views.py class MyJsonResponse(object): def __init__(self, request, status, msg): self.request = request self.status = status self.msg = msg def render(self): from django.http import JsonResponse return JsonResponse(&#123;'status': self.status, 'msg': self.msg&#125;, json_dumps_params=&#123;'ensure_ascii': False&#125;)def test(request): print('test') return MyJsonResponse(request, True, '周泽SB')","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"中间件","slug":"中间件","permalink":"http://cjwnb.top/tags/中间件/"}]},{"title":"Linux基础","slug":"Linux基础","date":"2019-08-19T12:02:35.433Z","updated":"2019-08-20T06:59:56.923Z","comments":true,"path":"2019/08/19/Linux基础/","link":"","permalink":"http://cjwnb.top/2019/08/19/Linux基础/","excerpt":"","text":"环境准备 公私钥设置 参考链接 https://blog.csdn.net/nahancy/article/details/79059135 客户端配置临时DNS路径，生成公钥， 服务器上注册客户端的公钥 客户端 MacBook-Pro:~ root# ssh-keygen -t rsa -b 4096MacBook-Pro:~ root# ssh-copy-id -i /root/.ssh/id_rsa.pub root@test1 # 拷贝公钥到服务器 服务器查看 [root@test1 ~]# cd .ssh/[root@test1 .ssh]# lsauthorized_keys[root@test1 .ssh]# cat authorized_keys ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCtsRb4fqCsBxDL5h7bZa0IS+lQwx7WN6rua74b6wgoTXop9+6v7GqdhCzDVxNsIQvmv2ao9+65q/XpdcTHcUe5RG7IEnVRPV3wixrwtmcRFSUBlzQ9SAehzjRtmg3ULsbSDq2jLPGbTHLH1Uu1I/dLbNBAbXULbz7sCzv+o9YCPutf9IpeVhOhwXcM5Olx17437kqL1WJksoHzqBQMTvgf3ualhQl2Ro8E7TtEohpVTU69LIgMos+6mriBXTXgUiA2wT+phILboX12tOmTxyj8FBA7/3Icp0vufHYuCl6DfbSZZ6ijO532Kw6VjSjebz+yE0tgufMnGQ/8v9AZhBzHajhKgWtjwPB/kUPzXBFAIkwG9MnbkG18tl+XmsYdZBa4qfo6hXpc41AkQKusxbmsmRVui2xVyKSEvE5WBlza8S8DyzoTE9tO53wGrbni61YHDJXsJ6Y+d6YHSimM/wWrcd5UYSE+S+lAcOQdAMJylRfus6YuByKsHIdalLnuoawI7G3vI83wl7wt9WJKJbi3kS3RNq5dEns5HXgKOfNveKH/00Iun6U9qY0bRKqIuefG+5kizwy6R/YYxAnBdhFteSgtlyfsnowttYHvV5spXq3dCQtaEx5EzNUSw/C4DjypLC0HRgLc6sohOXTeAiV9rx+7t5RVabQPQ9CTHyakNw== root@MacBook-Pro.local Centos 7将网卡名称改为eth0 # 1. 编辑网卡的配置文件 /etc/sysconfig/network-scripts/ifcfg-ens33, 将其中的NAME改为eth0root@test1: ~ # grep -wi 'name' /etc/sysconfig/network-scripts/ifcfg-ens33 NAME=\"eth0\"# 2. 禁用该可预测命名规则。对于这一点，你可以在启动时传递“net.ifnames=0 biosdevname=0”的内核参数。这是通过编辑/etc/default/grub并加入“net.ifnames=0 biosdevname=0 ”到GRUB_CMDLINE_LINUX变量来实现的。root@test1: ~ # grep -w 'GRUB_CMDLINE_LINUX' /etc/default/grub GRUB_CMDLINE_LINUX=\"rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet net.ifnames=0 biosdevname=0\"# 3. 运行命令 grub2-mkconfig -o /boot/grub2/grub.cfgroot@test1: ~ # grub2-mkconfig -o /boot/grub2/grub.cfg # 4. 重启系统, 必须重启系统, 重启网卡没用# 5. 查看网卡的UUIDroot@test1: ~ # nmcli conNAME UUID TYPE DEVICE 有线连接 1 2fe12fd2-de9c-39ff-bb58-a3201da8bfc1 ethernet eth0 eth0 73e59479-100d-4565-a231-4da2cb51823e ethernet -- centos7网卡报错解决办法总结问题描述:我的vm中安装了一台虚拟机centos7,用着用着不知道为什么网络就不能用了.解决:查询了一下,好像是系统自带的NetworkManager这个管理套件有关系，关掉.关掉方法:systemctl stop NetworkManagersystemctl disable NetworkManager重新启动网络： systemctl start network.serviceifconfig 如果网络可以那么你就走运了,问题已解决,但我这个时候还是有报错.报错(Job for network.service failed because the control process exited with error code. See \"systemctl status network.service\" and \"journalctl -xe\" for details.[root@centos7 ~]#)按照提示输入systemctl status network.service查看到有:Failed to start LSB: Bring up/down networking.不是那么走运吧,继续解决.下一步修改mac地址,这一步我没有做,好像也没关系.对应网络配置文件里的字段是HWADDR=00:0c:29:0c:15:49再下一步,将7的网卡名改成了eth0（众所周知7的网卡名是eno后面随机 一串数字），生成菜单时没有生效，那么在此生效一下.重点了:&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;注意网卡配置名是已经修改成eth0以后执行下面操作，一共修改的地方有三处.第一处网卡名：/etc/sysconfig/network-scripts/ifcfg-eth0 ，第二处配置文件里面：NAME=eth0 ，第三处也是配置文件里面：DEVICE=eth0这里贴出一下我的ifcfg-eth0文件信息:注:我的虚拟机网卡是配置的NAT模式TYPE=EthernetBOOTPROTO=dhcpDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noNAME=eth0UUID=277e342b-b9fe-407c-a454-ee2058a29dbeDEVICE=eth0ONBOOT=yesPEERDNS=yesPEERROUTES=yesIPV6_PEERDNS=yes IPV6_PEERROUTES=yes修改/etc/sysconfig/grub,添加net.ifnames=0 biosdevname=0注意在/etc/sysconfig/grub文件的标红位置GRUB_CMDLINE_LINUX=\"crashkernel=128M rd.lvm.lv=centos/root rhgb quiet net.ifnames=0 biosdevname=0\"下一步,生成菜单grub2-mkconfig -o /boot/grub2/grub.cfg最后reboot重启,我的网卡重启就好了&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;/p&gt;我的问题解决了,但愿你的问题也解决了.最后贴上一些有用的命令:重启网卡systemctl restart network给NetworkManager-wait-online服务设置开机自启动systemctl enable NetworkManager-wait-online.service停止关闭NetworkManagersystemctl stop NetworkManagersystemctl disable NetworkManager 基础习题1.显示“I'm a student”到屏幕上面# echo \"I'm a student\"2.将“I'm a student”追加到hello.txt文件中# echo \"I'm a student\" &gt;&gt; hello.txt3.查看oldboy.txt文件中的内容，并显示行号（请使用cat命令）。# cat -n oldboy.txt 4.使用cat命令把oldboy oldgirl student三行内容（每个字符串是一行内容）写入到test.txt文件中# cat&gt;test.txt&lt;&lt;EOF&gt; oldboy&gt; oldgirl&gt; student&gt; EOF5.查看系统中/etc/services文件中的内容（使用more和less命令，进行上下页查看，并搜索关键字‘ssh’，之后退出。）6.显示/etc/passwd文件的前5行内容。# head -5 /etc/passwd7.显示/etc/passwd文件的最后5行内容。# tail -5 /etc/passwd8.显示/etc/services文件的第11行到第20行的内容9.已知文件123.txt内容如下，请过滤出包含oldboy字符串的命令10.过滤出文件123.txt中不包含test的行，并给其过滤出来的内容加上行号11.要求过滤出文件123.txt中包含oldboy的字符串，忽略大小写。12.要求过滤出文件123.txt中包含online字符串的行，并统计共有多少行。13.要求过滤出文件123.txt中包含oldboy的单词。14.调试系统服务时，希望能实时查看系统日志/var/log/messages的更新,如何做？15.打印配置文件/etc/passwd内容的行号及内容，你有几种方法可以实现？练习题一1.如何查看当前所在的目录？2.如何查看/etc/目录下的所有文件，请用命令实现。3.如何查看/dev/目录下文件的详细信息？4.我只想查看/root目录的信息，而不是root目录下文件的信息，请问怎么实现？5.如何对/etc/目录下文件按照时间排序查看，请用命令实现。6.我想测试虚拟机的联网情况，怎样设置一个别名，并且执行别名就能得到虚拟机的联网情况。7.怎样取消你刚才设置的别名？8.怎样查看你所执行过得命令？9.怎样清除你之前所执行过得命令？10.如何快速的执行你最近的一次以ls开头执行的命令？11.请说明一下这两个目录的用处/home、/root？12.请说明/etc这个目录主要是用来存放什么的？注意，这个目录极其重要。13.写出你的虚拟机网卡配置文件。14.说明下面这几个文件的作用：/etc/hostname、/etc/resolv.conf、/etc/hosts。15.说明下列目录的用处?/var # 存放一些变化的文件/tmp # 系统零时目录，系统会定死删除长时间没有访问的文件/dev # 存放设备文件/proc # 反映系统当前进程的实时状态/mnt # 提供挂载的一个目录/opt # 第三方厂商的软件存放目录 /bin # 普通用户使用 命令/sbin # 管理员使用的命令16.如何快速返回上一次所在的目录？17.创建一个名为oldboy的目录，然后进入该目录.18.在oldboy下创建一个名为student.txt的文件19.查看/etc/hosts文件的内容。20.复制/etc/hostname目录到/tmp目录下。21.创建一个目录，shanghai。22.创建一个文件，test.txt23.进入到shanghai这个目录。24.显示你当前所在的位置。25.如何快速从当前目录切换到家目录？练习题二14.复制/etc/hosts文件到/root目录下面15.把/root/hosts移动到/tmp目录下16.删除/tmp/hosts文件 17.复制/etc/services文件拷贝到当前目录。18.查询services文件中包含ssh字符有多少行19.在当前目录创建一个文件oldboy.txt,并将其移动到/opt目录下面20.在/tmp目录下创建oldboy.txt文件，将其移动到/opt目录，提示文件已经存在，是否覆盖，如果不想看到这个提示，怎么执行命令？21.删除/opt/下的所有文件22.已知，/oldboy已存在，如果给该目录名称修改为/oldgirl,请问怎么实现？23.rm命令可以删除目录和文件，其主要差别就是是否使用了什么选项。24.怎样强制删除一个文件，例如，删除oldboy.txt文件。25.什么命令可以移动目录或文件，还可以为文件或目录重命名。26.如何删除一个非空目录/opt？27.用\"rm -i\"删除文件时，系统会提示什么来让你确认28.用户编写一个文本文件a.txt，想将该文件名称改为txt.a，请问怎么实现？29.你知道有哪些命令可以查看文件内容？请一一列举出来。30.若希望在查看文件内容过程中可以用光标上下移动来查看文件内容，应使用什么命令？31.打印/etc/passwd 文件中的第 2-5 行32.查看ip地址的命令有哪些？33.只显示/etc/passwd文件的第五行34.统计/etc/passwd文件一共有多少行35.使用cat命令查看文本文件的内容时要对所有的输出行进行显示行号，怎么实现？36.使用mv命令，下列说法错误的是？37.删除文件的命令为？38.改变bash的提示符实际上就是改变变量？写一个文件，文件内容如下,下面39-45题请用该文件作答？server &#123; lisTEN 80; server_nAme www.oldboy.com; root /code/dOcs index INDEX.html;&#125;39.过滤www.oldboy.com这段关键字40.同时过滤出root和index的行，不区分大小写41.过滤index，区分大小写42.过滤出带\"O\"的行，不区分大小写43.过滤出不带\";\"的行44.过滤出以s开头的行45.统计该文件的行数46.如果某一天你误操作了\"rm -rf *\"，会发生哪些情况47.rm是个危险的命令，要求用命令rm删除文件时提示“rm command no bny”，怎么实现？48.设置rm命令不能用之后，有要删除/oldboy这个目录，怎么实现？49.已知123.txt文件内容如下：egonfrankjason 要求过滤出jason这一行的内容？你有几种方法？50.接上题，要求不显示egon这行内容，怎么实现？你有几种方法？ 编译安装nginxroot@test1: ~ # wget http://nginx.org/download/nginx-1.16.1.tar.gzroot@test1: ~ # tar -xf nginx-1.16.1.tar.gzroot@test1: ~ # cd nginx-1.16.1root@test1: ~/nginx-1.16.1 # mkdir -p /app/nginx-1.16.1root@test1: ~/nginx-1.16.1 # yum -y install pcre-develroot@test1: ~/nginx-1.16.1 # yum -y install openssl-develroot@test1: ~/nginx-1.16.1 # ./configure --with-http_ssl_module --prefix=/app/nginx-1.16.1root@test1: ~/nginx-1.16.1 # make &amp;&amp; make install# 启动nginxroot@test1: /app/nginx-1.16.1/sbin # /app/nginx-1.16.1/sbin/nginx# 在家目录配置软连接root@test1: ~ # ln -s /app/nginx-1.16.1/sbin/nginx nginx# 启动nginxroot@test1: ~ # /root/nginx# 重启nginxroot@test1: ~ # /root/nginx -s reload# 停止nginx( 杀进程)root@test1: ~ # ps -ef |grep nginxroot 27563 1 0 14:55 ? 00:00:00 nginx: master process /root/nginxnobody 27564 27563 0 14:55 ? 00:00:00 nginx: worker processroot 27583 27165 0 14:55 pts/0 00:00:00 grep --color=auto nginxroot@test1: ~ # kill -9 27563 27564root@test1: ~ # ps -ef |grep nginxroot 27609 27165 0 14:55 pts/0 00:00:00 grep --color=auto nginx","categories":[{"name":"Linux","slug":"Linux","permalink":"http://cjwnb.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://cjwnb.top/tags/Linux/"}]},{"title":"函数练习题","slug":"函数练习题","date":"2019-08-19T00:50:26.031Z","updated":"2019-08-19T11:54:09.091Z","comments":true,"path":"2019/08/19/函数练习题/","link":"","permalink":"http://cjwnb.top/2019/08/19/函数练习题/","excerpt":"","text":"写函数，计算传入数字参数的和。（动态传参） def add(x,y): return x+yres=add(1,2)print(res) 写函数，用户传入修改的文件名，与要修改的内容，执行函数，完成整个文件的批量修改操作 def modify(old, new, old_content, new_content): with open(old, 'r', encoding='utf-8') as f: for line in f: res = line.replace(old_content, new_content) with open(new, 'w', encoding='utf-8') as f1: f1.write(res)modify('old.txt', 'new.txt', '周泽SB', '胡鸿鹏SB') 写函数，检查用户传入的对象（字符串、列表、元组）的每一个元素是否含有空内容。 def check(obj): if not obj: print('数据不能为空') if isinstance(obj, str): for i in obj: if i.isspace(): print('%s是字符串类型,含有空字符' % obj) if isinstance(obj, (list, tuple)): for i in obj: if not i: print('%s为空' % i) if ' ' in i: print('元素中含有空字符') 写函数，检查传入字典的每一个value的长度,如果大于2，那么仅保留前两个长度的内容（对value的值进行截断），并将新内容返回给调用者，注意传入的数据可以是字符、list、dict from collections import Iterabledef check(obj: dict): if not isinstance(obj, dict): print('不是字典类型') return for value in obj.values(): if not isinstance(value, Iterable): print('value是数字,无法处理') else: lens = len(value) res = [] if lens &gt; 2: value_update = value[:2] res.append(value_update) return resres = check(&#123;'a': 1&#125;)res2 = check(&#123;'a': '周泽SB'&#125;)print(res) 解释闭包的概念 一种嵌套函数, 内部函数调用外部函数的变量, 这样在外部函数被调用的时候,函数体里的变量不会被销毁, 正常没有嵌套函数的话是会被销毁的, 一直到内部函数执行完毕外部函数的函数体里的变量才会被销毁, 这种现象就叫闭包 def Outer(): name = '周泽SB' def inner(): print(name) return innerinner = Outer()inner() 写函数，返回一个扑克牌列表，里面有52项，每一项是一个元组 def poker(): res = [] for i in range(1, 11): res.append(('黑桃', i)) res.append(('红桃', i)) res.append(('梅花', i)) res.append(('方块', i)) print(res)poker() 写函数，传入n个数，返回字典{‘max’:最大值,’min’:最小值} def calc(*args): max_value = max(args) min_values = min(args) return &#123;'max': max_value, 'min': min_values&#125;res=calc(1,2,3)print(res)","categories":[{"name":"python开发之路","slug":"python开发之路","permalink":"http://cjwnb.top/categories/python开发之路/"}],"tags":[{"name":"函数","slug":"函数","permalink":"http://cjwnb.top/tags/函数/"},{"name":"python","slug":"python","permalink":"http://cjwnb.top/tags/python/"}]},{"title":"面向对象(一)","slug":"面向对象(一)","date":"2019-08-18T17:03:59.096Z","updated":"2019-08-21T18:44:02.384Z","comments":true,"path":"2019/08/19/面向对象(一)/","link":"","permalink":"http://cjwnb.top/2019/08/19/面向对象(一)/","excerpt":"","text":"函数式编程和面向对象的对比Round 1开发一个消息提醒的功能(邮件/短信/微信) 函数式编程def email(em, text): ''' 发送短信 :return: ''' passdef msg(tel, text): ''' 发送短信 :return: ''' passdef wechat(num, text): ''' 发送微信 :return: ''' pass# 编写功能: 假设用户购买课程, 然后给zzsb发送提醒:if 1 == 1: msg('1233343322', '周泽SB入坑了') email('zz@sb.com', '周泽SB入坑了') wechat('xxxx', '周泽SB入坑了') 面向对象编程class Message: def email(self,em, text): ''' 发送短信 :return: ''' pass def msg(self,tel, text): ''' 发送短信 :return: ''' pass def wechat(self,num, text): ''' 发送微信 :return: ''' passobj=Message()if 1 == 1: obj.msg('1233343322', '周泽SB入坑了') obj.email('zz@sb.com', '周泽SB入坑了') obj.wechat('xxxx', '周泽SB入坑了') 对比 类型 优点 缺点 面向对象编程 归类, 将某些类似的函数写在一起 定义复杂/调用复杂 函数式编程 定义简单/调用简单 总结1. 函数式编程可能会比面向对象好2. python中支持两种编程方式3. 面向对象格式: 定义: class 类名: # 定义了一个类 def 函数名(self,*args,**kwargs): # 在类中编写了一个'方法' pass 调用: obj = 类名() # 创建了一个对象/实例化一个对象 obj.函数名(*args,**kwargs) # 通过对象调用其中的一个方法 Round 2周泽/38岁/男/上山去砍柴周泽/38岁/男/开车去东北周泽/38岁/男/喜欢在下面 函数式编程def kc(name, age, gender): data = '%s, 性别%s,今年%s岁,每周上山去砍柴 ' % (name, gender, age) print(data)def db(name, age, gender): data = '%s, 性别%s,今年%s岁,今天开车去东北 ' % (name, gender, age) print(data)def bj(name, age, gender): data = '%s, 性别%s,今年%s岁,喜欢大保健 ' % (name, gender, age) print(data)kc('周泽', 38, '不详')db('周泽', 38, '不详')bj('周泽', 38, '不详') 面向对象编程class ZhouZeSB: def __init__(self, name, age, gender): # 特殊的方法, 如果类名(), 则该方法会被自动执行 self.name = name self.age = age self.gender = gender def kc(self): data = '%s, 性别%s,今年%s岁,每周上山去砍柴 ' % (self.name, self.gender, self.age) print(data) def db(self): data = '%s, 性别%s,今年%s岁,今天开车去东北 ' % (self.name, self.gender, self.age) print(data) def bj(self): data = '%s, 性别%s,今年%s岁,喜欢大保健 ' % (self.name, self.gender, self.age) print(data)obj = ZhouZeSB('周泽', 38, '不详')obj.kc()obj.db()obj.bj() 总结1. 构造方法 示例1: class Foo: def __init__(self,name): # 构造方法,对实例化的对象添加数据 self.name=name self.age=38 obj=Foo('周泽SB') 通过构造方法, 可以将数据进行打包, 以后使用时, 去其中获取即可 示例2: class Bar: pass obj=Bar() 应用 将数据封装到对象中, 以供自己在方法中调用 主动调用其他类的成员方式一class Base(object): def f1(self): print('5个功能')class Foo(object): def f1(self): print('3个功能') Base.f1(self)obj=Foo()obj.f1() 方式二super: 按照类的继承顺序找下一个类执行调用方法和属性 class Base(object): def f1(self): print('5个功能')class Foo(Base): def f1(self): super().f1() print('3个功能')obj=Foo()obj.f1() 补充class Foo(object): def f1(self): print('3个功能')class Bar(object): def f1(self): print('6个功能')class Info(Foo,Bar): passobj=Info() obj.f1() # 按照Info的继承顺序调用方法f1 特殊成员1class Foo(object): def __new__(cls, *args, **kwargs): ''' 创建一个空的对象, :param args: :param kwargs: :return: ''' print('__new__') v1 = object.__new__(cls) # 在python内部创建一个当前类的对象(初创时内部是空的) print(v1) # 和实例化的obj是一个对象, 但是内部数据不一样 return v1 def __init__(self, a1, a2): ''' 写入数据到空对象 :param a1: :param a2: ''' print('__init__方法') self.a1 = a1 self.a2 = a2 def __call__(self, *args, **kwargs): print(1111, args, kwargs) return 123 def __getitem__(self, item): print(item) return 456 def __setitem__(self, key, value): print(key, value) def __delitem__(self, key): print(key) def __add__(self, other): print(self.a1 + other.a2) return self.a1 + other.a2 def __enter__(self): print('1111111') return 'enter方法' def __exit__(self, exc_type, exc_val, exc_tb): print('2222222') __init__类名() 自动执行 __init__ obj = Foo(1, 2) __new__真正的构造方法 自动执行 __new__ obj = Foo(1, 2)print(obj) __call__对象() 自动执行__call__方法 obj = Foo(1, 2)ret = obj(1, 2, k1=5656)print(ret) __getitem__对象 [] 自动执行__getitem__ obj = Foo(1, 2)a = obj['k1']print(a) __setitem__对象[&#39;xx&#39;]=11 自动执行__setitem__ ===&gt; 无返回值 obj = Foo(1, 2)obj['k1'] = 'xxx' __delitem__不是删除, 和__getitem__类似 del 对象[xx] 自动执行 __delitem__ ===&gt; 无返回值 obj = Foo(1, 2)del obj['k1'] __add__对象+对象 自动执行__add__ obj1 = Foo(1, 2)obj2 = Foo(88, 99)ret = obj1 + obj2 # self=obj1 other=obj2print(ret) __enter__ / __exit__with 对象 自动执行__enter__方法和__exit__方法 obj=Foo(1,2)with obj as f: print(f) # __enter__的返回值 print('内部代码') 特殊成员2class Foo(dict): def __init__(self, **kwargs): super().__init__(**kwargs) def __setattr__(self, key, value): self[key] = value def __getattr__(self, item): return self[item]obj = Foo()obj.name = '周泽SB'print(obj.name) __setattr__用 . 语法进行随意赋值 obj = Foo()obj.name = '周泽SB' __getattr__用.语法查看数据 obj = Foo()obj.name = '周泽SB'print(obj.name)","categories":[{"name":"python开发之路","slug":"python开发之路","permalink":"http://cjwnb.top/categories/python开发之路/"}],"tags":[{"name":"python","slug":"python","permalink":"http://cjwnb.top/tags/python/"},{"name":"面向对象","slug":"面向对象","permalink":"http://cjwnb.top/tags/面向对象/"}]},{"title":"常用模块(一)","slug":"模块(一)","date":"2019-08-18T13:57:19.384Z","updated":"2019-08-18T16:55:38.140Z","comments":true,"path":"2019/08/18/模块(一)/","link":"","permalink":"http://cjwnb.top/2019/08/18/模块(一)/","excerpt":"","text":"re引子取出兼职模特空姐联系方式.txt所有的手机号 兼职模特空姐联系方式.txt 姓名 地区 身高 体重 电话况咏蜜 北京 171 48 13651054608王心颜 上海 169 46 13813234424马纤羽 深圳 173 50 13744234523乔亦菲 广州 172 52 15823423525罗梦竹 北京 175 49 18623423421刘诺涵 北京 170 48 18623423765岳妮妮 深圳 177 54 18835324553贺婉萱 深圳 174 52 18933434452叶梓萱 上海 171 49 18042432324杜姗姗 北京 167 49 13324523342 方法1 读取文件循环+条件判断 f = open('兼职模特空姐联系方式.txt')phone_list=[]for line in f: name, region, height, weight, phone = line.split() if phone.startswith('1'): phone_list.append(phone)f.close()print(phone_list) 方法2 读取文件循环+re模块 import ref = open('兼职模特空姐联系方式.txt')res = re.findall(\"[0-9]&#123;11&#125;\", f.read())f.close()print(res) re的匹配语法 re.match 从头开始匹配 re.search 匹配全局, 找到了就匹配结束 import ref = open('兼职模特空姐联系方式.txt')res = re.search(\"[0-9]&#123;11&#125;\", f.read())f.close()print(res) # &lt;_sre.SRE_Match object; span=(56, 67), match='13651054608'&gt; re.findall 把所有匹配到的字符放到以列表中的元素返回 re.split 以匹配到的字符当做列表分隔符 re.sub 匹配字符并替换 re.fullmatch 全部匹配 常用的表达式规则'.' 默认匹配除\\n之外的任意一个字符，若指定flag DOTALL,则匹配任意字符，包括换行'^' 匹配字符开头，若指定flags MULTILINE,这种也可以匹配上(r\"^a\",\"\\nabc\\neee\",flags=re.MULTILINE)'$' 匹配字符结尾， 若指定flags MULTILINE ,re.search('foo.$','foo1\\nfoo2\\n',re.MULTILINE).group() 会匹配到foo1'*' 匹配*号前的字符0次或多次， re.search('a*','aaaabac') 结果'aaaa''+' 匹配前一个字符1次或多次，re.findall(\"ab+\",\"ab+cd+abb+bba\") 结果['ab', 'abb']'?' 匹配前一个字符1次或0次 ,re.search('b?','alex').group() 匹配b 0次'&#123;m&#125;' 匹配前一个字符m次 ,re.search('b&#123;3&#125;','alexbbbs').group() 匹配到'bbb''&#123;n,m&#125;' 匹配前一个字符n到m次，re.findall(\"ab&#123;1,3&#125;\",\"abb abc abbcbbb\") 结果'abb', 'ab', 'abb']'|' 匹配|左或|右的字符，re.search(\"abc|ABC\",\"ABCBabcCD\").group() 结果'ABC''(...)' 分组匹配， re.search(\"(abc)&#123;2&#125;a(123|45)\", \"abcabca456c\").group() 结果为'abcabca45''\\A' 只从字符开头匹配，re.search(\"\\Aabc\",\"alexabc\") 是匹配不到的，相当于re.match('abc',\"alexabc\") 或^'\\Z' 匹配字符结尾，同$ '\\d' 匹配数字0-9'\\D' 匹配非数字'\\w' 匹配[A-Za-z0-9]'\\W' 匹配非[A-Za-z0-9]'s' 匹配空白字符、\\t、\\n、\\r , re.search(\"\\s+\",\"ab\\tc1\\n3\").group() 结果 '\\t''(?P...)' 分组匹配 re.search(\"(?P[0-9]&#123;4&#125;)(?P[0-9]&#123;2&#125;)(?P[0-9]&#123;4&#125; &#39;.&#39; 测试 &gt;&gt;&gt; import re&gt;&gt;&gt; re.search('.','周泽SB')&lt;_sre.SRE_Match object; span=(0, 1), match='周'&gt;&gt;&gt;&gt; re.search('.','周泽SB').group()'周'&gt;&gt;&gt; test=re.search('.','\\n')&gt;&gt;&gt; test&gt;&gt;&gt; print(test)None","categories":[{"name":"python开发之路","slug":"python开发之路","permalink":"http://cjwnb.top/categories/python开发之路/"}],"tags":[{"name":"python","slug":"python","permalink":"http://cjwnb.top/tags/python/"},{"name":"模块","slug":"模块","permalink":"http://cjwnb.top/tags/模块/"}]},{"title":"函数(二)","slug":"函数(二)","date":"2019-08-16T08:24:34.542Z","updated":"2019-08-18T13:12:34.447Z","comments":true,"path":"2019/08/16/函数(二)/","link":"","permalink":"http://cjwnb.top/2019/08/16/函数(二)/","excerpt":"","text":"闭包闭包现象 正常来说,函数调用结束, 函数体里的变量都会被销毁, 而有一种现象是当函数执行完毕, 函数体里的变量不会被销毁, 因为这个变量被内嵌函数的一段代码调用着,无法销毁, 这种现象叫做闭包 def outer(): name='周泽SB' def inner(): print(name) return innerfunc_inner=outer() # 返回的是inner这个内层函数对象加上调用的变量name的作用域func_inner() 函数进阶-装饰器 闭包函数的一种, 主要场景是一段程序执行前需要判断是否是否登录 实现这个功能还要符合开放封闭原则 ( 不改变程序的源代码以及调用方式进行扩展) 源程序 def home(): print('主页')def america(): print('----欧美专区----')def japan(): print('----日韩专区----')home()america()japan() 初级版需要对america, japan加入登录验证 account = &#123; 'is_authenticated': False, 'username': 'zzsb', 'password': '123',&#125;def login(func): if not account['is_authenticated']: usr, pwd = input('请输入用户名 ').strip(), input('请输入密码 ').strip() username, password = account.get('username'), account.get('password') if usr == username and pwd == password: print('登入成功') account['is_authenticated'] = True return func else: print('用户名或密码错误') else: print('用户已登录,认证通过') return funcdef home(): print('主页')def america(): print('----欧美专区----')def japan(): print('----日韩专区----')america = login(america)america()japan = login(japan)japan() 使用闭包函数实现功能(装饰器的本质) account = &#123; 'is_authenticated': False, 'username': 'zzsb', 'password': '123',&#125;def login(func): def inner(): if not account['is_authenticated']: usr, pwd = input('请输入用户名 ').strip(), input('请输入密码 ').strip() username, password = account.get('username'), account.get('password') if usr == username and pwd == password: print('登入成功') account['is_authenticated'] = True func() else: print('用户名或密码错误') else: print('用户已登录,认证通过') func() return innerdef home(): print('主页')def america(): print('----欧美专区----')def japan(): print('----日韩专区----')america = login(america)america()japan = login(japan)japan() 高级版如果被要求登录认证的函数是有参数的,上面的代码就会报错 account = &#123; 'is_authenticated': False, 'username': 'zzsb', 'password': '123',&#125;def login(func): def inner(*args,**kwargs): if not account['is_authenticated']: usr, pwd = input('请输入用户名 ').strip(), input('请输入密码 ').strip() username, password = account.get('username'), account.get('password') if usr == username and pwd == password: print('登入成功') account['is_authenticated'] = True func(*args,**kwargs) else: print('用户名或密码错误') else: print('用户已登录,认证通过') func(*args,**kwargs) return innerdef home(): print('主页')def america(): print('----欧美专区----')def japan(vip_level): if vip_level &gt; 3: print('解锁高级玩法') else: print('----日韩专区----')america = login(america)america()japan = login(japan)japan(4) python装饰器用法在需要进行登录验证的函数上加上@装饰器函数 account = &#123; 'is_authenticated': False, 'username': 'zzsb', 'password': '123',&#125;def login(func): def inner(*args,**kwargs): if not account['is_authenticated']: usr, pwd = input('请输入用户名 ').strip(), input('请输入密码 ').strip() username, password = account.get('username'), account.get('password') if usr == username and pwd == password: print('登入成功') account['is_authenticated'] = True func(*args,**kwargs) else: print('用户名或密码错误') else: print('用户已登录,认证通过') func(*args,**kwargs) return innerdef home(): print('主页')@logindef america(): print('----欧美专区----')@logindef japan(vip_level): if vip_level &gt; 3: print('解锁高级玩法') else: print('----日韩专区----')america()japan(4) 列表生成式将列表的值的元素每一个加1 使用lambda函数 a = [1, 2, 3, 4, 5]res = map(lambda x: x + 1, a)print(list(res)) 使用列表生成式 a = [1, 2, 3, 4, 5]ls = [i+1 for i in a]print(ls) 生成器range在python2和python3的区别 python2环境下自动生成数字存入对象 &gt;&gt;&gt; range(10)[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] python3中只是一个生成器对象 &gt;&gt;&gt; range(10)range(0, 10) 引子 for循环生成100000000 个数字 import timestart= time.time()for i in range(100000000): if i == 100: break print(i)print(time.time()-start) # 2.91226005554 while循环生成100000000 个数字 import timestart = time.time()count = 0while count &lt; 100000000: count += 1 if count &gt; 100: breakprint(time.time() - start) # 0.000188112258911 什么是生成器 以上2个例子: for循环执行效率更慢, 因为先生成1-100000000的列表,再进行判断, 这种占用大量内存空间 while循环是通过某种算法( 每次自加1)计算出下一次循环的数据, 根据需要进行取值, 这种占用内存更少 在python中, 这种一边循环一边计算下一次循环的值的机制就是生成器, 也可理解为一种数据类型 创建生成器&gt;&gt;&gt; (x*x for x in range(10)) &lt;generator object &lt;genexpr&gt; at 0x10ddf5a50&gt; 生成器取值通过next取值&gt;&gt;&gt; test=(x*x for x in range(5))&gt;&gt;&gt; test&lt;generator object &lt;genexpr&gt; at 0x103979d58&gt;&gt;&gt;&gt; next(test)0&gt;&gt;&gt; next(test)1&gt;&gt;&gt; next(test)4&gt;&gt;&gt; next(test)9&gt;&gt;&gt; next(test)16&gt;&gt;&gt; next(test) # 取不到值就会报错Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;StopIteration 取出所有值&gt;&gt;&gt; test=(x*x for x in range(5))&gt;&gt;&gt; for i in test:... print(i)... 014916 函数生成器实现斐波那契数列 1 2 3 5 8 13…. count = 0a = 0b = 1while count &lt; 20: old_a = a a = b b = old_a + a ''' 第一次循环: old_a=0 a=1 b=1 第二次循环: old_a=1 a=1 b=2 第三次循环: old_a=1 a=2 b=3 第四次循环: old_a=2 a=3 b=5 ''' print(b) count += 1 通过生成器实现斐波那契数列def MakeServer(n): ''' 生成器函数 ''' count = 0 a = 0 b = 1 while count &lt; n: old_a = a a = b b = old_a + a ''' 第一次循环: old_a=0 a=1 b=1 第二次循环: old_a=1 a=1 b=2 第三次循环: old_a=1 a=2 b=3 第四次循环: old_a=2 a=3 b=5 ''' yield b # 暂停并返回b的值, 下面的代码通过next()函数触发才会执行 count += 1obj=MakeServer(6)print(obj.__next__())print(obj.__next__())print(obj.__next__())print(obj.__next__())print('----生成器----')print(obj.__next__())print(obj.__next__()) Yield接收外部输入的值错误代码 TypeError: can’t send non-None value to a just-started generator def g_test(): while True: n = yield print('recieve from outside', n)g=g_test()for i in range(10): g.send(i) 解决方案 先发送一个None给到生成器 def g_test(): while True: n = yield print('recieve from outside', n)g=g_test()g.send(None) # 调用生成器, 同时会发送None到Yieldfor i in range(10): g.send(i) # 调用生成器, 同时发送i def g_test(): while True: n = yield print('recieve from outside', n)g=g_test()g.__next__() # 调用生成器, 同时会发送None到Yieldfor i in range(10): g.send(i) # 调用生成器, 同时发送i 实现单线程下的多并发def consumer(name): print('消费者%s准备吃包子了...' % name) while True: baozi_num = yield print('消费者%s吃了包子%s' % (name, baozi_num))c1 = consumer('c1')c2 = consumer('c2')c3 = consumer('c3')c1.__next__()c2.__next__()c3.__next__()for i in range(1, 6): print('-------生成了第%s批包子-------' % i) c1.send(i) c2.send(i) c3.send(i) 迭代器可迭代对象 直接作用于for循环的对象统称为可迭代对象 ( 可以被循环 ) 判断一个对象是否是Iterable对象 &gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance([],Iterable)True&gt;&gt;&gt; isinstance(&#123;&#125;,Iterable)True&gt;&gt;&gt; isinstance('abc',Iterable)True&gt;&gt;&gt; isinstance((x for x in range(10)),Iterable)True&gt;&gt;&gt; isinstance(100,Iterable)False 哪些数据类型可以直接作用于for循环 集合类型数据 , list, tuple, dict, set, str等 generator, 包括生成器和带yield的generator function 什么是迭代器 可以被next() 函数调用并不断返回下一个值的对象称为迭代器: Iterator 判断一个对象是否是Iterator &gt;&gt;&gt; from collections import Iterator&gt;&gt;&gt; isinstance(1,Iterator)False&gt;&gt;&gt; isinstance(&#123;&#125;,Iterator)False&gt;&gt;&gt; isinstance([],Iterator)False&gt;&gt;&gt; isinstance('周泽SB',Iterator)False&gt;&gt;&gt; isinstance((i for i in range(10)),Iterator) # 生成器对象是迭代器对象True&gt;&gt;&gt; iter(&#123;&#125;) # 可迭代对象通过调用函数iter()可转换为迭代器对象 &lt;dict_keyiterator object at 0x10a9ad1d8&gt;&gt;&gt;&gt; isinstance(iter(&#123;&#125;),Iterator)True&gt;&gt;&gt; isinstance(iter([]),Iterator)True&gt;&gt;&gt; isinstance(iter('周泽SB'),Iterator)True","categories":[{"name":"python开发之路","slug":"python开发之路","permalink":"http://cjwnb.top/categories/python开发之路/"}],"tags":[{"name":"函数","slug":"函数","permalink":"http://cjwnb.top/tags/函数/"},{"name":"python","slug":"python","permalink":"http://cjwnb.top/tags/python/"}]},{"title":"函数(一)","slug":"函数","date":"2019-08-14T17:08:16.374Z","updated":"2019-08-17T14:14:01.852Z","comments":true,"path":"2019/08/15/函数/","link":"","permalink":"http://cjwnb.top/2019/08/15/函数/","excerpt":"","text":"基本定义 一个程序的运行经常性伴随着函数, 所以函数可以理解为一段子程序或者子过程 函数的参数形参 定义函数时候指定调用函数时候需要传递的参数 实参 调用函数时候传递的参数 位置参数 形参的一种, 实参传递给函数时候,根据形参的位置进行传递 默认参数 形参的一种, 函数在定义时候, 指定形参的值, 函数在调用时候, 如果实参传递了数据就使用实参传递的数据,否则就是用定义时候定义的这个值, 这个值又叫默认值 关键字参数 通过变量赋值的方式对函数进行传参 def Test(x,y) print(x,y) Test(x=1, y=2) 非固定参数 形参的一种, args, *kwargs *args 实参传递的值就是单列容器打散后的值, 就是直接传值, 最后如果没有参数接收, 就有这个参数接收, 用元组的方式保存, 传值方式和位置参数的传值是一样的 **kwargs 实参传递的值就是双列容器打散后的值, 只有字典才是双列容器, 最后如果没有关键字参数接收, 则全部存入kwargs中, 传值方式和关键字传参一样 def Test(name,*args,**kwargs): print(name,args,kwargs)Test('周泽SB','说得对',age=88, sex='not knownd') 函数的返回值和作用域返回值函数外部的代码想要获得函数的执行结果,则在函数里面用return语句来定义 函数在执行过程中只要遇到return语句, 就会停止执行并返回结果 如果未在函数中通过return语句来定义返回值, 则函数默认返回值就是None 在函数中return多个值, 在函数外部拿到的时候, 这些值会以一个元组的形式呈现 全局与局部变量 局部变量只能够在函数内部调用 全局变量在程序的任何位置都可以被调用 函数内部在调用变量的时候,先找局部变量,再找全局变量 name='周泽SB' # 全局变量def Test(): global name # 将变量name作为全局变量(不推荐使用) name='炮王' # 局部变量 print(name) print(locals()) # 查看局部变量(函数内的变量) print(globals()) # 查看全局变量Test() # 炮王print(name) # 周泽SB 传递列表,字典产生的现象 函数内如果直接调用全局变量, 则可以调用全局变量的一切的属性和方法 ls = ['周泽SB', '胡鸿鹏SB']dic = &#123;'name': \"周泽SB\", 'age': 87, 'hobby': '大保健'&#125;def Test(ls,dic): ls.append('罗文SB') # ls是全局变量, 函数内调用全局变量ls并执行它的方法 dic['desc']='为老不尊' # dic是全局变量, 函数内调用全局变量ls并执行它的方法 return ls,dicreturn_get=Test(ls,dic)# 打印的结果一模一样print(return_get)print(ls,dic) 嵌套&amp;匿名&amp;高阶嵌套函数 在函数内定义函数并调用这个函数, 只有在外层函数调用时候, 内层函数才会变得有意义 name='周泽SB'def Test(): name='炮王' def inner(): name='周泽被绿了' print('第三层打印',name) inner() print('第二层打印',name)Test()print('第一层打印',name) 匿名函数 不需要指定函数的名字 一般不会写太复杂的语法, 能写的最复杂的也只是诸如三元运算符之类 calc_lambda = lambda x, y: x ** y # 定义匿名函数res_lambda = calc_lambda(2, 3) # 调用匿名函数print(res_lambda) # 打印匿名函数的返回值 上面的功能定义成有名函数 def calc(x, y): return x ** yres = calc(2, 3)print(res) 与map函数配合使用map函数的用法 map(func, *iterables) --&gt; map object def calc(x): return x**2res=map(calc,[1,2,3,4])print(list(res)) 与匿名函数连用 res = map(lambda x: x ** 2, [1, 2, 3, 4])print(list(res)) 匿名函数使用三元表达式 res = map(lambda x: x ** 2 if x &gt; 10 else x ** 3, [1, 2, 3, 4,12])print(list(res)) 高阶函数就是返回一个函数名的函数就叫高阶函数 接收一个或多个函数作为输入 返回的是输入的一个或多个函数的返回值 def get_abs(num): return int(str(num).strip('-'))def add(x,y,func): # 接收函数名作为输入 return func(x)+func(y) # 返回输入的函数的返回值res=add(-130,-5,get_abs)print(res) 练习 写一个余数计算器 def get_abs(num): return int(str(num).strip('-'))def add(x,y,func): return func(x)%func(y)res=add(-7,-6,get_abs)print(res) 函数的递归 必须要有一个明确的结束条件 每次递归,问题的规模会越来越小,离结果会越来越近 递归效率不高,递归层次过多会导致栈溢出, 会占用更多内存, 影响程序性能,所以python解释器默认加了1000层的递归限制 将 100这个数字每次都除以2, 一直到不能除 n = 100while n &gt; 0: n = n // 2 print(n) 通过函数来实现 def calc(n): print(n) if n &gt; 0: n = n // 2 calc(n) print(n)calc(100) 内置函数 abs 取绝对值 bin 返回整数的二进制格式( 将十进制转成二进制 ), 输出结果以0b开头 &gt;&gt;&gt; bin(10)'0b1010'&gt;&gt;&gt; bin(100)'0b1100100'&gt;&gt;&gt; bin(1000)'0b1111101000' hex 返回一个10进制的16进制表示形式, 以0x开头 &gt;&gt;&gt; hex(10)'0xa'&gt;&gt;&gt; hex(100)'0x64' oct 返回一个10进制的8进制表示形式, 以0o开头 &gt;&gt;&gt; oct(10)'0o12' bool 返回一个数据结构是True 或者 False , 0, None(空字符串, 空集合,空字典,空列表, 空元组)都为False, 其余都为True &gt;&gt;&gt; bool([])False&gt;&gt;&gt; bool('')False&gt;&gt;&gt; bool(())False&gt;&gt;&gt; bool(&#123;&#125;)False&gt;&gt;&gt; bool(0)False&gt;&gt;&gt; bool(None)False&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool('周泽SB')True all 可迭代对象中每个元素通过bool函数判断都为True, 最后结果为True, 否则是False &gt;&gt;&gt; test=[1,2,3,0]&gt;&gt;&gt; all(test)False&gt;&gt;&gt; test2=[1,2,3]&gt;&gt;&gt; all(test2)True any 可迭代对象中每个元素通过bool函数判断只要有一个为True, 最后结果为True, 否则是False &gt;&gt;&gt; test3=[0,None,'']&gt;&gt;&gt; any(test3)False&gt;&gt;&gt; test4=[1,2,0,None,'']&gt;&gt;&gt; any(test4)True bytearray 将字节变成容器对象, 可以修改数据 &gt;&gt;&gt; str='周泽SB' &gt;&gt;&gt; a=str.encode('gbk')&gt;&gt;&gt; ab'\\xd6\\xdc\\xd4\\xf3SB'&gt;&gt;&gt; b=bytearray(a)&gt;&gt;&gt; bbytearray(b'\\xd6\\xdc\\xd4\\xf3SB')&gt;&gt;&gt; b[0]214&gt;&gt;&gt; b[1]220&gt;&gt;&gt; b[2]212&gt;&gt;&gt; b[3]243&gt;&gt;&gt; b[4]83&gt;&gt;&gt; b[5]66&gt;&gt;&gt; b[1]=200&gt;&gt;&gt; bbytearray(b'\\xd6\\xc8\\xd4\\xf3SB')&gt;&gt;&gt; b.decode('gbk')'秩泽SB' bytes 对字符串进行编码 &gt;&gt;&gt; test='周泽大炮'&gt;&gt;&gt; byte(test,'gbk')Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;NameError: name 'byte' is not defined&gt;&gt;&gt; bytes(test,'gbk')b'\\xd6\\xdc\\xd4\\xf3\\xb4\\xf3\\xc5\\xda'&gt;&gt;&gt; test.encode('gbk')b'\\xd6\\xdc\\xd4\\xf3\\xb4\\xf3\\xc5\\xda' callable 用于检查一个对象是否是可调用的。如果返回 True，object 仍然可能调用失败；但如果返回 False，调用对象 object 绝对不会成功。 对于函数、方法、lambda 函式、 类以及实现了 *_call_ *方法的类实例, 它都返回 True。 &gt;&gt;&gt; a=1&gt;&gt;&gt; callable(a)False&gt;&gt;&gt; def add(a,b):... return a+b... &gt;&gt;&gt; callable(add) # # 函数返回 TrueTrue&gt;&gt;&gt; class A(object):... def method(self):... return 0... &gt;&gt;&gt; callable(A) # 类返回 TrueTrue&gt;&gt;&gt; a=A()&gt;&gt;&gt; callable(a) # 没有实现 __call__, 返回 FalseFalse&gt;&gt;&gt; class B(object):... def __call__(self):... return 0... &gt;&gt;&gt; callable(B)True&gt;&gt;&gt; b=B()&gt;&gt;&gt; callable(b) # 实现 __call__, 返回 TrueTrue chr 返回一个数字对应的ascii字符 &gt;&gt;&gt; chr(65)'A'&gt;&gt;&gt; chr(90)'Z'&gt;&gt;&gt; chr(97)'a'&gt;&gt;&gt; chr(122)'z' dict 生成一个空字典 &gt;&gt;&gt; dic=dict()&gt;&gt;&gt; dic&#123;&#125; dir 显示对象的所有的可调用属性 &gt;&gt;&gt; test=[1,2,3]&gt;&gt;&gt; test.test.append( test.count( test.insert( test.reverse(test.clear( test.extend( test.pop( test.sort( test.copy( test.index( test.remove( &gt;&gt;&gt; dir(test)['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'] divmod 返回除法的商和余数 &gt;&gt;&gt; divmod(4,3)(1, 1)&gt;&gt;&gt; divmod(10,3)(3, 1) enumerate 返回列表的索引和元素 &gt;&gt;&gt; a=['周泽SB','胡鸿鹏SB']&gt;&gt;&gt; enumerate(a)&lt;enumerate object at 0x10d6c0f78&gt;&gt;&gt;&gt; list(enumerate(a))[(0, '周泽SB'), (1, '胡鸿鹏SB')] eval 把字符串形式的list,dict,set,tuple 再转换成原有的数据类型 a = ['周泽SB', '胡鸿鹏SB']f = open('eval_test', 'w', encoding='utf-8')f.write(str(a))f.close()f2 = open('eval_test', 'r', encoding='utf-8')res = f2.read()f2.close()print(type(res)) # &lt;class 'str'&gt;ls_res = eval(res)print(type(ls_res)) # &lt;class 'list'&gt; exec 把字符串格式的代码,进行转义并执行 &gt;&gt;&gt; exec(\"print('周泽SB')\")周泽SB filterdef Test(x): return x &gt; 10 # 返回的是True或者Falseres = filter(Test, [1, 3, 5, 44, 33])print(list(res))# 或者可以用匿名函数&gt;&gt;&gt; res=filter(lambda x:x&gt;10,[1,44,22,3])&gt;&gt;&gt; list(res)[44, 22] frozenset 把一个集合变成不可修改的数据类型 &gt;&gt;&gt; a=&#123;1,2&#125;&gt;&gt;&gt; a.add(4)&gt;&gt;&gt; a&#123;1, 2, 4&#125;&gt;&gt;&gt; b=frozenset(a)&gt;&gt;&gt; b.add(5)Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;AttributeError: 'frozenset' object has no attribute 'add'&gt;&gt;&gt; bfrozenset(&#123;1, 2, 4&#125;) globals 打印全局作用域里所有变量的信息 &gt;&gt;&gt; globals()&#123;'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': &#123;&#125;, '__builtins__': &lt;module 'builtins' (built-in)&gt;, 'test': [1, 2, 3], 'test2': [1, 2, 3], 'test3': [0, None, ''], 'test4': [1, 2, 0, None, ''], 'str': '周泽SB', 'a': &#123;1, 2, 4, 6&#125;, 'b': frozenset(&#123;1, 2, 4&#125;), 'add': &lt;function add at 0x10d6b3a60&gt;, 'A': &lt;class '__main__.A'&gt;, 'B': &lt;class '__main__.B'&gt;, 'dic': &#123;&#125;, 'res': &lt;filter object at 0x10d6b1f60&gt;&#125; id 查看对象的内存地址 &gt;&gt;&gt; a&#123;1, 2, 4, 6&#125;&gt;&gt;&gt; id(a)4518231624 isinstance 判断一个数据结构的类型 &gt;&gt;&gt; bfrozenset(&#123;1, 2, 4&#125;)&gt;&gt;&gt; isinstance(b,frozenset)True&gt;&gt;&gt; isinstance(b,list)False map 会根据提供的函数对指定序列做映射 &gt;&gt;&gt; map(lambda x:x**2,[2,3,4])&lt;map object at 0x10d6b1e48&gt;&gt;&gt;&gt; list(map(lambda x:x**2,[2,3,4]))[4, 9, 16] max 求最大值 &gt;&gt;&gt; c=[33,545,232,3433]&gt;&gt;&gt; max(c)3433# 字符串比的是unicode中的对应的ascii里的数字的大小&gt;&gt;&gt; d=['周泽SB','胡鸿鹏SB']&gt;&gt;&gt; max(d)'胡鸿鹏SB'&gt;&gt;&gt; ascii('周泽SB')\"'\\\\u5468\\\\u6cfdSB'\"&gt;&gt;&gt; ascii('胡鸿鹏SB')\"'\\\\u80e1\\\\u9e3f\\\\u9e4fSB'\" min 求最小值 &gt;&gt;&gt; d=['周泽SB','胡鸿鹏SB']&gt;&gt;&gt; min(d)'周泽SB' ord 返回ascii字符对应的十进制数 &gt;&gt;&gt; ord('周')21608&gt;&gt;&gt; ord('泽')27901&gt;&gt;&gt; ord('S')83&gt;&gt;&gt; ord('B')66&gt;&gt;&gt; ord('胡')32993&gt;&gt;&gt; ord('鸿')40511&gt;&gt;&gt; ord('鹏')40527 round 将一个小数四舍五入 &gt;&gt;&gt; round(16.7,1)16.7&gt;&gt;&gt; round(16.79,1)16.8&gt;&gt;&gt; round(16.79,0)17.0 zip 可以把2个或多个列表拼成一个列表 &gt;&gt;&gt; a=[1,2,3]&gt;&gt;&gt; b=['周泽SB','胡鸿鹏SB']&gt;&gt;&gt; c=[33,44,55]&gt;&gt;&gt; zip(a,b)&lt;zip object at 0x10d6b8708&gt;&gt;&gt;&gt; list(zip(a,b))[(1, '周泽SB'), (2, '胡鸿鹏SB')]&gt;&gt;&gt; list(zip(a,b,c))[(1, '周泽SB', 33), (2, '胡鸿鹏SB', 44)] 名称空间 存放名字的地方, 存放变量名与值这样一个关系的地方 分类 Locals 函数内部的名称空间, 一般包括函数的局部变量以及形式参数 enclosing function 在嵌套函数中外部函数的名称空间 globals 当前的模块空间, 或者全局空间, 在当前py文件的任何一个区域都是有效的 _builtins_ 内置模块空间, python解释器启动就形成的一些名字空间, 通过 print(dir(_builtins_)) 来查看 查找顺序 Locals —&gt; enclosing function—-&gt; globals —-&gt;_builtins_ level = 'L0'dir = 11def func(): level = 'L1' dir = 22 print(level, dir) def outer(): level = 'L2' dir = '33' print(level, dir) def inner(): level = 'L3' dir = '44' print(level, dir) inner() outer()func()","categories":[{"name":"python开发之路","slug":"python开发之路","permalink":"http://cjwnb.top/categories/python开发之路/"}],"tags":[{"name":"函数","slug":"函数","permalink":"http://cjwnb.top/tags/函数/"},{"name":"python","slug":"python","permalink":"http://cjwnb.top/tags/python/"}]},{"title":"python基础补充","slug":"python基础补充","date":"2019-08-12T14:40:05.948Z","updated":"2019-08-18T13:18:40.406Z","comments":true,"path":"2019/08/12/python基础补充/","link":"","permalink":"http://cjwnb.top/2019/08/12/python基础补充/","excerpt":"","text":"Bytes类型需求是数据要存到硬盘, 但是硬盘只能存二进制 2进制转换成文字的过程: 2进制===&gt;十进制===&gt;ascii/gbk/utf-8/(磁盘的编码)===&gt;unicode(内存的编码) unicode 又称万国码, 里面存着各种与各种编码的映射关系( 比如说gbk,utf-8) 数据往硬盘上存,因为硬盘只能存二进制, 就是说将数据转换成2进制,就能将数据存在硬盘上,所以数据往硬盘上存, 或者说数据转换成2进制之前,首先要进行编码 文字===&gt;utf-8/gbk ===&gt; 十进制===&gt; 2进制 图片===&gt;jpg/png===&gt; 十进制===&gt; 2进制 音乐===&gt;mp3/wav ===&gt; 十进制===&gt; 2进制 视频===&gt;mp4/mov ===&gt; 十进制===&gt; 2进制 编码https://www.cnblogs.com/alex3714/articles/7550940.html bytes类型是 以16进制形式表示,2个16进制数构成一个byte, 以b’ ‘来标识 &gt;&gt;&gt; s='小小周泽'&gt;&gt;&gt; s'小小周泽'&gt;&gt;&gt; s.encode('utf8')b'\\xe5\\xb0\\x8f\\xe5\\xb0\\x8f\\xe5\\x91\\xa8\\xe6\\xb3\\xbd' 以b开头的字符串就是字节类型, 也可以理解为二进制的一种显示方式 1一个十六进制数据占据4个二进制位, 2个十六进制数据就是占据8个二进制位, 也就是一个字节, 所以编码的过程就是将数据转换成字节 我们通过python解释器查看编码的结果是\\x开头的2个十六进制数,这是解释器内部设定的一种显示方式 为什么这么设定: 一个字节使用2个十六进制来表示,通过\\x开头, 所以查看数据的大小(占用多少个字节)可以通过查看多少个十六进制数(或者多少个\\x来判定) python3的运行环境中, 默认的编码是utf-8 如果自己指定编码打开文件, python按你指定的数据编码成2进制 f=open('bytes.txt','w',encoding='utf-8')f.write('周泽SB')f.write('胡鸿鹏SB')f.close() 不同编码占用的大小utf-8 一个中文占用3个字节 &gt;&gt;&gt; s='小小周泽'&gt;&gt;&gt; s'小小周泽'&gt;&gt;&gt; s.encode('utf8')b'\\xe5\\xb0\\x8f\\xe5\\xb0\\x8f\\xe5\\x91\\xa8\\xe6\\xb3\\xbd' 一个英文占用1个字节 &gt;&gt;&gt; s2='hhpsb'&gt;&gt;&gt; s2.encode('utf-8')b'hhpsb' GBK 一个中文占用2个字节 &gt;&gt;&gt; s3='小小周泽'&gt;&gt;&gt; s3.encode('gbk')b'\\xd0\\xa1\\xd0\\xa1\\xd6\\xdc\\xd4\\xf3' 一个英文占用1个字节 &gt;&gt;&gt; s4='hhpsb'&gt;&gt;&gt; s4.encode('gbk')b'hhpsb' 字符编码的转换编码与解码 s=’周泽sb’ s.encode(‘utf-8’) 以utf-8编码成2进制 s.decode(‘utf-8’) 从2进制解码成unicode str &gt;&gt;&gt; s='周泽sb'&gt;&gt;&gt; s'周泽sb'&gt;&gt;&gt; s.encode('utf-8')b'\\xe5\\x91\\xa8\\xe6\\xb3\\xbdsb'&gt;&gt;&gt; s_utf8=s.encode('utf-8')&gt;&gt;&gt; s_utf8b'\\xe5\\x91\\xa8\\xe6\\xb3\\xbdsb'&gt;&gt;&gt; s_utf8.decode('utf-8')'周泽sb'&gt;&gt;&gt; s_utf8.decode('')Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;LookupError: unknown encoding: &gt;&gt;&gt; s_utf8.decode()'周泽sb'&gt;&gt;&gt; s_utf8.decode('gbk') # s_utf8是以utf8为编码的字节, 解码不能用gbk, 只能用utf-8, 否则就是乱码'鍛ㄦ辰sb' 编码转换什么是编码转换 把文字从一种编码转换成另一种编码, 比如说从gbk编码的文字转换成utf-8 为什么要进行编码的转换 Windows 上不指定编码,默认将文字通过gbk进行编码 macOS, Linux 上不指定编码, 默认将文字通过utf-8进行编码 不同的系统,编码不一样,这样的话,如果windows系统上编码的文字想在linux系统上看就不可能了, 但是我现在想实现这个需求, 先通过万国码unicode进行转换, 然后再转换成相关的编码 # 打开一个gbk编码的文件, mac系统显示乱码cjw@MacBook-Pro: ~/Desktop/python_test $ cat test_windows ????ϲ??????# 进行编码转换f = open('test_windows', 'rb')s = f.read()f.close()# 编码成unicode, #这一步和解码的操作一样, 因为2进制字符串转换成普通字符串前,通过响应的编码进行解码后,是转换成unicode字符串存入内存中, 在通过unicode内部的映射关系转换成普通字符串s_gbk = s.decode('gbk') # 编码成utf-8s_utf8 = s_gbk.encode('utf-8') # 创建一个新的文件f=open('test_mac','wb')# 将重新编码后的utf-8编码的字节写入到打开的文件test_mac中f.write(s_utf8)f.close()# 验证, mac系统可以查看window上的该文件的内容cjw@MacBook-Pro: ~/Desktop/python_test $ cat test_mac 周泽喜欢大炮 深浅拷贝值拷贝 字符串 值拷贝, 字符串是不可变数据类型,所以值拷贝中一个变量值变了,则这个变量就会指向新的一个 &gt;&gt;&gt; a='zhouzesb'&gt;&gt;&gt; b=a&gt;&gt;&gt; b'zhouzesb'&gt;&gt;&gt; a='hhpsb'&gt;&gt;&gt; a'hhpsb'&gt;&gt;&gt; b'zhouzesb'&gt;&gt;&gt; a,b('hhpsb', 'zhouzesb') 容器数据类型值拷贝,容器类型数据是一种嵌套数据类型,外层是容器,占用一个内存地址, 内层包的数据是容器内的数据,各自占用一个内存地址 容器数据类型值拷贝时候,只是将外层容器的内存地址指向给一个变量名, 所以值拷贝这样的数据后,只要是这个值所指向的任何一个变量修改容器内的数据, 容器内的数据的地址如果是不可变类型,则就会替换成新的数据的地址, 值拷贝的对象指向的是外面的这个大容器, 最后取值都是通过大容器来取内部数据,所以其中一个变量修改数据, 其他指向这个容器的变量数据也变了 &gt;&gt;&gt; s=data=&#123;... 'name':'zhouzesb',... 'age':18,... 'scores':&#123;... '语文':123,... '数学':33,... '英语':44,... &#125;... &#125;&gt;&gt;&gt; s2=s&gt;&gt;&gt; s,s2(&#123;'name': 'zhouzesb', 'age': 18, 'scores': &#123;'语文': 123, '数学': 33, '英语': 44&#125;&#125;, &#123;'name': 'zhouzesb', 'age': 18, 'scores': &#123;'语文': 123, '数学': 33, '英语': 44&#125;&#125;)&gt;&gt;&gt; id(s),id(s2)(4307588296, 4307588296)&gt;&gt;&gt; s2['name']='hhpsb'&gt;&gt;&gt; s2&#123;'name': 'hhpsb', 'age': 18, 'scores': &#123;'语文': 123, '数学': 33, '英语': 44&#125;&#125;&gt;&gt;&gt; s&#123;'name': 'hhpsb', 'age': 18, 'scores': &#123;'语文': 123, '数学': 33, '英语': 44&#125;&#125; 浅拷贝 无论是浅拷贝还是深拷贝, 最后产生的数据是另外占用了一个内存空间 对于浅拷贝,如果容器类型数据中嵌套了一个容器类型, 则对于这个容器类型的数据, 如果通过其中一个变量修改其中的值, 则另一个变量也会跟着变 &gt;&gt;&gt; s=s2.copy()&gt;&gt;&gt; s,s2(&#123;'name': 'hhpsb', 'age': 18, 'scores': &#123;'语文': 123, '数学': 33, '英语': 44&#125;&#125;, &#123;'name': 'hhpsb', 'age': 18, 'scores': &#123;'语文': 123, '数学': 33, '英语': 44&#125;&#125;)&gt;&gt;&gt; s2['name']='zhouzesb'&gt;&gt;&gt; s,s2(&#123;'name': 'hhpsb', 'age': 18, 'scores': &#123;'语文': 123, '数学': 33, '英语': 44&#125;&#125;, &#123;'name': 'zhouzesb', 'age': 18, 'scores': &#123;'语文': 123, '数学': 33, '英语': 44&#125;&#125;)&gt;&gt;&gt; s['scores']['语文']=333&gt;&gt;&gt; s,s2(&#123;'name': 'hhpsb', 'age': 18, 'scores': &#123;'语文': 333, '数学': 33, '英语': 44&#125;&#125;, &#123;'name': 'zhouzesb', 'age': 18, 'scores': &#123;'语文': 333, '数学': 33, '英语': 44&#125;&#125;) 深拷贝 对于深拷贝,如果容器类型数据中嵌套了一个容器类型, 则对于这个容器类型的数据, 如果通过其中一个变量修改其中的值, 则另一个变量不会跟着变 &gt;&gt;&gt; import copy&gt;&gt;&gt; s4=copy.deepcopy(s)&gt;&gt;&gt; s4,s(&#123;'name': 'hhpsb', 'age': 18, 'scores': &#123;'语文': 333, '数学': 33, '英语': 44&#125;&#125;, &#123;'name': 'hhpsb', 'age': 18, 'scores': &#123;'语文': 333, '数学': 33, '英语': 44&#125;&#125;)&gt;&gt;&gt; s['name']='zhouzesb'&gt;&gt;&gt; s,s4(&#123;'name': 'zhouzesb', 'age': 18, 'scores': &#123;'语文': 333, '数学': 33, '英语': 44&#125;&#125;, &#123;'name': 'hhpsb', 'age': 18, 'scores': &#123;'语文': 333, '数学': 33, '英语': 44&#125;&#125;)&gt;&gt;&gt; s['scores']['语文']=333333211545443&gt;&gt;&gt; s,s4(&#123;'name': 'zhouzesb', 'age': 18, 'scores': &#123;'语文': 333333211545443, '数学': 33, '英语': 44&#125;&#125;, &#123;'name': 'hhpsb', 'age': 18, 'scores': &#123;'语文': 333, '数学': 33, '英语': 44&#125;&#125;)","categories":[{"name":"python开发之路","slug":"python开发之路","permalink":"http://cjwnb.top/categories/python开发之路/"}],"tags":[{"name":"函数","slug":"函数","permalink":"http://cjwnb.top/tags/函数/"},{"name":"python","slug":"python","permalink":"http://cjwnb.top/tags/python/"}]},{"title":"计算机硬件的组成","slug":"计算机硬件的组成","date":"2019-08-10T14:59:27.172Z","updated":"2019-08-20T07:18:21.688Z","comments":true,"path":"2019/08/10/计算机硬件的组成/","link":"","permalink":"http://cjwnb.top/2019/08/10/计算机硬件的组成/","excerpt":"","text":"计算机硬件分类所有的计算机硬件都是基于冯诺依曼体系. 根据冯诺依曼体系结构构成的计算机,必须具备如下功能 把需要的程序和数据送至计算机中 必须有长期记忆程序,数据,中间结果及最终运算结果的能力 能够完成各种算数,逻辑运算和数据传送等数据加工处理的能力 能够根据需要控制程序走向,并能根据指令控制机器的人各部件协调操作 能够按照要求将处理结果输出给用户 为了完成上述的功能,计算机必须具备五大基本结构 控制器 运算器 存储器 ​ 硬盘 ​ RAM ​ 内存条 ​ ROM 只读存储器 ​ BIOS 拔了主板电池所有BIOS的设置都会被清空 ​ NVRAM ​ CMOS 存储BIOS的一些设置 输入设备 ​ 键盘 ​ 系统识别的标准输入 ​ 鼠标 输出设备 ​ 显示器 cpu通过总线控制其他所有的硬件 运维与服务器运维人员核心职责 网站数据不能丢 网站7*24小时运行 提升用户体验 —访问的快 服务器什么是服务器 是提供计算服务的设备. 服务器的构成包括处理器,硬盘.内存,系统总线等 优势就是高可靠, 7*24小时一致保持运行, 高安全性,高扩展性,高管理型 服务器的尺寸 只有一个标准 – 高度( U ) 1U = 4.45CM 一般的服务器是2U 服务器的分类 机架式服务器 ( 互联网公司常用 ) 刀片服务器 塔式服务器( 更强壮的计算机 ) 互联网公司的服务器品牌 DELL( 大多数公司, 常用) HP 华为 IBM ( 大公司用) 浪潮 联想 华为提出的概念 ICT=IT+CT=物联网=云平台 认证 存储IE 云计算IE 服务器品牌Dell 时间 1U 2U 2010年以前 1850 1950 2850 2950 2010-2013 R410 R610 R710 2014-2016年 R420/430 R620/630 R720/R730 服务器硬件 CPU =====&gt; 负责计算 一般通过几路来描述服务器CPU的个数 1路就是一个物理CPU, 2路就是2个物理CPU 一般一个CPU有4个核心, 一般服务器有1个物理CPU, 好一点的有2个物理CPU 硬盘 内存 作用于CPU和硬盘之间 特点: 临时存放数据的地方, 断电之后内存中的信息消失 ( 一般不会断电,关机后由主板电池供电) raid卡 电源 ===&gt; 服务器一般为双电源,又叫AB路 远程控制卡 ===&gt; 可以理解为一种特殊的网卡,远程控制服务器, 通过这块网卡,直接就可以进入服务器的console如果要使用,需要连接网线, 液晶屏幕==&gt; 可以用来设置和查看ip等一些配置 网卡===&gt; 一般服务器有2块网卡, Dell R710有4块网卡","categories":[{"name":"Linux","slug":"Linux","permalink":"http://cjwnb.top/categories/Linux/"}],"tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://cjwnb.top/tags/计算机基础/"}]},{"title":"Linux三剑客","slug":"Linux三剑客","date":"2019-08-06T16:46:41.084Z","updated":"2019-08-06T16:46:41.084Z","comments":true,"path":"2019/08/07/Linux三剑客/","link":"","permalink":"http://cjwnb.top/2019/08/07/Linux三剑客/","excerpt":"","text":"案例1 取出本机macOS中en0的ip地址 方法一 - awk+awk $ ifconfig en0|awk 'NR==4'|awk '&#123;print $2&#125;' 方法二","categories":[{"name":"Linux","slug":"Linux","permalink":"http://cjwnb.top/categories/Linux/"}],"tags":[{"name":"基础命令","slug":"基础命令","permalink":"http://cjwnb.top/tags/基础命令/"}]},{"title":"Stark组件（四）列表页面自定义函数扩展","slug":"Stark组件（四）列表页面自定义函数扩展","date":"2019-08-06T12:10:43.238Z","updated":"2019-08-06T12:39:44.616Z","comments":true,"path":"2019/08/06/Stark组件（四）列表页面自定义函数扩展/","link":"","permalink":"http://cjwnb.top/2019/08/06/Stark组件（四）列表页面自定义函数扩展/","excerpt":"","text":"需求9","categories":[{"name":"项目","slug":"项目","permalink":"http://cjwnb.top/categories/项目/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"CRM","slug":"CRM","permalink":"http://cjwnb.top/tags/CRM/"}]},{"title":"Django中_Meta 部分用法","slug":"Django中_Meta 部分用法","date":"2019-08-05T14:59:38.488Z","updated":"2019-08-05T14:59:38.489Z","comments":true,"path":"2019/08/05/Django中_Meta 部分用法/","link":"","permalink":"http://cjwnb.top/2019/08/05/Django中_Meta 部分用法/","excerpt":"","text":"_meta用法class UserInfo(models.Model): ''' 用户表 ''' name = models.CharField(verbose_name='姓名', max_length=32) age = models.IntegerField(verbose_name='年龄') email = models.EmailField(verbose_name='邮箱', max_length=32) depart = models.ForeignKey(to='Depart', verbose_name='部门ID') def __str__(self): return self.name model.UserInfo._meta.app_label #获取该类所在app的app名称model.UserInfo._meta.model_name#获取该类对应表名（字符串类型）model.UserInfo._meta.get_field('name')#获取该类内指定字段信息（对象）model.UserInfo._meta.fields#获取该类内所有字段对象model.UserInfo._meta.get_fields#获取该类内所有字段信息（对象），包含反向关联的字段model.UserInfo._meta.many_to_many#获取该类内多对多字段信息 model.UserInfo._meta.get_field('name').verbose_name#获取该类内‘username’字段，verbose_name 的值","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"CRM","slug":"CRM","permalink":"http://cjwnb.top/tags/CRM/"}]},{"title":"Stark组件（三）定制页面显示的列","slug":"Stark组件（三）定制页面显示的列","date":"2019-08-05T13:36:44.635Z","updated":"2019-08-08T10:24:56.885Z","comments":true,"path":"2019/08/05/Stark组件（三）定制页面显示的列/","link":"","permalink":"http://cjwnb.top/2019/08/05/Stark组件（三）定制页面显示的列/","excerpt":"","text":"复习判断是否是函数from types import FunctionTypedef Foo(): passprint(isinstance(Foo,FunctionType)) # 判断如果是函数返回Trueprint(isinstance('222',FunctionType)) # 判断不是函数返回False 函数和方法本质上函数和方法都是类下面的一个函数,只是由于调用者的不同叫法不同,用法也不同 当调用者为对象( 当前类所产生的对象),则此时函数称之为方法,用法支持点语法 class Foo(object): def func(self,name): print(name)obj=Foo()obj.func('lyysb') # 方法print(obj.func) # bound method 当调用者为类, 则此时这个函数就是函数,用法也是函数的用法,该传多少参数就穿多少参数 class Foo(object): def func(self,name): print(name) Foo.func(obj, 'lxxsb') # 函数print(Foo.func) # function Foo 需求5 为每个表定制相关的列显示字段 这个主要操作的是视图函数change_list 每一个表的处理类是继承基类的一些方法,如果自身没有代码,则用基类的 因为要实现这个需求逻辑是一样的, 所以业务逻辑写在基类的change_list方法中 由于每个表在页面上显示的字段不一样, 所以需要一个东西存储显示的字段,所以在每个表所对应的处理类中定义一个列表 list_display 去存放这个表在页面上所显示的字段 当我们在浏览器中输入url, 比如说 http://127.0.0.1:8000/stark/app01/depart/list,这个时候就会找到depart这个路由关系 (depart是表名小写), 在路由的执行中,depart这个表所对应的的处理类已经被实例化了,类实例化才能执行下面的方法,并得到我们要的结果, 同时类实例化也能得到自身的属性,所以可以通过depart处理类实例化的对象可以拿到depart处理类中定义的存储这个表要在页面上显示的字段的容器 list_display, 循环这个列表,得到了表头数据 最后一个问题就是要显示数据库中的内容在页面上显示, 在后端拼这样一个格式, 先从数据库中所有的对象取出来, 然后通过循环数据库中每一行数据的对象, 然后内部再循环表头的数据, 表头数据就是数据库的一行数据的对象, 表头数据就是对象的属性,所以通过反射将对象属性的值给取出来,存入一个小列表,在循环外将所有小列表都存入一个大列表, 类似于 [ [ ‘1’,’技术部’], [ ‘2’, ‘销售部’] ] 在前端循环的时候, 一个小列表代表一行数据, 列表中的元素代表一行中的某一列数据, 所以第一个for循环行标签( tr )循环, 在行标签里循环每一个循环出来的小列表,在列标签(th)里循环, 这样页面就能拿到需要显示的数据 /stark/service/v1.py # return (urlconf_module, app_name, namespace)from django.conf.urls import urlfrom django.shortcuts import HttpResponse, renderclass StarkHandler(object): list_display = [] def __init__(self, model_class, prev): self.model_class = model_class self.prev = prev self.app_label, self.model_name = self.model_class._meta.app_label, self.model_class._meta.model_name def change_list(self, request): ''' 列表页面 :return: ''' model_name = self.model_name # 拿到表头数据 head_list = [] for key in self.list_display: verbose_name = self.model_class._meta.get_field(key).verbose_name head_list.append(verbose_name) # 拿到表内容 data_list = self.model_class.objects.all() body_list = [] for row in data_list: row_list = [] for col in self.list_display: row_list.append(getattr(row, col)) body_list.append(row_list) return render(request, 'stark/changelist.html', locals()) def add_view(self, request): ''' 添加页面 :return: ''' return HttpResponse('%s添加页面' % (self.model_class)) def change_view(self, request, pk): ''' 编辑页面 :return: ''' return HttpResponse('%s编辑页面' % self.model_class) def delete_view(self, request, pk): ''' 删除页面 :return: ''' return HttpResponse('删除页面') def get_url_name(self, param): if self.prev: name = '%s_%s_%s_%s' % (self.app_label, self.model_name, self.prev, param) return name name = '%s_%s_%s' % (self.app_label, self.model_name, param) return name @property def get_list_url_name(self): name = self.get_url_name('list') return name @property def get_add_url_name(self): name = self.get_url_name('add') return name @property def get_change_url_name(self): name = self.get_url_name('change') return name @property def get_delete_url_name(self): name = self.get_url_name('delete') return name @property def get_urls(self): patterns = [] # 设置别名 app名字_表名_功能名 patterns.append(url(r'^list', self.change_list, name=self.get_list_url_name)) patterns.append(url(r'^add', self.add_view, name=self.get_add_url_name)) patterns.append(url(r'^edit/(\\d+)', self.change_view, name=self.get_change_url_name)) patterns.append(url(r'^del/(\\d+)', self.delete_view, name=self.get_delete_url_name)) patterns.extend(self.extra_urls) return patterns @property def extra_urls(self): return []class StarkSite(object): def __init__(self): self.app_name = 'stark' self.namespace = 'stark' self._register = [] def register(self, model_class, handle_class=StarkHandler, prev=None): return self._register.append( &#123;\"model_class\": model_class, 'handle_class': handle_class(model_class, prev), 'prev': prev&#125;) @property def get_urls(self): patterns = [] for item in self._register: model_class, handle_class, prev = item['model_class'], item['handle_class'], item['prev'] # 获取app名字和表名小写 app_label, model_name = model_class._meta.app_label, model_class._meta.model_name if not prev: patterns.append(url(r'^%s/%s/' % (app_label, model_name), (handle_class.get_urls, None, None))) else: patterns.append(url(r'^%s/%s/%s/' % (app_label, model_name, prev), (handle_class.get_urls, None, None))) return patterns @property def urls(self): return self.get_urls, self.app_name, self.namespacesite = StarkSite() /app01/stark.py from app01 import modelsfrom stark.service.v1 import site, StarkHandlerclass UserInfoHandler(StarkHandler): list_display = ['name','age','email']site.register(models.UserInfo, prev='private', handle_class=UserInfoHandler)class DepartHandler(StarkHandler): list_display = ['title']site.register(models.Depart, handle_class=DepartHandler) /app02/stark.py from app02 import modelsfrom stark.service.v1 import site, StarkHandlerclass HostHandler(StarkHandler): list_display = ['host', 'ip']site.register(models.Host)class RoleHandler(StarkHandler): list_display = ['title']site.register(models.Role)class ProjectHandler(StarkHandler): list_display = ['title']site.register(models.Project) /stark/templates/stark/changelist.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&#123;&#123; model_name &#125;&#125;表&lt;/h1&gt;&lt;table border=\"1px\"&gt; &lt;thead&gt; &lt;tr&gt; &#123;% for header in header_list %&#125; &lt;th&gt;&#123;&#123; header &#125;&#125;&lt;/th&gt; &#123;% endfor %&#125; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt;&#123;# [['周泽SB', 88, 'paowang@bb.com'], ['胡鸿鹏SB', 99, 'dssdkjd@sb.com']]#&#125; &#123;% for row in body_list %&#125; &lt;tr&gt; &#123;% for col in row %&#125; &lt;th&gt;&#123;&#123; col &#125;&#125;&lt;/th&gt; &#123;% endfor %&#125; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 需求6 未定义list_display字段的页面,默认显示对象 如果要指定对象的显示方式,可以在ORM类中指定__str__方法 /stark/service/v1.py # return (urlconf_module, app_name, namespace)from django.conf.urls import urlfrom django.shortcuts import HttpResponse, renderclass StarkHandler(object): list_display = [] def __init__(self, model_class, prev): self.model_class = model_class self.prev = prev self.app_label, self.model_name = self.model_class._meta.app_label, self.model_class._meta.model_name def change_list(self, request): ''' 列表页面 :return: ''' model_name = self.model_name # 拿到表头数据 head_list = [] if self.list_display: for key in self.list_display: verbose_name = self.model_class._meta.get_field(key).verbose_name head_list.append(verbose_name) else: head_list.append(model_name) # 拿到表内容 data_list = self.model_class.objects.all() body_list = [] for row in data_list: row_list = [] if self.list_display: for col in self.list_display: row_list.append(getattr(row, col)) else: row_list.append(row) body_list.append(row_list) return render(request, 'stark/changelist.html', locals()) def add_view(self, request): ''' 添加页面 :return: ''' return HttpResponse('%s添加页面' % (self.model_class)) def change_view(self, request, pk): ''' 编辑页面 :return: ''' return HttpResponse('%s编辑页面' % self.model_class) def delete_view(self, request, pk): ''' 删除页面 :return: ''' return HttpResponse('删除页面') def get_url_name(self, param): if self.prev: name = '%s_%s_%s_%s' % (self.app_label, self.model_name, self.prev, param) return name name = '%s_%s_%s' % (self.app_label, self.model_name, param) return name @property def get_list_url_name(self): name = self.get_url_name('list') return name @property def get_add_url_name(self): name = self.get_url_name('add') return name @property def get_change_url_name(self): name = self.get_url_name('change') return name @property def get_delete_url_name(self): name = self.get_url_name('delete') return name @property def get_urls(self): patterns = [] # 设置别名 app名字_表名_功能名 patterns.append(url(r'^list', self.change_list, name=self.get_list_url_name)) patterns.append(url(r'^add', self.add_view, name=self.get_add_url_name)) patterns.append(url(r'^edit/(\\d+)', self.change_view, name=self.get_change_url_name)) patterns.append(url(r'^del/(\\d+)', self.delete_view, name=self.get_delete_url_name)) patterns.extend(self.extra_urls) return patterns @property def extra_urls(self): return []class StarkSite(object): def __init__(self): self.app_name = 'stark' self.namespace = 'stark' self._register = [] def register(self, model_class, handle_class=StarkHandler, prev=None): return self._register.append( &#123;\"model_class\": model_class, 'handle_class': handle_class(model_class, prev), 'prev': prev&#125;) @property def get_urls(self): patterns = [] for item in self._register: model_class, handle_class, prev = item['model_class'], item['handle_class'], item['prev'] # 获取app名字和表名小写 app_label, model_name = model_class._meta.app_label, model_class._meta.model_name if not prev: patterns.append(url(r'^%s/%s/' % (app_label, model_name), (handle_class.get_urls, None, None))) else: patterns.append(url(r'^%s/%s/%s/' % (app_label, model_name, prev), (handle_class.get_urls, None, None))) return patterns @property def urls(self): return self.get_urls, self.app_name, self.namespacesite = StarkSite() 需求7 为页面显示的列预留一个钩子函数, 不同的用户来访问的列是不一样的 /stark/service/v1.py # return (urlconf_module, app_name, namespace)from django.conf.urls import urlfrom django.shortcuts import HttpResponse, renderclass StarkHandler(object): list_display = [] def get_list_display(self): value = [] value.extend(self.list_display) return value def __init__(self, model_class, prev): self.model_class = model_class self.prev = prev self.app_label, self.model_name = self.model_class._meta.app_label, self.model_class._meta.model_name def change_list(self, request): ''' 列表页面 :return: ''' model_name = self.model_name # 拿到表头数据 head_list = [] if self.list_display: for key in self.get_list_display(): verbose_name = self.model_class._meta.get_field(key).verbose_name head_list.append(verbose_name) else: head_list.append(model_name) # 拿到表内容 data_list = self.model_class.objects.all() body_list = [] for row in data_list: row_list = [] if self.list_display: for col in self.get_list_display(): row_list.append(getattr(row, col)) else: row_list.append(row) body_list.append(row_list) return render(request, 'stark/changelist.html', locals()) def add_view(self, request): ''' 添加页面 :return: ''' return HttpResponse('%s添加页面' % (self.model_class)) def change_view(self, request, pk): ''' 编辑页面 :return: ''' return HttpResponse('%s编辑页面' % self.model_class) def delete_view(self, request, pk): ''' 删除页面 :return: ''' return HttpResponse('删除页面') def get_url_name(self, param): if self.prev: name = '%s_%s_%s_%s' % (self.app_label, self.model_name, self.prev, param) return name name = '%s_%s_%s' % (self.app_label, self.model_name, param) return name @property def get_list_url_name(self): name = self.get_url_name('list') return name @property def get_add_url_name(self): name = self.get_url_name('add') return name @property def get_change_url_name(self): name = self.get_url_name('change') return name @property def get_delete_url_name(self): name = self.get_url_name('delete') return name @property def get_urls(self): patterns = [] # 设置别名 app名字_表名_功能名 patterns.append(url(r'^list', self.change_list, name=self.get_list_url_name)) patterns.append(url(r'^add', self.add_view, name=self.get_add_url_name)) patterns.append(url(r'^edit/(\\d+)', self.change_view, name=self.get_change_url_name)) patterns.append(url(r'^del/(\\d+)', self.delete_view, name=self.get_delete_url_name)) patterns.extend(self.extra_urls) return patterns @property def extra_urls(self): return []class StarkSite(object): def __init__(self): self.app_name = 'stark' self.namespace = 'stark' self._register = [] def register(self, model_class, handle_class=StarkHandler, prev=None): return self._register.append( &#123;\"model_class\": model_class, 'handle_class': handle_class(model_class, prev), 'prev': prev&#125;) @property def get_urls(self): patterns = [] for item in self._register: model_class, handle_class, prev = item['model_class'], item['handle_class'], item['prev'] # 获取app名字和表名小写 app_label, model_name = model_class._meta.app_label, model_class._meta.model_name if not prev: patterns.append(url(r'^%s/%s/' % (app_label, model_name), (handle_class.get_urls, None, None))) else: patterns.append(url(r'^%s/%s/%s/' % (app_label, model_name, prev), (handle_class.get_urls, None, None))) return patterns @property def urls(self): return self.get_urls, self.app_name, self.namespacesite = StarkSite() /app01/stark.py from app01 import modelsfrom stark.service.v1 import site, StarkHandlerclass UserInfoHandler(StarkHandler): list_display = ['name','age','email'] def get_list_display(self): return ['name']site.register(models.UserInfo, prev='private', handle_class=UserInfoHandler)class DepartHandler(StarkHandler): list_display = ['title']site.register(models.Depart, handle_class=DepartHandler) 需求8 为页面提供自定义显示的函数, 比如说,希望访问Userinfo这张表的数据的时候,希望有编辑和删除2个选项, 将函数名加入list_display列表中, 在显示表头数据和表内容数据判断是否是函数,如果是函数就将函数的返回显示到页面 /app01/stark.py from app01 import modelsfrom stark.service.v1 import site, StarkHandlerfrom django.utils.safestring import mark_safeclass UserInfoHandler(StarkHandler): def display_edit(self, is_header=None): if is_header: return '编辑表头' return mark_safe('&lt;a href=\"http://www.baidu.com\"&gt;编辑&lt;/a&gt;') def display_delete(self, is_header=None): if is_header: return '删除表头' return mark_safe('&lt;a href=\"http://www.baidu.com\"&gt;删除&lt;/a&gt;') list_display = ['name', 'age', 'email',display_edit, display_delete]site.register(models.UserInfo, prev='private', handle_class=UserInfoHandler)class DepartHandler(StarkHandler): list_display = ['title']site.register(models.Depart, handle_class=DepartHandler) /stark/service/v1.py # return (urlconf_module, app_name, namespace)from django.conf.urls import urlfrom django.shortcuts import HttpResponse, renderfrom types import FunctionTypeclass StarkHandler(object): list_display = [] def get_list_display(self): value = [] value.extend(self.list_display) return value def __init__(self, model_class, prev): self.model_class = model_class self.prev = prev self.app_label, self.model_name = self.model_class._meta.app_label, self.model_class._meta.model_name def change_list(self, request): ''' 列表页面 :return: ''' model_name = self.model_name # 拿到表头数据 head_list = [] if self.list_display: for key_or_func in self.get_list_display(): if isinstance(key_or_func, FunctionType): head_list.append(key_or_func(self, is_header=True)) else: verbose_name = self.model_class._meta.get_field(key_or_func).verbose_name head_list.append(verbose_name) else: head_list.append(model_name) # 拿到表内容 data_list = self.model_class.objects.all() body_list = [] for row in data_list: row_list = [] if self.list_display: for col in self.get_list_display(): if isinstance(col, FunctionType): row_list.append(col(self, False)) else: row_list.append(getattr(row, col)) else: row_list.append(row) body_list.append(row_list) return render(request, 'stark/changelist.html', locals()) def add_view(self, request): ''' 添加页面 :return: ''' return HttpResponse('%s添加页面' % (self.model_class)) def change_view(self, request, pk): ''' 编辑页面 :return: ''' return HttpResponse('%s编辑页面' % self.model_class) def delete_view(self, request, pk): ''' 删除页面 :return: ''' return HttpResponse('删除页面') def get_url_name(self, param): if self.prev: name = '%s_%s_%s_%s' % (self.app_label, self.model_name, self.prev, param) return name name = '%s_%s_%s' % (self.app_label, self.model_name, param) return name @property def get_list_url_name(self): name = self.get_url_name('list') return name @property def get_add_url_name(self): name = self.get_url_name('add') return name @property def get_change_url_name(self): name = self.get_url_name('change') return name @property def get_delete_url_name(self): name = self.get_url_name('delete') return name @property def get_urls(self): patterns = [] # 设置别名 app名字_表名_功能名 patterns.append(url(r'^list', self.change_list, name=self.get_list_url_name)) patterns.append(url(r'^add', self.add_view, name=self.get_add_url_name)) patterns.append(url(r'^edit/(\\d+)', self.change_view, name=self.get_change_url_name)) patterns.append(url(r'^del/(\\d+)', self.delete_view, name=self.get_delete_url_name)) patterns.extend(self.extra_urls) return patterns @property def extra_urls(self): return []class StarkSite(object): def __init__(self): self.app_name = 'stark' self.namespace = 'stark' self._register = [] def register(self, model_class, handle_class=StarkHandler, prev=None): return self._register.append( &#123;\"model_class\": model_class, 'handle_class': handle_class(model_class, prev), 'prev': prev&#125;) @property def get_urls(self): patterns = [] for item in self._register: model_class, handle_class, prev = item['model_class'], item['handle_class'], item['prev'] # 获取app名字和表名小写 app_label, model_name = model_class._meta.app_label, model_class._meta.model_name if not prev: patterns.append(url(r'^%s/%s/' % (app_label, model_name), (handle_class.get_urls, None, None))) else: patterns.append(url(r'^%s/%s/%s/' % (app_label, model_name, prev), (handle_class.get_urls, None, None))) return patterns @property def urls(self): return self.get_urls, self.app_name, self.namespacesite = StarkSite() 需求9 根据URL的别名进行反向生成url路径 显示orm类中的choice选项定义的字段 app01/models.py from django.db import models# Create your models here.class Depart(models.Model): ''' 部门表 ''' title = models.CharField(verbose_name='部门名称', max_length=32)class UserInfo(models.Model): ''' 用户表 ''' name = models.CharField(verbose_name='用户名', max_length=32) age = models.IntegerField(verbose_name='年龄') email = models.EmailField(verbose_name='邮箱', max_length=32) depart = models.ForeignKey(to='Depart', verbose_name='部门') gender_choices = ( (1, '男'), (2, '女'), ) gender = models.IntegerField(verbose_name='性别', choices=gender_choices, default=1) app02/models.py from django.db import models# Create your models here.class Host(models.Model): ''' 主机表 ''' host = models.CharField(verbose_name='主机名', max_length=32) ip = models.GenericIPAddressField(verbose_name='IP')class Role(models.Model): ''' 角色表 ''' title = models.CharField(verbose_name='角色名', max_length=32) def __str__(self): return self.titleclass Project(models.Model): ''' 项目表 ''' title = models.CharField(verbose_name='项目名', max_length=32) def __str__(self): return self.title urls.py from django.conf.urls import urlfrom django.contrib import adminfrom stark.service.v1 import siteprint(site._register)print('路由开始')urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^stark/', site.urls),] /stark/service/v1.py # return (urlconf_module, app_name, namespace)from django.conf.urls import urlfrom django.shortcuts import HttpResponse, renderfrom types import FunctionTypefrom django.urls import reversefrom django.utils.safestring import mark_safedef get_choices(title, fields): ''' :param title: 希望页面显示的表头 :param fields: 字段名称 :return: ''' def inner(self, obj=None, is_header=None): if is_header: return title method = 'get_%s_display' % fields return getattr(obj, method)() return innerclass StarkHandler(object): list_display = [] def display_edit(self, is_header=None, obj=None): if is_header: return '编辑表头' # 得到编辑页面的别名 name = '%s:%s' % (self.site.namespace, self.get_change_url_name) # 反向生成url url = reverse(name, args=(obj.pk,)) return mark_safe('&lt;a href=\"%s\"&gt;编辑&lt;/a&gt;' % url) def display_delete(self, is_header=None, obj=None): if is_header: return '删除表头' # 获取删除页面的别名 name = '%s:%s' % (self.site.namespace, self.get_delete_url_name) url = reverse(name, args=(obj.pk,)) return mark_safe('&lt;a href=\"%s\"&gt;删除&lt;/a&gt;' % url) def get_list_display(self): value = [] value.extend(self.list_display) return value def __init__(self, model_class, prev, site): self.site = site self.model_class = model_class self.prev = prev self.app_label, self.model_name = self.model_class._meta.app_label, self.model_class._meta.model_name def change_list(self, request): ''' 列表页面 :return: ''' model_name = self.model_name # 拿到表头数据 head_list = [] if self.list_display: for key_or_func in self.get_list_display(): # ['name', 'age', 'email',display_edit, display_delete] if isinstance(key_or_func, FunctionType): head_list.append(key_or_func(self, is_header=True)) else: verbose_name = self.model_class._meta.get_field(key_or_func).verbose_name head_list.append(verbose_name) else: head_list.append(model_name) # 拿到表内容 data_list = self.model_class.objects.all() body_list = [] for row in data_list: row_list = [] if self.list_display: for col in self.get_list_display(): if isinstance(col, FunctionType): row_list.append(col(self, is_header=False, obj=row)) else: row_list.append(getattr(row, col)) else: row_list.append(row) body_list.append(row_list) return render(request, 'stark/changelist.html', locals()) def add_view(self, request): ''' 添加页面 :return: ''' return HttpResponse('%s添加页面' % (self.model_class)) def change_view(self, request, pk): ''' 编辑页面 :return: ''' return HttpResponse('%s编辑页面' % self.model_class) def delete_view(self, request, pk): ''' 删除页面 :return: ''' return HttpResponse('删除页面') def get_url_name(self, param): if self.prev: name = '%s_%s_%s_%s' % (self.app_label, self.model_name, self.prev, param) return name name = '%s_%s_%s' % (self.app_label, self.model_name, param) return name @property def get_list_url_name(self): name = self.get_url_name('list') return name @property def get_add_url_name(self): name = self.get_url_name('add') return name @property def get_change_url_name(self): name = self.get_url_name('change') return name @property def get_delete_url_name(self): name = self.get_url_name('delete') return name @property def get_urls(self): patterns = [] # 设置别名 app名字_表名_功能名 patterns.append(url(r'^list', self.change_list, name=self.get_list_url_name)) patterns.append(url(r'^add', self.add_view, name=self.get_add_url_name)) patterns.append(url(r'^edit/(\\d+)', self.change_view, name=self.get_change_url_name)) patterns.append(url(r'^del/(\\d+)', self.delete_view, name=self.get_delete_url_name)) patterns.extend(self.extra_urls) return patterns @property def extra_urls(self): return []class StarkSite(object): def __init__(self): self.app_name = 'stark' self.namespace = 'stark' self._register = [] def register(self, model_class, handle_class=StarkHandler, prev=None): return self._register.append( &#123;\"model_class\": model_class, 'handle_class': handle_class(model_class, prev, self), 'prev': prev&#125;) @property def get_urls(self): patterns = [] for item in self._register: model_class, handle_class, prev = item['model_class'], item['handle_class'], item['prev'] # 获取app名字和表名小写 app_label, model_name = model_class._meta.app_label, model_class._meta.model_name if not prev: patterns.append(url(r'^%s/%s/' % (app_label, model_name), (handle_class.get_urls, None, None))) else: patterns.append(url(r'^%s/%s/%s/' % (app_label, model_name, prev), (handle_class.get_urls, None, None))) return patterns @property def urls(self): return self.get_urls, self.app_name, self.namespacesite = StarkSite() /app01/stark.py from app01 import modelsfrom stark.service.v1 import StarkHandlerfrom stark.service.v1 import sitefrom stark.service.v1 import get_choicesclass UserInfoHandler(StarkHandler): # 为页面定制选择的字段的列 def display_gender(self, obj=None, is_header=None): if is_header: return '性别' return obj.get_gender_display() # 定制外键字段显示的内容,也可以在models中用__str__定义 def dispaly_depart(self, is_header=None, obj=None): if is_header: return '部门' return obj.depart.title # 定制页面显示的列 list_display = ['name', 'age', 'email', display_gender, get_choices('性别','gender'),dispaly_depart, StarkHandler.display_edit, StarkHandler.display_delete]site.register(models.UserInfo, prev='private', handle_class=UserInfoHandler)class DepartHandler(StarkHandler): list_display = ['id', 'title', StarkHandler.display_edit, StarkHandler.display_delete]site.register(models.Depart, handle_class=DepartHandler) /app02/stark.py from app02 import modelsfrom stark.service.v1 import site, StarkHandlerclass HostHandler(StarkHandler): list_display = ['host', 'ip', StarkHandler.display_edit, StarkHandler.display_delete]site.register(models.Host, handle_class=HostHandler)class RoleHandler(StarkHandler): list_display = ['title']site.register(models.Role)class ProjectHandler(StarkHandler): list_display = ['title']site.register(models.Project)","categories":[{"name":"项目","slug":"项目","permalink":"http://cjwnb.top/categories/项目/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"CRM","slug":"CRM","permalink":"http://cjwnb.top/tags/CRM/"}]},{"title":"Stark组件（二）URL别名的优化","slug":"Stark组件（二）URL别名的优化","date":"2019-08-05T12:57:59.217Z","updated":"2019-08-06T10:31:48.271Z","comments":true,"path":"2019/08/05/Stark组件（二）URL别名的优化/","link":"","permalink":"http://cjwnb.top/2019/08/05/Stark组件（二）URL别名的优化/","excerpt":"","text":"需求3 将一级路由分发再往下设置一级路由分发 在v1.py 中将所有路由的公共部分拆开来,作为一级路由, 放在url生成类(StarkSite) 中 在v1.py中的 基类处理类(StarkHandler) 中定义一个方法 get_urls,存储二级路由分发的url数据的列表, 最后返回 比如说 url(r&#39;edit/(\\d+)&#39;, self.change_view) 然后 在 v1.py 中的 url生成类中调用二级路由分发的url数据 每一个表中的url是不一样的 在v1.py中的 基类处理类(StarkHandler)中定义一个钩子函数 extra_urls ,返回一个空列表 在v1.py中的基类处理类(StarkHandler)中的get_urls中多写一行代码, 最后返回的列表追加钩子函数extra_urls返回的一个列表 如果某个表要增加路由的话,在自己的处理类中定义extra_urls方法, 将增加的路由关系写进一个列表并返回,最后被调用的时候就会使用自己的extra_urls方法,然后在基类的处理类中就会将增加的路由关系的列表和基类中默认的列表合二为一; 如果某个表需要减少路由的话,直接覆盖基类处理类(StarkHandler)中的get_urls方法就行,通过url 生成类(StarkSite)调用的时候,会调用自己的get_urls方法的返回值 对每一个分发的url设置别名 别名的作用主要是反向解析,这里先设置,后面需要用到 格式: app名字_表名_功能名 在基类处理类(StarkHandler)中的使用字符串拼接的方式生成url的时候指定一个name参数即可, 即二级路由的名字 但是需要判断是否有前缀,因为是否有前缀字符串拼接方式不同. 如果不判断,则和没有前缀的名字是一样的,因为就设置了一个别名,无论有没有前缀都是这个名字 /stark/service/v1.py # return (urlconf_module, app_name, namespace)from django.conf.urls import urlfrom django.shortcuts import HttpResponseclass StarkHandler(object): def __init__(self, model_class, prev): self.model_class = model_class self.prev = prev def change_list(self, request): ''' 列表页面 :return: ''' return HttpResponse('%s列表页面' % (self.model_class._meta.model_name)) def add_view(self, request): ''' 添加页面 :return: ''' return HttpResponse('%s添加页面' % (self.model_class)) def change_view(self, request, pk): ''' 编辑页面 :return: ''' return HttpResponse('%s编辑页面' % self.model_class) def delete_view(self, request, pk): ''' 删除页面 :return: ''' return HttpResponse('删除页面') @property def get_urls(self): patterns = [] # 设置别名 app名字_表名_功能名 app_label, model_name = self.model_class._meta.app_label, self.model_class._meta.model_name if not self.prev: patterns.append(url(r'^list', self.change_list, name='%s_%s_list' % (app_label, model_name))) patterns.append(url(r'^add', self.add_view, name='%s_%s_add' % (app_label, model_name))) patterns.append(url(r'^edit/(\\d+)', self.change_view, name='%s_%s_edit' % (app_label, model_name))) patterns.append( url(r'^del/(\\d+)', self.delete_view, self.change_view, name='%s_%s_del' % (app_label, model_name))) else: patterns.append(url(r'^list', self.change_list, name='%s_%s_%s_list' % (app_label, model_name, self.prev))) patterns.append(url(r'^add', self.add_view, name='%s_%s_%s_add' % (app_label, model_name, self.prev))) patterns.append( url(r'^edit/(\\d+)', self.change_view, name='%s_%s_%s_edit' % (app_label, model_name, self.prev))) patterns.append( url(r'^del/(\\d+)', self.delete_view, self.change_view, name='%s_%s_%s_del' % (app_label, model_name, self.prev))) patterns.extend(self.extra_urls) return patterns @property def extra_urls(self): return []class StarkSite(object): def __init__(self): self.app_name = 'stark' self.namespace = 'stark' self._register = [] def register(self, model_class, handle_class=StarkHandler, prev=None): return self._register.append( &#123;\"model_class\": model_class, 'handle_class': handle_class(model_class, prev), 'prev': prev&#125;) @property def get_urls(self): patterns = [] for item in self._register: model_class, handle_class, prev = item['model_class'], item['handle_class'], item['prev'] # 获取app名字和表名小写 app_label, model_name = model_class._meta.app_label, model_class._meta.model_name if not prev: patterns.append(url(r'^%s/%s/' % (app_label, model_name), (handle_class.get_urls, None, None))) patterns.append(url(r'^%s/%s/' % (app_label, model_name), (handle_class.get_urls, None, None))) patterns.append(url(r'^%s/%s/' % (app_label, model_name), (handle_class.get_urls, None, None))) patterns.append(url(r'^%s/%s/' % (app_label, model_name), (handle_class.get_urls, None, None))) else: patterns.append(url(r'^%s/%s/%s/' % (app_label, model_name, prev), (handle_class.get_urls, None, None))) patterns.append(url(r'^%s/%s/%s/' % (app_label, model_name, prev), (handle_class.get_urls, None, None))) patterns.append( url(r'^%s/%s/%s/(\\d+)' % (app_label, model_name, prev), (handle_class.get_urls, None, None))) patterns.append( url(r'^%s/%s/%s/(\\d+)' % (app_label, model_name, prev), (handle_class.get_urls, None, None))) return patterns @property def urls(self): return self.get_urls, self.app_name, self.namespacesite = StarkSite() /app01/stark.py from stark.service.v1 import sitefrom app01 import modelsfrom stark.service.v1 import StarkHandlerfrom django.conf.urls import urlfrom django.shortcuts import HttpResponseclass DepartHandler(StarkHandler): @property def extra_urls(self): ''' 增加URL,通过覆盖父类中的钩子函数extra_urls方法,改变方法中的列表的值, ''' patterns = [url(r'detail/(\\d+)', self.detail_view)] return patterns def detail_view(self, request, pk): return HttpResponse('%s的detail_View' % (self.model_class._meta.model_name))class UserInfoHandler(StarkHandler): @property def get_urls(self): ''' 改变父类中默认的URL, 通过覆盖继承的父类的get_urls方法 :return: ''' patterns = [] patterns.append(url(r'list', self.change_list)) patterns.append(url(r'add', self.add_view)) return patternssite.register(models.Depart, handler_class=DepartHandler)site.register(models.UserInfo, prev='private', handler_class=UserInfoHandler) /app02/stark.py from stark.service.v1 import sitefrom app02 import modelsfrom stark.service.v1 import StarkHandlerclass HostHandler(StarkHandler): passclass RoleHandler(StarkHandler): passclass ProjectHandler(StarkHandler): passsite.register(models.Host)site.register(models.Role)site.register(models.Project)site.register(models.Project, prev='private') 需求4 对别名进行优化,简化代码 /stark/service/v1.py # return (urlconf_module, app_name, namespace)from django.conf.urls import urlfrom django.shortcuts import HttpResponse, renderclass StarkHandler(object): list_display = [] def __init__(self, model_class, prev): self.model_class = model_class self.prev = prev self.app_label, self.model_name = self.model_class._meta.app_label, self.model_class._meta.model_name def change_list(self, request): ''' 列表页面 :return: ''' return HttpResponse('%s列表页面' % (self.model_class._meta.model_name)) def add_view(self, request): ''' 添加页面 :return: ''' return HttpResponse('%s添加页面' % (self.model_class)) def change_view(self, request, pk): ''' 编辑页面 :return: ''' return HttpResponse('%s编辑页面' % self.model_class) def delete_view(self, request, pk): ''' 删除页面 :return: ''' return HttpResponse('删除页面') def get_url_name(self, param): if self.prev: name = '%s_%s_%s_%s' % (self.app_label, self.model_name, self.prev, param) return name name = '%s_%s_%s' % (self.app_label, self.model_name, param) return name @property def get_list_url_name(self): name = self.get_url_name('list') return name @property def get_add_url_name(self): name = self.get_url_name('add') return name @property def get_change_url_name(self): name = self.get_url_name('change') return name @property def get_delete_url_name(self): name = self.get_url_name('delete') return name @property def get_urls(self): patterns = [] # 设置别名 app名字_表名_功能名 patterns.append(url(r'^list', self.change_list, name=self.get_list_url_name)) patterns.append(url(r'^add', self.add_view, name=self.get_add_url_name)) patterns.append(url(r'^edit/(\\d+)', self.change_view, name=self.get_change_url_name)) patterns.append(url(r'^del/(\\d+)', self.delete_view, name=self.get_delete_url_name)) patterns.extend(self.extra_urls) return patterns @property def extra_urls(self): return []class StarkSite(object): def __init__(self): self.app_name = 'stark' self.namespace = 'stark' self._register = [] def register(self, model_class, handle_class=StarkHandler, prev=None): return self._register.append( &#123;\"model_class\": model_class, 'handle_class': handle_class(model_class, prev), 'prev': prev&#125;) @property def get_urls(self): patterns = [] for item in self._register: model_class, handle_class, prev = item['model_class'], item['handle_class'], item['prev'] # 获取app名字和表名小写 app_label, model_name = model_class._meta.app_label, model_class._meta.model_name if not prev: patterns.append(url(r'^%s/%s/' % (app_label, model_name), (handle_class.get_urls, None, None))) else: patterns.append(url(r'^%s/%s/%s/' % (app_label, model_name, prev), (handle_class.get_urls, None, None))) return patterns @property def urls(self): return self.get_urls, self.app_name, self.namespacesite = StarkSite()","categories":[{"name":"项目","slug":"项目","permalink":"http://cjwnb.top/categories/项目/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"CRM","slug":"CRM","permalink":"http://cjwnb.top/tags/CRM/"}]},{"title":"macOS系统常见问题","slug":"macOS系统常见问题","date":"2019-08-05T05:26:36.170Z","updated":"2019-08-12T02:27:51.254Z","comments":true,"path":"2019/08/05/macOS系统常见问题/","link":"","permalink":"http://cjwnb.top/2019/08/05/macOS系统常见问题/","excerpt":"","text":"mac出现无法上网的问题电脑总盘符(/)-资源库-Preferences文件夹-SystemConfiguration文件夹-只保留文件com.apple.smb.server.plist/com.apple.Boot.plist MYSQL 命令行操作 启动mysql $ sudo /usr/local/mysql/support-files/mysql.server start 停止mysql $ sudo /usr/local/mysql/support-files/mysql.server stop 重启mysql $ sudo /usr/local/mysql/support-files/mysql.server restart Brew 更新慢的问题 ~ $ cd \"$(brew --repo)\"/usr/local/Homebrew $ git remote set-url origin https://mirrors.ustc.edu.cn/brew.git/usr/local/Homebrew $ cd \"$(brew --repo)/Library/Taps/homebrew/homebrew-core\"/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core $ git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core $ brew updateUpdated 1 tap (homebrew/core) Brew安装软件 安装telnet $ brew install telnet 安装iproute $ brew install iproute2mac$ ip a MacOS 命令 lsof macos自带命令, 不需要通过brew安装 $ lsof -i:3306 # 列出谁在使用3306端口COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMENavicat 1102 cjw 10u IPv4 0xdb4b36948523ba7b 0t0 TCP localhost:49570-&gt;localhost:mysql (ESTABLISHED) $ lsof -i # 列出所有网络链接$ lsof -i tcp # 列出所有tcp网络连接$ lsof -i udp # 列出所有udp网络连接$ lsof -i | grep -i ESTABLISHED #找出已建立的连接$ lsof -i | grep -i LISTEN # 找出监听端口","categories":[{"name":"macOS","slug":"macOS","permalink":"http://cjwnb.top/categories/macOS/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://cjwnb.top/tags/网络/"},{"name":"macOS","slug":"macOS","permalink":"http://cjwnb.top/tags/macOS/"}]},{"title":"Docker基础","slug":"Docker基础","date":"2019-08-01T16:42:09.966Z","updated":"2019-08-07T15:47:28.380Z","comments":true,"path":"2019/08/02/Docker基础/","link":"","permalink":"http://cjwnb.top/2019/08/02/Docker基础/","excerpt":"","text":"Docker简介 开源的容器引擎,可以让开发者打包应用以及依赖的库,然后发布到任何流行的linux发行版上,移植很方便 由go语言编写,基于apache2.0协议发布 基于linux kernel, 要想在windows下运行需要借助一个vm(虚拟机来实现) docker从1.13x开始,版本分为社区版ce和企业版ee,并且基于年月的时间线形式 Docker优势 启动速度快,秒级实现 资源利用率高,一台高配置服务器可以跑上千个docker容器 更快的交付和部署,一次创建和配置后,可以爱任意地方运行 内核级别的虚拟化,不需要额外的hypervisor支持,会有更高的性能和效率 易迁移,平台依赖性不强 和普通虚拟机对比 特性 容器 虚拟机 启动 秒级 分钟级 硬盘使用 一般为MB 一般为GB 性能 接近原生 弱于原生 系统支持量 单机支持上千个容器 一般几十个 Docker核心概念镜像 是一个只读的模板,类似于安装系统用到的哪个iso文件,我们通过镜像来完成各种应用的部署 容器 镜像类似于操作系统,而容器类似于虚拟机本身,它可以被启动,开始,停止,删除等操作,每个容器都是相互隔离的 仓库 存放镜像的一个场所,仓库分为公开仓库和私有仓库. 最大的公开仓库是Docker hub (hub.docker.com), 国内公开仓库(dockerpool.com ) 官网 https://www.docker.com/ GIithub https://github.com/docker/docker.github.io Docker安装Mac OS安装下载安装包 https://download.docker.com/mac/stable/Docker.dmg 查看docker版本$ docker --versionDocker version 19.03.1, build 74b1e89 Docker镜像管理配置阿里云加速器 https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 下载镜像$ docker pull centos 查看本地镜像 docker images 查看本地的镜像 $ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEcentos latest 9f38484d220f 4 months ago 202MBhello-world latest fce289e99eb9 7 months ago 1.84kB 搜索镜像 docker search xxx 搜索镜像, 其中xxx是关键词 $ docker search jumpserverNAME DESCRIPTION STARS OFFICIAL AUTOMATEDjumpserver/jumpserver 14 jiaxiangkong/jumpserver_docker 开源跳板机(堡垒机):认证,授权,审计,自动化运维 11 给镜像打标签 docker tag centos REPOSITORY名字 docker tag centos REPOSITORY名字:TAG名字 两个命令执行完通过 docker images 查询后会产生新的一行,但是这一行代表同一个镜像, 因为IAMGE ID字段是一样的, IMAGE ID是标识镜像唯一性的一个字段 $ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEcentos latest 9f38484d220f 4 months ago 202MB# 第一种写法$ docker tag centos download_by_cjw$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEcentos latest 9f38484d220f 4 months ago 202MBdownload_by_cjw latest 9f38484d220f 4 months ago 202MBhello-world latest fce289e99eb9 7 months ago 1.84kB# 第二种写法$ docker tag centos latest:test$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEcentos latest 9f38484d220f 4 months ago 202MBdownload_by_cjw latest 9f38484d220f 4 months ago 202MBlatest test 9f38484d220f 4 months ago 202MBhello-world latest fce289e99eb9 7 months ago 1.84kB 把镜像启动为容器 docker run -itd 镜像名 -i 标识让容器以标准输入打开 -t 标识分配一个伪终端 -d 标识后台启动 要把 -itd 写在要启动的容器前面,不然会报错 $ docker run -itd centos1a9c7102582349c97139851e4a62368bd2413f4cb77330ba5aebf758d5935f07 查看运行的容器 docker ps 查看运行的容器, 加上-a 选项后可以查看所有容器,包括未运行的 # 查看启动的容器$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES1a9c71025823 centos \"/bin/bash\" 5 seconds ago Up 4 seconds gallant_rosalind# 加 -a 查看所有容器$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd540e6eadeb7 centos \"/bin/bash\" 15 seconds ago Up 14 seconds nostalgic_wescoff86547f1d2801 centos \"-itd\" 29 seconds ago Created naughty_gagarin1204ee692e76 centos \"/bin/bash\" 49 seconds ago Exited (0) 48 seconds ago inspiring_meitner1a9c71025823 centos \"/bin/bash\" 5 minutes ago Exited (137) About a minute ago gallant_rosalind9f1d6ca406a2 hello-world \"/hello\" 3 days ago Exited (0) 3 days ago ecstatic_morse63d708278e8e hello-world \"/hello\" 3 days ago Exited (0) 3 days ago suspicious_rhodes 关闭容器 docker stop 容器的CONTAINER id $ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES1a9c71025823 centos \"/bin/bash\" 4 minutes ago Up 4 minutes gallant_rosalind$ docker stop 1a9c710258231a9c71025823 删除镜像和tag docker rmi REPOSITORY名字 docker rmi REPOSITORY名字:TAG名字 docker rmi 镜像名 此时就会连同 标签一起删除 $ docker pull ubuntucjw@MacBook-Pro: ~ $ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEubuntu latest 3556258649b2 2 weeks ago 64.2MBlatest test 9f38484d220f 4 months ago 202MBcentos latest 9f38484d220f 4 months ago 202MBdownload_by_cjw latest 9f38484d220f 4 months ago 202MBhello-world latest fce289e99eb9 7 months ago 1.84kBcjw@MacBook-Pro: ~ $ docker rmi ubuntuUntagged: ubuntu:latestUntagged: ubuntu@sha256:c303f19cfe9ee92badbbbd7567bc1ca47789f79303ddcef56f77687d4744cd7aDeleted: sha256:3556258649b2ef23a41812be17377d32f568ed9f45150a26466d2ea26d926c32Deleted: sha256:e68a9307017f6b268915b4d1b537ff663ff6967a37c85bd03a26f2e171ee9f6fDeleted: sha256:ed8308579f11f616d6b58e6e456f765f8e3837f69f81f7304f213c4e3aa96856Deleted: sha256:a757708db54bb9fe5cc7962e8890e008992209d6eca7d6556db03d2891159fefDeleted: sha256:543791078bdb84740cb5457abbea10d96dac3dea8c07d6dc173f734c20c144fecjw@MacBook-Pro: ~ $ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEcentos latest 9f38484d220f 4 months ago 202MBdownload_by_cjw latest 9f38484d220f 4 months ago 202MBlatest test 9f38484d220f 4 months ago 202MBhello-world latest fce289e99eb9 7 months ago 1.84kB# 删除tag$ docker rmi download_by_cjwUntagged: download_by_cjw:latest $ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEcentos latest 9f38484d220f 4 months ago 202MBlatest test 9f38484d220f 4 months ago 202MBhello-world latest fce289e99eb9 7 months ago 1.84kB$ docker images latest:testREPOSITORY TAG IMAGE ID CREATED SIZElatest test 9f38484d220f 4 months ago 202MBcjw@MacBook-Pro: ~ $ docker rmi latest:testUntagged: latest:test# 删除镜像名,则所有和镜像相关的标签也一起删除$ docker tag centos test$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEcentos latest 9f38484d220f 4 months ago 202MBtest latest 9f38484d220f 4 months ago 202MBhello-world latest fce289e99eb9 7 months ago 1.84kB$ docker rmi centosUntagged: centos:latestUntagged: centos@sha256:a799dd8a2ded4a83484bbae769d97655392b3f86533ceb7dd96bbac929809f3c$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEtest latest 9f38484d220f 4 months ago 202MBhello-world latest fce289e99eb9 7 months ago 1.84kB 通过容器创建镜像","categories":[{"name":"Linux","slug":"Linux","permalink":"http://cjwnb.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://cjwnb.top/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"http://cjwnb.top/tags/Docker/"}]},{"title":"Linux核心命令（一）","slug":"Linux核心命令（一）","date":"2019-08-01T08:47:33.728Z","updated":"2019-08-20T11:21:18.716Z","comments":true,"path":"2019/08/01/Linux核心命令（一）/","link":"","permalink":"http://cjwnb.top/2019/08/01/Linux核心命令（一）/","excerpt":"","text":"公私钥配置参考链接 https://blog.csdn.net/nahancy/article/details/79059135 客户端配置临时DNS路径，生成公钥， 服务器上注册客户端的公钥 客户端 MacBook-Pro:~ root# ssh-keygen -t rsa -b 4096MacBook-Pro:~ root# ssh-copy-id -i /root/.ssh/id_rsa.pub root@test1 # 拷贝公钥到服务器 服务器查看 [root@test1 ~]# cd .ssh/[root@test1 .ssh]# lsauthorized_keys[root@test1 .ssh]# cat authorized_keys ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCtsRb4fqCsBxDL5h7bZa0IS+lQwx7WN6rua74b6wgoTXop9+6v7GqdhCzDVxNsIQvmv2ao9+65q/XpdcTHcUe5RG7IEnVRPV3wixrwtmcRFSUBlzQ9SAehzjRtmg3ULsbSDq2jLPGbTHLH1Uu1I/dLbNBAbXULbz7sCzv+o9YCPutf9IpeVhOhwXcM5Olx17437kqL1WJksoHzqBQMTvgf3ualhQl2Ro8E7TtEohpVTU69LIgMos+6mriBXTXgUiA2wT+phILboX12tOmTxyj8FBA7/3Icp0vufHYuCl6DfbSZZ6ijO532Kw6VjSjebz+yE0tgufMnGQ/8v9AZhBzHajhKgWtjwPB/kUPzXBFAIkwG9MnbkG18tl+XmsYdZBa4qfo6hXpc41AkQKusxbmsmRVui2xVyKSEvE5WBlza8S8DyzoTE9tO53wGrbni61YHDJXsJ6Y+d6YHSimM/wWrcd5UYSE+S+lAcOQdAMJylRfus6YuByKsHIdalLnuoawI7G3vI83wl7wt9WJKJbi3kS3RNq5dEns5HXgKOfNveKH/00Iun6U9qY0bRKqIuefG+5kizwy6R/YYxAnBdhFteSgtlyfsnowttYHvV5spXq3dCQtaEx5EzNUSw/C4DjypLC0HRgLc6sohOXTeAiV9rx+7t5RVabQPQ9CTHyakNw== root@MacBook-Pro.local 常用快捷键移动光标类 快捷键 功能 ctrl+a 光标回到命令行首 ctrl+e 光标回到命令行尾 ctrl+f 光标向右移动一个字符（相当于方向键右键） ctrl+f 光标向右移动一个字符（相当于方向键右键） ctrl+b 光标向左移动一个字符（相当于方向左键） 修改类 快捷键 功能 ctrl+k 剪贴（删除）光标处到行尾的字符 ctrl+u 剪贴（删除）光标处到行首的字符 ctrl+w 剪贴（删除）光标前的一个单词，在Linux系统中每个单词间以空格间隔 ctrl+y 粘贴ctrl+u/ctrl+k/ctrl+w删除的文本 ctrl+h 删除光标所在处的前一个字符（相当于退格键） 操作终端类 快捷键 功能 ctrl+c 退出当前命令行 ctrl+d 退出当前终端 ctrl+r 搜索命令行使用过的命令记录 ctrl+g 从ctrl+r的模式中退出 ctrl+l/clear 清屏，在屏幕最上方开始一个新行 ctrl+z 暂停执行在终端运行在终端运行的任务 ctrl+s 锁定终端，无法输入（mac键盘可能无法识别） ctrl+q 解锁ctrl+s运行的锁定状态 （mac键盘可能无法识别） $ ctrl+c[root@cjw_test ~]# systemctl restart^C[root@cjw_test ~]# systemctl restart sshd^C$ ctrl+d[root@cjw_test ~]#[root@cjw_test ~]# 登出Connection to cjw_test closed.$ ctrl+r[root@cjw_test ~]# (reverse-i-search)`system': systemctl restart sshd$ ctrl+g(reverse-i-search)`system': systemctl restart sshd[root@cjw_test ~]# 其他类 快捷键 功能 !! 执行上一条命令 !$ 获取上一条命令的最后一个参数 esc+. 获取上一条命令的最后一个参数 esc+b 移动到当前单词的开头 esc+f 移动到当前单词的结尾 获取命令的帮助信息 man help Info [root@cjw_test ~]# man ls[root@cjw_test ~]# ls --help[root@cjw_test ~]# info ls 字符集相关[root@cjw_test ~]# cat /etc/locale.conf LANG=en_US.UTF-8[root@cjw_test ~]# echo $LANGzh_CN.UTF-8[root@cjw_test ~]# set |grep LANGLANG=zh_CN.UTF-8 关机和重启命令重启命令 命令 说明 reboot 立即重启 Shutdown -r now 立即重启 Shutodown -r +1 1分钟后重启 init 6 切换得到运行级别6，运行级别6表示重启 关机命令 命令 说明 shutdown -h now 立刻关机 Shutdown -h +1 1分钟后关机，1可以是别的数字或时间点，例如：11：00 halt 立即停止系统，需要人工关闭电源 init 0 切换到运行级别0 ， 0表示关机 poweroff 立即停止系统并关闭电源 注销命令 命令 说明 logout 注销退出当前终端 exit 注销退出当前终端， 快捷键ctrl+d Yum命令显示yum仓库 显示所有的仓库 root@test1: ~ # yum repolist all 显示可用的yum仓库 root@test1: ~ # yum repolist enabledroot@test1: ~ # yum repolist 显示不可用的仓库 root@test1: ~ # yum repolist diabled 显示应用程序包 显示所有的程序包 root@test1: ~ # yum list allroot@test1: ~ # yum list 显示指定的软件包名字 支持正则查询 root@test1: ~ # yum list tre*root@test1: ~ # yum list tre?root@test1: ~ # yum list iproute* 显示可安装的软件包 显示所有可安装的软件包 root@test1: ~ # yum list availableroot@test1: ~ # yum list available open*ssl*root@test1: ~ # yum list available gccroot@test1: ~ # yum list available php 显示更新或已安装的软件包 root@test1: ~ # yum list installedroot@test1: ~ # yum list updates 显示仓库中最近增加的程序包 root@test1: ~ # yum list recent 安装软件root@test1: ~ # yum -y install httpd 升级软件root@test1: ~ # yum update httpd 卸载软件root@test1: ~ # rpm -q httpdhttpd-2.4.6-89.el7.centos.1.x86_64root@test1: ~ # yum -y remove httpdroot@test1: ~ # rpm -q httpd未安装软件包 httpd root@test1: ~ # rpm -q treetree-1.6.0-10.el7.x86_64root@test1: ~ # yum -y erase treeroot@test1: ~ # rpm -q tree未安装软件包 tree 查看程序包信息root@test1: ~ # yum info tree 查看文件的来源root@test1: ~ # yum provides ls 清理本地缓存root@test1: ~ # yum clean all 清除插件缓存root@test1: ~ # yum clean plugins 构建缓存root@test1: ~ # yum makecache 如何使用yum缓存已经安装过了的软件包 缓存rpm包方式一 修改yum全局配置文件 root@test1: ~ # grep -B5 'cache*' /etc/yum.conf [main]cachedir=/var/cache/yum/$basearch/$releaseverkeepcache=1 # 启动缓存# 注意: $basearch 和 $releasever 是镜像中定义的变量, 在不同的镜像值不同, 这样开启缓存时候, 多个yum源, 开启缓存会分成不同的目录 缓存rpm包方式二 只下载不安装 root@test1: ~ # yum install httpd -y --downloadonly --downloaddir=/tmp 搜索root@test1: ~ # yum search httpd 查看指定包所依赖的capabilitiesroot@test1: ~ # yum deplist httpd 查看yum事务历史root@test1: ~ # yum history 包组相关的命令 安装软件( centos 7 ) root@test1: ~ # yum groupinstall \"System Management\" --setopt=group_package_types=mandatory,default,optional 显示包组 root@test1: ~ # yum grouplist 显示包的信息 root@test1: ~ # yum groupinfo \"System Management\" 移除包组 root@test1: ~ # yum groupremove \"System Management\" 更新包组 root@test1: ~ # yum groupupdate 压缩包管理打包压缩压缩包工具 .zip # zip压缩工具 .bz2 #bzip2压缩工具, 只能压缩文件,会删除源文件 .gz #gzip压缩工具, 只能压缩文件, 会删除源文件 tar.gz #gzip压缩, 使用tar打包 tar.bz2 #使用bizp2压缩, 使用tar打包 tar命令tar 参数 tar 参数 作用 z 通过gzip进行压缩 c 创建压缩包 v 显示创建压缩包和解压的过程 f 指定压缩包 ( f一定要放在几个参数的最后) t 查看压缩包内容 P 打包时保留文件及目录的绝对路径 tar 打包压缩命令root@test1: ~ # tar zcvf /tmp/etc.tar.gz /etc/ tar 查看压缩包root@test1: ~ # tar tf /tmp/etc.tar.gz 解压到当前目录(默认是当前目录)root@test1: ~ # tar xf /tmp/etc.tar.gz 解压到指定目录root@test1: ~ # tar xf /tmp/etc.tar.gz -C /mnt/ 选择性解压root@test1: ~ # tar xf /tmp/etc.tar.gz -C /mnt/ --exclude fstabroot@test1: ~ # tar xf /tmp/etc.tar.gz -C /mnt/ --exclude systemd --exclude fstab --exclude xdg tar命令打包压缩提示: Removing leading `/‘ from member names解决方案加上P参数, 以绝对路径写入压缩文件, 默认会去掉最后的/, 所有的根从这个目录开始, 也就是从相对路径写入 root@test1: ~ # tar zcPf /tmp/opt.tar.gz /opt zip 命令","categories":[{"name":"Linux","slug":"Linux","permalink":"http://cjwnb.top/categories/Linux/"}],"tags":[{"name":"基础命令","slug":"基础命令","permalink":"http://cjwnb.top/tags/基础命令/"}]},{"title":"Stark组件（一）自动生成url","slug":"Stark组件（一）自动生成url","date":"2019-07-31T14:33:54.743Z","updated":"2019-08-05T12:57:46.028Z","comments":true,"path":"2019/07/31/Stark组件（一）自动生成url/","link":"","permalink":"http://cjwnb.top/2019/07/31/Stark组件（一）自动生成url/","excerpt":"","text":"复习函数 函数如果有多个返回值，则会以元组的方式展示 def Test(): return 'aaa','bbb','ccc'print(Test()) Stark组件开发准备创建基础业务表settings.py INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'app01.apps.App01Config', 'app02.apps.App02Config', 'stark.apps.StarkConfig',]DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'stark', 'HOST':'127.0.0.1', 'USER':'root', 'PASSWORD':'123', 'POST':3306 &#125;&#125; /stark_2/stark/__init__.py import pymysqlpymysql.install_as_MySQLdb() app01/models.py from django.db import models# Create your models here.class Depart(models.Model): ''' 部门表 ''' title=models.CharField(verbose_name='部门名称',max_length=32)class Userinfo(models.Model): ''' 用户表 ''' name=models.CharField(verbose_name='姓名',max_length=32) age=models.CharField(verbose_name='年龄',max_length=32) email=models.CharField(verbose_name='邮箱',max_length=32) depart=models.ForeignKey(verbose_name='部门',to='Depart') /app02/models.py from django.db import models# Create your models here.class Host(models.Model): ''' 主机表 ''' host=models.CharField(verbose_name='主机名',max_length=32) ip=models.GenericIPAddressField(verbose_name='IP',protocol='both') class Role(models.Model): ''' 角色表 ''' title=models.CharField(verbose_name='角色名称',max_length=32) 需求 1 动态生成url 创建3个app(app01, app02, stark) app01 app02 stark 创建service/v1.py文件， 在v1.py定义类， 这个类最后的返回值是(urlconf_module, app_name, namespace), 最后这三个值都是作为元组返回给urls.py这个文件的，所以最后返回三个值就行，函数返回多个值，则以元组的方式返回 app_name, namespace作为类的初始化属性，在初始化属性中还需要定义一个空列表，主要就是为了存urlconf_module这个变量所需要的值 urlconf_module 这是个[url(r’^路由名字’, 视图函数)，url(r’^路由名字’, 视图函数)] 这样的一个列表，一级路由urls.py前面的路由名字会匹配这里的路由名字并执行相应的视图函数，会从列表的索引0开始匹配查找，先匹配到的执行，下面的不执行； 思路就是要把 urlconf_module 把这个数据搞出来，先拼路由匹配名字 urlconf_module是由url这个函数的返回对象，这里面有2个形参需要填写（路由名字和相应的视图函数） 如何拿到路由名字 路由名字公共的部分是 /应用名/表名/…. 所以问题就是要拿到应用名和表名，而应用名和表名要拿到都需要拿到类的名字，然后通过_meta方法拿到 应用名：type类对象._meta.app_label 表名: type类对象._meta.model_name app01/models.py Depart /app01/depart/list/ /app01/depart/add/ /app01/depart/edit/(\\d+)/ /app01/depart/del/(\\d+)/ UserInfo /app01/userinfo/list/ /app01/userinfo/add/ /app01/userinfo/edit/(\\d+)/ /app01/userinfo/del/(\\d+)/app02/models.py Host /app02/host/list/ /app02/host/add/ /app02/host/edit/(\\d+)/ /app02/host/del/(\\d+)/ 拿到视图函数 二级路由是要在一级路由分发前配置都已经准备好，所以在app中的app.py中配置路由分发前执行的python文件, 这里在app01和app02都新建一个stark.py文件 在stark.py中定义一个类，包括了增删改查4个方法，一个表对应一个类，最后通过类实例化对象并调用方法的形式生成视图函数，最后视图函数就是通过类实例化调用方法，所以是4个视图函数（增删改查4个方法），一个表有4个视图函数，四个表就是16个视图函数 所以最后以字典的方式将表对应的type类对象和视图函数给存入一个字典中，然后全部丢入初始化方法中的_registery这个列表中 urlconf_module 最后是一个列表的形式， 所以把存的数据处理下，放入一个新的列表，生成urlconf_module需要的格式 urlconf_module= [ url(r’路名名字(路径)’ , 视图函数) , url(r’路名名字(路径)’ , 视图函数)，。。。] 最后返回 urlconf_module, app_name, namespace给urls.py中的根路由进行路由分发 /stark/service/v1.py from django.conf.urls import urlclass StarkSite(object): def __init__(self): self._registry = [] self.app_name = 'stark' self.namespace = 'stark' def register(self, model_Class, handler_class): ''' :param model_Class: 是models中数据库表对应的类 :param handler_class: 处理请求的视图函数所在的类 :return: ''' self._registry.append(&#123;'model_class': model_Class, 'handler_class': handler_class(model_Class)&#125;) @property def get_urls(self): patterns = [] ''' 测试 patterns.append(url(r'^x1/', lambda request: HttpResponse('x1'))) patterns.append(url(r'^x2/', lambda request: HttpResponse('x2'))) ''' for item in self._registry: # 把每个数据库表对应的类拿到 model_class = item['model_class'] handler_class = item['handler_class'] # 把处理表的增删改查的对象拿到 ''' &lt;class 'app01.models.Depart'&gt; &lt;class 'app01.models.Userinfo'&gt; &lt;class 'app02.models.Host'&gt; ''' # 为每个model_class 生成4个url # 需要拿到每个对应数据库的表的类名称对应的应用名，类名小写，来拼成路由的名字 ''' / app01 / depart / list / / app01 / depart / add / / app01 / depart / edit / (\\d+) / / app01 / depart /del / (\\d+) / ''' # 拿到数据库的表的类名称对应的应用名 app_label = model_class._meta.app_label # 比如说 app01 # 拿到数据库的表的类名称对应的类名 model_name = model_class._meta.model_name # 比如说 depart patterns.append(url(r'^%s/%s/list' % (app_label, model_name), handler_class.Changelist)) patterns.append(url(r'^%s/%s/add' % (app_label, model_name), handler_class.add_view)) patterns.append(url(r'^%s/%s/edit/(\\d+)' % (app_label, model_name), handler_class.change_view)) patterns.append(url(r'^%s/%s/del/(\\d+)' % (app_label, model_name), handler_class.delete_view)) return patterns @property def urls(self): return self.get_urls, self.app_name, self.namespacesite = StarkSite()'''stark文件是在路由分发前执行第一步， 调用register方法就传一个参数(models里面的类名，就是数据库中的表)stark文件中做的操作： site.register(models.Depart)site.register(models.Userinfo)site.register(models.Host)self._registry=[&#123;'model_class': models.Depart&#125;,&#123;'model_class': models.Userinfo&#125;,&#123;'model_class': models.Host&#125;]启动django后，site.__dict__= app02 &#123;'_registry': [&#123;'model_class': &lt;class 'app01.models.Depart'&gt;&#125;, &#123;'model_class': &lt;class 'app01.models.Userinfo'&gt;&#125;, &#123;'model_class': &lt;class 'app02.models.Host'&gt;&#125;], 'app_name': 'stark', 'namespace': 'stark'&#125;第二步 再传一个参数给register,也是一个类，对应的是增删改查的方法,但是最后传给_registry键值，值是这个类实例化的对象，实例化再将前面的类名作为参数传递给这个对象启动django后，site.__dict__= &#123;'_registry': [&#123;'model_class': &lt;class 'app01.models.Depart'&gt;, 'handler_class': &lt;app01.stark.DepartHandler object at 0x1044d9c88&gt;&#125;, &#123;'model_class': &lt;class 'app01.models.Userinfo'&gt;, 'handler_class': &lt;app01.stark.UserInfoHandler object at 0x1044d9d30&gt;&#125;, &#123;'model_class': &lt;class 'app02.models.Host'&gt;, 'handler_class': &lt;app02.stark.HostHandler object at 0x1044e8160&gt;&#125;], 'app_name': 'stark', 'namespace': 'stark'&#125;''' /app01/stark.py from stark.service.v1 import sitefrom app01 import modelsfrom django.shortcuts import HttpResponseclass DepartHandler(object): def __init__(self, model_class): self.model_class = model_class def Changelist(self, request): ''' 列表页面 :return: ''' return HttpResponse('depart的列表页面') def add_view(self, request): ''' 添加页面 :return: ''' return HttpResponse('depart的添加页面') def change_view(self, request, pk): ''' 编辑页面 :param request: :param pk: :return: ''' return HttpResponse('depart的编辑页面') def delete_view(self, request, pk): ''' 删除页面 :param request: :return: ''' return HttpResponse('depart的删除页面')class UserInfoHandler(object): def __init__(self, model_class): self.model_class = model_class def Changelist(self, request): ''' 列表页面 :return: ''' return HttpResponse('Userinfo的列表页面') def add_view(self, request): ''' 添加页面 :return: ''' return HttpResponse('Userinfo的添加页面') def change_view(self, request, pk): ''' 编辑页面 :param request: :param pk: :return: ''' return HttpResponse('Userinfo的编辑页面') def delete_view(self, request, pk): ''' 删除页面 :param request: :return: ''' return HttpResponse('Userinfo的删除页面')site.register(models.Depart, DepartHandler)site.register(models.Userinfo, UserInfoHandler)print(site.__dict__) /app02/stark.py from stark.service.v1 import sitefrom app02 import modelsfrom django.shortcuts import HttpResponseclass HostHandler(object): def __init__(self, model_class): self.model_class = model_class def Changelist(self, request): ''' 列表页面 :return: ''' return HttpResponse('Host的列表页面') def add_view(self, request): ''' 添加页面 :return: ''' return HttpResponse('Host的添加页面') def change_view(self, request, pk): ''' 编辑页面 :param request: :param pk: :return: ''' return HttpResponse('host的编辑页面') def delete_view(self, request, pk): ''' 删除页面 :param request: :return: ''' return HttpResponse('host的删除页面')class RoleHandler(object): def __init__(self, model_class): self.model_class = model_class def Changelist(self, request): ''' 列表页面 :return: ''' return HttpResponse('Role的列表页面') def add_view(self, request): ''' 添加页面 :return: ''' return HttpResponse('Role的添加页面') def change_view(self, request, pk): ''' 编辑页面 :param request: :param pk: :return: ''' return HttpResponse('Role的编辑页面') def delete_view(self, request, pk): ''' 删除页面 :param request: :return: ''' return HttpResponse('Role的删除页面')site.register(models.Host, HostHandler)site.register(models.Role, RoleHandler) urls.py from django.conf.urls import url,includefrom django.contrib import adminfrom stark.service.v1 import siteprint('路由开始')urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^stark/', site.urls),] 需求2 提取公共视图，定义基类，使用继承简化代码 通过继承的思想将所有视图函数类封装成一个基类，然后每个公共函数类继承基类来减少代码量 /app01/models.py from django.db import models# Create your models here.class Depart(models.Model): ''' 部门表 ''' title = models.CharField(verbose_name='部门名称', max_length=32) def __str__(self): return self.titleclass UserInfo(models.Model): ''' 用户表 ''' name = models.CharField(verbose_name='姓名', max_length=32) age = models.IntegerField() email = models.EmailField(verbose_name='邮箱', max_length=32) depart = models.ForeignKey(to='Depart', verbose_name='部门') def __str__(self): return self.name /app02/models.py from django.db import models# Create your models here.class Host(models.Model): ''' 主机表 ''' host = models.CharField(verbose_name='主机名', max_length=32) ip = models.GenericIPAddressField(verbose_name='IP', protocol='both') def __str__(self): return self.hostclass Role(models.Model): ''' 角色表 ''' title = models.CharField(verbose_name='角色名称', max_length=32) def __str__(self): return self.titleclass Project(models.Model): ''' 项目表 ''' title = models.CharField(verbose_name='项目名称', max_length=32) def __str__(self): return self.title /stark/service/v1.py # (urlconf_module, app_name, namespace)from django.conf.urls import urlfrom django.shortcuts import HttpResponse, renderclass StarkSite(object): def __init__(self): self.app_name = 'stark' self.namespace = 'stark' self._registery = [] def register(self, model_class, handler_class): return self._registery.append(&#123;'model_class': model_class, 'handler_class': handler_class(model_class)&#125;) @property def get_url(self): patterns = [] ''' 测试： patterns.append(url(r'^x1/$', lambda request: HttpResponse('test'))) ''' for item in self._registery: model_class = item['model_class'] handler_class = item['handler_class'] # /app01/depart/list /app01/depart/add /app01/depart/edit/1 /app01/depart/del/1 # 拿到应用名 app_label = model_class._meta.app_label model_name = model_class._meta.model_name patterns.append(url(r'^%s/%s/list' % (app_label, model_name), handler_class.Chang_list)) patterns.append(url(r'^%s/%s/add' % (app_label, model_name), handler_class.add_view)) patterns.append(url(r'^%s/%s/edit/(\\d+)' % (app_label, model_name), handler_class.change_view)) patterns.append(url(r'^%s/%s/del/[0-9]+' % (app_label, model_name), handler_class.delete_view)) return patterns @property def urls(self): return self.get_url, self.app_name, self.namespaceclass StarkHandler(object): def __init__(self, model_class): self.model_class = model_class def Chang_list(self, request): ''' 查看页面 :param request: :return: ''' print(self.model_class) data_list = self.model_class.objects.all() return render(request, 'stark/changelist.html', &#123;'data_list': data_list&#125;) def add_view(self, request): ''' 添加页面 :param request: :return: ''' return HttpResponse('添加页面') def change_view(self, request, pk): ''' 编辑页面 :param request: :param pk: :return: ''' return HttpResponse('编辑页面') def delete_view(self, request, pk): ''' 删除页面 :param request: :param pk: :return: ''' return HttpResponse('删除页面')site = StarkSite() /app01/stark.py from stark.service.v1 import site,StarkHandlerfrom app01 import modelsfrom django.shortcuts import HttpResponseclass UserInfoHandler(StarkHandler): passclass DepartHandler(StarkHandler): passsite.register(models.UserInfo, UserInfoHandler)site.register(models.Depart, DepartHandler)models.UserInfo.objects.all() /app02/stark.py from stark.service.v1 import site,StarkHandlerfrom app02 import modelsfrom django.shortcuts import HttpResponseclass HostHandler(StarkHandler): passclass RoleHandler(StarkHandler): passclass ProjectHandler(StarkHandler): passsite.register(models.Host, HostHandler)site.register(models.Role, RoleHandler)site.register(models.Project,ProjectHandler) /urls.py from django.conf.urls import url,includefrom stark.service.v1 import siteurlpatterns = [ url(r'^stark/', site.urls),] /templates/stark/changelist.html 在stark应用目录下建立templates目录，必须是叫这个名字，不然后端无法找到下面的子目录或文件 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;列表页面&lt;/h1&gt;&lt;table border=\"1\"&gt; &lt;thead&gt; &#123;% for data in data_list %&#125; &lt;tr&gt; &lt;th&gt;&#123;&#123; data &#125;&#125;&lt;/th&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; GITHUB代码 https://github.com/Javawinner/strark_3","categories":[{"name":"项目","slug":"项目","permalink":"http://cjwnb.top/categories/项目/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"CRM","slug":"CRM","permalink":"http://cjwnb.top/tags/CRM/"}]},{"title":"CRM项目之rcbc","slug":"CRM项目之rcbc","date":"2019-07-31T13:47:31.372Z","updated":"2019-08-19T16:22:57.073Z","comments":true,"path":"2019/07/31/CRM项目之rcbc/","link":"","permalink":"http://cjwnb.top/2019/07/31/CRM项目之rcbc/","excerpt":"","text":"项目用到的基础知识orm操作models.py from django.db import modelsclass Permission(models.Model): \"\"\" 权限表 \"\"\" title = models.CharField(verbose_name='标题', max_length=32) url = models.CharField(verbose_name='含正则的URL', max_length=128) def __str__(self): return self.titleclass Role(models.Model): \"\"\" 角色 \"\"\" title = models.CharField(verbose_name='角色名称', max_length=32) permissions = models.ManyToManyField(verbose_name='拥有的所有权限', to='Permission', blank=True) def __str__(self): return self.titleclass UserInfo(models.Model): \"\"\" 用户表 \"\"\" name = models.CharField(verbose_name='用户名', max_length=32) password = models.CharField(verbose_name='密码', max_length=64) email = models.CharField(verbose_name='邮箱', max_length=32) roles = models.ManyToManyField(verbose_name='拥有的所有角色', to='Role', blank=True) def __str__(self): return self.name 获得luowen的所有权限 &gt;&gt;&gt; obj=models.UserInfo.objects.filter(name='luowen',password=123).first()&gt;&gt;&gt; obj.roles.filter(permissions__url__isnull=False).values('id','title','permissions__url') 获得zhouzesb的所有权限 &gt;&gt;&gt; obj=models.UserInfo.objects.filter(name='zhouzesb',password=123).first()&gt;&gt;&gt; obj.roles.all().values('permissions__url').distinct() 获得zhangfan的所有权限 &gt;&gt;&gt; obj=models.UserInfo.objects.filter(name='zhangfan',password=123).first()&gt;&gt;&gt; obj.roles.all().values('permissions__url') 正则表达式current_url = '/customer/edit/1/'error_url = '/customer/editssddssd/1/'error_url2 ='/customer/edit/1/sfsdsdsdsd'reg = '^/customer/edit/(\\d+)/$'import reresult_correct = re.match(reg, current_url)result_error = re.match(reg, error_url)result_error2=re.match(reg,error_url2)print(result_correct)print(result_error)print(result_error2) 准备创建app manage.py@CRM &gt; startapp rbacbash -cl \"/usr/local/bin/python3.6 /Applications/PyCharm.app/Contents/helpers/pycharm/django_manage.py startapp rbac /Users/cjw/Desktop/CRM\"Tracking file by folder pattern: migrationsFollowing files were affected /Users/cjw/Desktop/CRM/rbac/migrations/__init__.pyProcess finished with exit code 0manage.py@CRM &gt; startapp webbash -cl \"/usr/local/bin/python3.6 /Applications/PyCharm.app/Contents/helpers/pycharm/django_manage.py startapp web /Users/cjw/Desktop/CRM\"Tracking file by folder pattern: migrationsFollowing files were affected /Users/cjw/Desktop/CRM/web/migrations/__init__.pyProcess finished with exit code 0 创建表 在应用rbac中的models创建 from django.db import models# Create your models here.class Permission(models.Model): ''' 权限表 ''' title = models.CharField(verbose_name='标题', max_length=32) url = models.CharField(verbose_name='含正则的url', max_length=128) def __str__(self): return self.titleclass Role(models.Model): ''' 角色表 ''' title = models.CharField(verbose_name='角色名称', max_length=32) permissions = models.ManyToManyField(verbose_name='拥有的权限', to='Permission', blank=True) def __str__(self): return self.titleclass Userinfo(models.Model): ''' 用户表 ''' name=models.CharField(verbose_name='用户名',max_length=32) password=models.CharField(verbose_name='密码',max_length=64) email=models.CharField(verbose_name='邮箱',max_length=32) roles=models.ManyToManyField(verbose_name='拥有的所有角色',to='Role',blank=True) def __str__(self): return self.name 目标 CRM系统 权限 stark组件 CRM业务 步骤 创建 Django project， CRM 创建2个app(rbac 权限组件; web 销售管理系统) app rbac权限组件 将权限相关的表编写到这个app的models.pyzhong app web 将销售管理系统表写到这里 两个app的整合 ​ 销售管理系统中的URL ​ 5.1 基于admin进行权限信息的录入 &gt; url(r'^customer/list/$', customer.customer_list),&gt; url(r'^customer/add/$', customer.customer_add),&gt; url(r'^customer/edit/(?P&lt;cid&gt;\\d+)/$', customer.customer_edit),&gt; url(r'^customer/del/(?P&lt;cid&gt;\\d+)/$', customer.customer_del),&gt; url(r'^customer/import/$', customer.customer_import),&gt; url(r'^customer/tpl/$', customer.customer_tpl),&gt; &gt; url(r'^payment/list/$', payment.payment_list),&gt; url(r'^payment/add/$', payment.payment_add),&gt; url(r'^payment/edit/(?P&lt;pid&gt;\\d+)/$', payment.payment_edit),&gt; url(r'^payment/del/(?P&lt;pid&gt;\\d+)/$', payment.payment_del),&gt; ​ 5.2 基于admin进行权限和角色信息的分配 &gt; luowen &gt; 女教师&gt; 客户列表&gt; 秘书&gt; 无&gt; &gt; zhouzesb&gt; 教导主任&gt; 客户列表&gt; &gt; 女教师&gt; 客户列表&gt; 添加客户&gt; 账单列表&gt; &gt; zhangfan&gt; 校长&gt; 所有权限&gt; 源码下载 快速完成一个基本权限控制 为用户显示自己的菜单 快速完成一个基本权限控制 登录页面是否有权限访问 POST请求, 用户登录检验是否合法 获取当前用户相关的所有权限并放入session 再次向服务端发起请求,http://xxx.xxx.xxx, 后端编写中间件对用户当前访问的URL进行权限的判断(是否在session中) 权限控制的基本流程 用户登录1. 获取用户信息放入session2. 获取当前用户所有的权限并写入session urls.py from web.views import accounturlpatterns = [ url(r'login',account.login), ....] settings.py PERMISSION_SESSION_KEY='permission_list' /web/views/account.py from django.shortcuts import render, HttpResponse, redirectfrom rbac import modelsfrom luffy_permission import settingsdef login(request): ''' 用户登录 :param request: :return: ''' if request.method == 'GET': return render(request, 'login.html') # form表单验证 # 1, 获取提交的用户名密码 user, pwd = request.POST.get('user'), request.POST.get('pwd') # 2. 检查用户是否合法 obj = models.UserInfo.objects.filter(name=user, password=pwd).first() if not obj: return render(request, 'login.html', &#123;'msg': '用户名或密码错误'&#125;) # 3. 获取用户信息和权限信息写入session permissions = obj.roles.filter(permissions__url__isnull=False).values('permissions__url').distinct() permissions_list = list(permissions) print(permissions_list) request.session['userinfo'] = &#123;'id': obj.pk, 'name': obj.name&#125; request.session[settings.PERMISSION_SESSION_KEY] = permissions_list return redirect('/customer/list') 编写中间件做权限信息校验1. 获取当前请求URL2. 获取当前用户的所有权限3 .权限校验 settings.py VALID_URL=['^/login/$','^/admin/.*', ] web/middleware/rbac.py from django.utils.deprecation import MiddlewareMixinfrom django.conf import settingsfrom django.shortcuts import redirect, HttpResponseimport reclass RbacMiddleware(MiddlewareMixin): ''' 权限控制中间件 ''' def process_request(self, request): ''' 权限控制 :param request: :return: ''' # 1. 获取当前请求URL current_url = request.path_info # 1.5 白名单处理 for reg in settings.VALID_URL: if re.match(reg,current_url): return None # 2. 获取当前用户session中所有的权限 permission_list = request.session.get(settings.PERMISSION_SESSION_KEY) if not permission_list: return redirect('/login/') # 3. 进行权限校验 print('current_url', current_url) print('permission_list', permission_list) flag = False for item in permission_list: reg = '^%s$' % (item.get('permissions__url')) res = re.match(reg, current_url) if res: flag = True break if not flag: return HttpResponse('无权访问') 小坑 settings.py中的定义的变量必须全部大写, 否则无法调用 不要随便删除cookie, 否则在进入中间件会无法进入视图函数 为用户显示自己的菜单","categories":[{"name":"项目","slug":"项目","permalink":"http://cjwnb.top/categories/项目/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"CRM","slug":"CRM","permalink":"http://cjwnb.top/tags/CRM/"}]},{"title":"面向对象","slug":"面向对象","date":"2019-07-31T10:59:43.687Z","updated":"2019-08-02T10:02:44.325Z","comments":true,"path":"2019/07/31/面向对象/","link":"","permalink":"http://cjwnb.top/2019/07/31/面向对象/","excerpt":"","text":"@property的理解和使用将类的方法装饰城类的属性 class A: def __init__(self): self.__name = 'lxx' @property # 将方法装饰成类的属性 def xxx(self): return self.__name @xxx.setter # 给装饰成类的属性的方法赋值 def xxx(self, v): self.__name = v# 获取初始值a = A()print(a.xxx)# 设置值a.xxx = 'lyy'print(a.xxx)print(a.xxx)","categories":[{"name":"Python基础","slug":"Python基础","permalink":"http://cjwnb.top/categories/Python基础/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://cjwnb.top/tags/面向对象/"}]},{"title":"CRM项目之必备知识点","slug":"CRM项目之必备知识点","date":"2019-07-30T13:32:20.689Z","updated":"2019-08-06T04:06:17.410Z","comments":true,"path":"2019/07/30/CRM项目之必备知识点/","link":"","permalink":"http://cjwnb.top/2019/07/30/CRM项目之必备知识点/","excerpt":"","text":"什么是stark 是一个帮助开发者快速实现数据库表的增删改查 在django项目启动时，自定义执行某个py文件 django项目启动时， 且在读取路由之前执行某个py文件 在任意app的apps.py中的Config类中定义ready方法， 并调用autodiscover_modules from django.apps import AppConfigfrom django.utils.module_loading import autodiscover_modulesclass App01Config(AppConfig): name = 'app01' def ready(self): autodiscover_modules('xxxx') django在启动的时候，就回去已注册的所有app的目录下找 xxxx.py文件 并自动导入 如果执行2次， 是因为django内部自动重启所致 Python3 manager.py runserver 127.0.0.1:8888 –noreload 提示 如果xxxx.py执行的代码想 “某个神奇的地方”放入了一些值， 那么之后的路由加载时， 可以去“某个神奇的地方”读取到原来设置的值 测试 先创建2个app, 分别是app01, app02, 并在settings.py中注册 urls.py from django.conf.urls import urlfrom django.contrib import adminprint('路由加载')urlpatterns = [ url(r'^admin/', admin.site.urls),] app01/app.py from django.apps import AppConfigfrom django.utils.module_loading import autodiscover_modulesclass App01Config(AppConfig): name = 'app01' def ready(self): autodiscover_modules('alyysb') app01/lyysb.py print('app01目录下的lyysb.py') app02/app.py from django.apps import AppConfigfrom django.utils.module_loading import autodiscover_modulesclass App02Config(AppConfig): name = 'app02' def ready(self): autodiscover_modules('lxxsb') app02/lxxsb.py print('app02目录下的lyysb.py') 最后得到的结果是lxxsb.py, lyysb.py这两个文件在路由分发前加载 为什么lxxsb.py, lyysb.py执行了2次 在django中，会定时自动重启，在这个重启的过程中，有2个线程运行着，一个线程是运行Django程序的，另一个是检测Django程序中是否有代码更新，2个线程都在运行就导致了lxxsb.py, lyysb.py执行了2次 我就想要lxxsb.py, lyysb.py执行了1次 只能通过命令行脚本运行manager.py启动Django , 加上–noreload manage.py@Stark_develop &gt; runserver 127.0.0.1:8888 --noreload 如果想在pycharm中执行也想让lxxsb.py, lyysb.py执行1次 Run-Edit Configurations-Configuration-Additional Options, 填入 –noreload 单例模式 单: 一个 例: 实例，对象 通过利用Python模块导入的特性: 在Python中，如果已经导入过的文件被重新导入的时候，Python不会再重新解释一遍，而是选择从内存中直接将原来导入的值使用 utils.py class Adminsite(object): passsite=Adminsite()site.name='lyysb' commons.py import utilsprint(utils.site) # &lt;utils.Adminsite object at 0x10215e390&gt;print(utils.site.name) app.py import utilsprint(utils.site) # &lt;utils.Adminsite object at 0x10215e390&gt;import commons 提示 如果以后存在一个单例模式的对象，可以先在此对象中存一个值，然后在其他文件中导入该对象，通过对象再讲值取到 django路由分发的本质 include代码实例1from django.conf.urls import url,includeurlpatterns = [ url(r'^web/', include('app01.urls')),] /urls.py from django.conf.urls import url,includefrom django.contrib import adminprint('路由加载')urlpatterns = [ url(r'^web/', include('app01.urls')),] /app01/urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsprint('app01下的路由加载')urlpatterns = [ url(r'index/', views.index), url(r'home/', views.home),] app01/views.py from django.shortcuts import render,HttpResponse# Create your views here.def index(request): return HttpResponse('app01下的index')def home (request): return HttpResponse('app01下的home') 浏览器输入url查看效果 源码分析1/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/django/conf/urls/__init__.py def include(arg, namespace=None, app_name=None): # arg= 'app01.urls' if app_name and not namespace: raise ValueError('Must specify a namespace if specifying app_name.') if app_name: warnings.warn( 'The app_name argument to django.conf.urls.include() is deprecated. ' 'Set the app_name in the included URLconf instead.', RemovedInDjango20Warning, stacklevel=2 ) if isinstance(arg, tuple): # callable returning a namespace hint try: urlconf_module, app_name = arg except ValueError: 逻辑代码块 else: # No namespace hint - use manually provided namespace urlconf_module = arg # urlconf_module = arg= 'app01.urls' if isinstance(urlconf_module, six.string_types): # 根据字符串'app01.urls'导入 urls， 这是import_module做的事情 # 这个时候urlconf_module已经是个模块了(就是app01.urls这个文件) urlconf_module = import_module(urlconf_module) # 去urlconf_module这个模块里找urlpatterns这个属性(变量) patterns = getattr(urlconf_module, 'urlpatterns', urlconf_module) app_name = getattr(urlconf_module, 'app_name', app_name) return (urlconf_module, app_name, namespace) # 最后的返回值 本质上代码实例1 的主路由文件 /urls.py文件可以这么写 from django.conf.urls import url,includefrom django.contrib import adminfrom app01 import urlsprint('路由加载')urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^web/', (urls,,None,None)), # 返回值是 (urlconf_module, app_name, namespace)， app_name,namespace这两个形参默认是None，所以可以不穿 # 第一个参数是urls文件对象，通过此对象可以获取urls.patterns获取分发的路由] 源码分析2/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/django/urls/resolvers.py class RegexURLResolver(LocaleRegexProvider): 》》》》代码块》》》》》 @cached_property def urlconf_module(self): if isinstance(self.urlconf_name, six.string_types): return import_module(self.urlconf_name) else: return self.urlconf_name @cached_property def url_patterns(self): # urlconf_module might be a valid set of patterns, so we default to it patterns = getattr(self.urlconf_module, \"urlpatterns\", self.urlconf_module) # urlconf_module是个对象, 去 urlconf_module这个对象查找是不是有urlpatterns这个属性，有就使用这个属性赋值给patterns # 如果没有就将自身赋值给patterns try: iter(patterns) # 将pattern变成一个对象,前提是pattern必须是一个可迭代对象 except TypeError: msg = ( \"The included URLconf '&#123;name&#125;' does not appear to have any \" \"patterns in it. If you see valid patterns in the file then \" \"the issue is probably caused by a circular import.\" ) raise ImproperlyConfigured(msg.format(name=self.urlconf_name)) return patterns # 最后返回的就是一个对象 代码实例2urlpatterns = [ url(r'^web/', ([ url(r'index/', views.index), url(r'home/', views.home), ], app_name,app_namespace)), ]# 这个列表对象 [url(r'index/', views.index),url(r'home/', views.home), ] 会传给resolvers.py文件中url_patterns函数的patterns 属性通过反射getattr进行判断，最后返回patterns这个属性给/python3.6/importlib/__init__.py处理后，到这里，路由分发的流程结束，然后接着执行视图函数相应的功能 /urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsprint('路由加载')urlpatterns = [ url(r'^web/', ([ url(r'index/', views.index), url(r'home/', views.home), ], None,None) ),] app01/views.py from django.shortcuts import render,HttpResponse# Create your views here.def index(request): return HttpResponse('app01下的index')def home (request): return HttpResponse('app01下的home') 案例 实现输入 127.0.0.1/web/app01 跳转到app01的主页, 输入 127.0.0.1/web/app02 跳转到app02 的主页 /urls.py from django.conf.urls import urlfrom django.contrib import adminfrom test import siteprint('在路由读取前打印', site._registry)print('读取路由')urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^web/', site.urls)] app01/app.py from django.apps import AppConfigfrom django.utils.module_loading import autodiscover_modulesclass App01Config(AppConfig): name = 'app01' def ready(self): autodiscover_modules('alyysb') app02/app.py from django.apps import AppConfigfrom django.utils.module_loading import autodiscover_modulesclass App02Config(AppConfig):a name = 'app02' def ready(self): autodiscover_modules('lxxsb') lxxsb.py print('app02下的lxxsb.py')from test import sitesite._register.append('app02') lyysb.py print('app01下的lyysb.py')from test import sitesite._register.append('app01') test.py from django.conf.urls import urlfrom app01 import views as v1from app02 import views as v2class StarkSite(object): def __init__(self): self._register = [] @property def get_urls(self): urlpatterns = [] for app in self._register: if app == 'app01': urlpatterns.append(url(r'^%s/' % app, v1.index)) if app == 'app02': urlpatterns.append(url(r'^%s/' % app, v2.index)) return (urlpatterns, None, None)site = StarkSite() GIthub 仓库 https://github.com/Javawinner/stark_qianxi","categories":[{"name":"项目","slug":"项目","permalink":"http://cjwnb.top/categories/项目/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"CRM","slug":"CRM","permalink":"http://cjwnb.top/tags/CRM/"}]},{"title":"BBS项目","slug":"BBS项目","date":"2019-07-23T08:06:22.166Z","updated":"2019-07-30T09:05:11.910Z","comments":true,"path":"2019/07/23/BBS项目/","link":"","permalink":"http://cjwnb.top/2019/07/23/BBS项目/","excerpt":"","text":"项目开发的流程项目需求分析产品经理+架构师+开发经理/组长 去到客户的公司谈需求(博弈的过程) 项目架构设计架构师设计(数据库(主库:MySQL,从库:redis,mongodb),框架的选择,项目功能划分…) 报价:每个开发人员1500~3000 300万多部门联合审批 分组开发 开会 分任务小组人员开始搬砖 (忘生成好的框架内填写代码即可) 测试 开发人员自己测试（显而易见的bug） 测试人员(妹纸) 交付上线 自己的服务器 对方的服务器 项目需求分析表结构设计项目最最重要是表结构设计 如果一张表内的数据分成两块 一块是经常使用的 一块是不经常使用的,这个时候考虑数据优化的问题 表与表之间关系判断表中的一条数据能否对于另外一张表的多条数 一对一关系 一张表拆成了两张表 两张表中的数据是一一对应的 如果两张表存在一对一关系，比如表a,表b, 则如果其中一张表 表a 与另一张表 表c 存在一对多关系或者多对多关系，那么 表b和表c也是存在同样的关系的 用户表(利用auth_user表) phone avatar create_time blog 一对一个人站点 ps:DateField() auto_now:每次操作数据都会将当前时间更新 auto_now_add:自动将创建该数据的时间记录下来之后不再改变 个人站点表 站点名称 site_name 站点标题 site_title 站点样式 site_theme 文章表 文章标题 title 文章简介 desc 文章内容 content 发布时间 create_time blog 一对多个人站点 category 一对多分类表 tag 多对多标签表 # 数据库设计优化(******) up_num down_num comment_num # 当你操作点赞点踩表或者评论表的时候 只要保证上面三个同步更新 标签表 tag_name blog 一对多个人站点 分类表 category_name blog 一对多个人站点 点赞点踩表 user 一对多user表 article 一对多article表 is_up 0/1 文章评论表 user 一对多user表 article 一对多article表 content create_time parent 自关联评论表 (to='self') # self表示的就是当前表 项目需要用到的知识点img标签的src属性可以接受三种类型的值 图片的文件路径 图片的二进制数据 url地址 ORM中的关系字段Foreign外键类型在ORM中用来表示外键关联关系，一般把ForeignKey字段设置在 ‘一对多’中’多’的一方。 ForeignKey可以和其他表做关联关系同时也可以和自身做关联关系。 字段参数 to设置要关联的表 子关联一对多外键的一种 表中的每一行数据有一定的关联性，就需要用到子关联，比如说博客页面的评论下有多个子评论，这种就用到了子关联 class Comment(models.Model): ''' 评论表 根评论 &gt;&gt;&gt; 一条评论 子评论 &gt;&gt;&gt; 一条评论下的多条评论 所以子评论和多评论是一对多的关系 ''' nid = models.AutoField(primary_key=True) article = models.ForeignKey(to='Article', to_field='nid', verbose_name='评论文章') # 一对多 user = models.ForeignKey(to='User', to_field='nid', verbose_name='评论者') # 一对多 content = models.CharField(verbose_name='评论内容', max_length=255) create_time = models.DateTimeField(verbose_name='创建时间', auto_now_add=True) parent_comment = models.ForeignKey(to='self', null=True) def __str__(self): return self.content to_field设置要关联的表的字段 on_delete当删除关联表中的数据时，当前表与其关联的行的行为。 models.CASCADE删除关联数据，与之关联也删除 db_constraint是否在数据库中创建外键约束，默认为True。 其余字段参数 models.DO_NOTHING删除关联数据，引发错误IntegrityErrormodels.PROTECT删除关联数据，引发错误ProtectedErrormodels.SET_NULL删除关联数据，与之关联的值设置为null（前提FK字段需要设置为可空）models.SET_DEFAULT删除关联数据，与之关联的值设置为默认值（前提FK字段需要设置默认值）models.SET删除关联数据，a. 与之关联的值设置为指定值，设置：models.SET(值)b. 与之关联的值设置为可执行对象的返回值，设置：models.SET(可执行对象) def func(): return 10class MyModel(models.Model): user = models.ForeignKey( to=\"User\", to_field=\"id\"， on_delete=models.SET(func) ) OneToOneField一对一字段。 通常一对一字段用来扩展已有字段。(通俗的说就是一个人的所有信息不是放在一张表里面的，简单的信息一张表，隐私的信息另一张表，之间通过一对一外键关联) 字段参数 to设置要关联的表。 to_field设置要关联的字段。 on_delete当删除关联表中的数据时，当前表与其关联的行的行为。(参考上面的例子) ManytoManyField“关联管理器”是在一对多或者多对多的关联上下文中使用的管理器。 它存在于下面两种情况： 外键关系的反向查询 多对多关联关系 简单来说就是在多对多表关系并且这一张多对多的关系表是有Django自动帮你建的情况下，下面的方法才可使用。 through放存储表关系的那张表的名字 through_fieldsthrough_fields=（’参数1‘，’参数2‘） 参数1： 放存表多对多的表关系的那张表要查到当前的这张表需要通过哪个字段可以查得到 参数2： 放存表多对多的表关系的那张表的另一个关联字段的名字 class Tag(models.Model): ''' 标签表 ''' nid = models.AutoField(primary_key=True) title = models.CharField(verbose_name='标签名称', max_length=32) blog = models.ForeignKey(verbose_name='所属博客', to='Blog', to_field='nid') def __str__(self): return self.titleclass Article(models.Model): nid = models.AutoField(primary_key=True) title = models.CharField(max_length=50, verbose_name='文章标题') desc = models.CharField(max_length=255, verbose_name='文章描述') create_time = models.DateTimeField(verbose_name='创建时间', auto_now_add=True) content = models.TextField() tag = models.ManyToManyField(to='Tag', through='Article2tag', through_fields=('article', 'tag')) def __str__(self): return self.titleclass Article2tag(models.Model): nid = models.AutoField(primary_key=True) article = models.ForeignKey(verbose_name='文章', to='Article', to_field='nid') tag = models.ForeignKey(verbose_name='标签', to='Tag', to_field='nid') 生成大小写字母&gt;&gt;&gt; chr(65)'A&gt;&gt;&gt; chr(90)'Z'&gt;&gt;&gt; chr(97)'a'&gt;&gt;&gt; chr(122)'z' 动态生成图片from django.shortcuts import HttpResponsedef get_valid_img(request): def get_random_color(): import random return (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)) from PIL import Image, ImageDraw, ImageFont from io import BytesIO img = Image.new('RGB', (270, 35), color=get_random_color()) # 通过磁盘处理 with open(\"validCode.png\", 'wb') as f: img.save(f,'png') with open(\"validCode.png\", 'rb') as f: data = f.read() # 通过内存处理 from io import BytesIO f = BytesIO() img.save(f, 'png') data = f.getvalue() return HttpResponse(data) 图片中插入文字from PIL import ImageDraw,Image,ImageFontimage=Image.open('background.jpg')drawobj=ImageDraw.Draw(image)text='Hello World'font=ImageFont.truetype('static/font/大梁体繁简精全2016版(9月版).ttf',40)drawobj.text([300,500],text,font=font)image.show() 自定义标签app01/templatetags/mytags from django import templateregister=template.Library()@register.simple_tag()def multify(x,y): return x*y 使用 &#123;% load mytags %&#125; &#123;% multify 23 9 %&#125; 自定义inclusion tag本质上就是自定义标签，只是功能通过一个html文件进行传递 app01/templatetags/mytags @register.inclusion_tag('classification.html')def get_classification_style(username): blog = models.Blog.objects.filter(site_name=username).first() article_list = models.Article.objects.filter(blog=blog) category_list = models.Category.objects.filter(blog=blog).annotate(c=Count('article')).values_list('title', 'c', 'nid') tag_list = models.Tag.objects.filter(blog=blog).annotate(c=Count('article')).values_list('title', 'c', 'nid') month_list = models.Article.objects.filter(blog=blog).annotate(month=TruncMonth('create_time')).values( 'month').annotate(c=Count('pk')).values_list('month', 'c') return &#123;'blog': blog, 'article_list': article_list, 'category_list': category_list, 'tag_list': tag_list,'month_list':month_list&#125; classification.html &lt;div&gt; &lt;div class=\"panel panel-success\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3 class=\"panel-title\"&gt;文章分类&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &#123;% for category in category_list %&#125; &lt;p&gt;&lt;a href=\"/&#123;&#123; username &#125;&#125;/category/&#123;&#123; category.2 &#125;&#125;\"&gt;&#123;&#123; category.0 &#125;&#125;&lt;/a&gt;&amp;nbsp;(&#123;&#123; category.1 &#125;&#125;)&lt;/p&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"panel panel-danger\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3 class=\"panel-title\"&gt;文章标签&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &#123;% for tag in tag_list %&#125; &lt;p&gt;&lt;a href=\"/&#123;&#123; username &#125;&#125;/tag/&#123;&#123; tag.2 &#125;&#125;\"&gt;&#123;&#123; tag.0 &#125;&#125;&lt;/a&gt;&amp;nbsp;(&#123;&#123; tag.1 &#125;&#125;)&lt;/p&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"panel panel-info\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3 class=\"panel-title\"&gt;日期归档 &lt;/h3&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &#123;% for month in month_list %&#125; &lt;p&gt; &lt;a href=\"/&#123;&#123; username &#125;&#125;/archive/&#123;&#123; month.0|date:'Y/m' &#125;&#125;\"&gt;&#123;&#123; month.0 |date:'Y年m月' &#125;&#125;&lt;/a&gt;&amp;nbsp;(&#123;&#123; month.1 &#125;&#125;) &lt;/p&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 使用 &#123;% load mytags %&#125;&#123;% get_classification_style username %&#125; DOM操作var name='lyysb'var age=38console.log(`Her name is $&#123;name&#125;, and its age is $&#123;age&#125;`) 建表settings.py Mysql需要设置 NO_ENGINE_SUBSTITUTION 模式，否则有时候进行反向查询会报错 mysql&gt; show variables like \"sql_mode\" -&gt; ;+---------------+------------------------+| Variable_name | Value |+---------------+------------------------+| sql_mode | NO_ENGINE_SUBSTITUTION |+---------------+------------------------+1 row in set (0.00 sec)mysql&gt; set global sql_mode=NO_ENGINE_SUBSTITUTION;Query OK, 0 rows affected (0.01 sec) 功能模块表设计settings.py DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'bbs4', 'USER': 'root', 'PASSWORD': '123', 'HOST': '127.0.0.1', 'PORT': 3306, 'CHARSET': 'utf8' &#125;&#125;AUTH_USER_MODEL='blog.Userinfo' # 一定要加这句话，因为Userinfo是继承auth组件的那个表，所以需要配置，否则在床架表的时候会出现如下报错（SystemCheckError: System check identified some issues:ERRORS:auth.User.groups: (fields.E304) Reverse accessor for 'User.groups' clashes with reverse accessor for 'Userinfo.groups'. HINT: Add or change a related_name argument to the definition for 'User.groups' or 'Userinfo.groups'.auth.User.user_permissions: (fields.E304) Reverse accessor for 'User.user_permissions' clashes with reverse accessor for 'Userinfo.user_permissions'. HINT: Add or change a related_name argument to the definition for 'User.user_permissions' or 'Userinfo.user_permissions'.blog.Userinfo.groups: (fields.E304) Reverse accessor for 'Userinfo.groups' clashes with reverse accessor for 'User.groups'. HINT: Add or change a related_name argument to the definition for 'Userinfo.groups' or 'User.groups'.blog.Userinfo.user_permissions: (fields.E304) Reverse accessor for 'Userinfo.user_permissions' clashes with reverse accessor for 'User.user_permissions'. HINT: Add or change a related_name argument to the definition for 'Userinfo.user_permissions' or 'User.user_permissions'.） __init__.py import pymysqlpymysql.install_as_MySQLdb() 快捷键alt+R执行manager.py脚本 manage.py@bbs3 &gt; makemigrationsmanage.py@bbs3 &gt; migrate 注册功能静态文件配置 settings.py STATIC_URL = '/static/'STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static')] 前端获取用户输入，前端和后端需要对用户输入的信息进行校验（form） form组件校验数据 from django import formsfrom django.forms import widgetsfrom blog import modelsfrom django.core.exceptions import ValidationErrorclass MyForm(forms.Form): username = forms.CharField(max_length=8, min_length=3, label='用户名', error_messages=&#123; 'max_length': '用户名最长8位', 'min_length': '用户名最短3位', 'required': '用户名不能为空' &#125;, widget=widgets.TextInput( attrs=&#123;'class': 'form-control'&#125;)) password = forms.CharField(max_length=8, min_length=3, label='密码', error_messages=&#123; 'max_length': '密码最长8位', 'min_length': '密码最短3位', 'required': '密码不能为空' &#125;, widget=widgets.TextInput( attrs=&#123;'class': 'form-control'&#125;)) confirm_password = forms.CharField(max_length=8, min_length=3, label='确认密码', error_messages=&#123; 'max_length': '确认密码最长8位', 'min_length': '确认密码最短3位', 'required': '确认密码不能为空' &#125;, widget=widgets.TextInput( attrs=&#123;'class': 'form-control'&#125;)) email = forms.EmailField(label='邮箱', error_messages=&#123; 'invalid': '邮箱格式错误', 'required': '邮箱不能为空' &#125;, widget=widgets.EmailInput( attrs=&#123;'class': 'form-control'&#125;)) # 局部钩子 判断当前用户名是否存在 def clean_username(self): username = self.cleaned_data['username'] user_obj = models.Userinfo.objects.filter(username=username).first() if user_obj: raise ValidationError('用户名已存在') else: return username # 全局钩子，校验两次密码是否一致 def clean(self): password = self.cleaned_data.get('password') confirm_password = self.cleaned_data.get('confirm_password') if not password == confirm_password: self.add_error('confirm_password', '两次密码输入不一致') else: return self.cleaned_data 写注册页面 前端： 页面布局，设计点击事件（click）和修改事件(change) 后端： 对校验的数据进行处理，操作数据库 后端业务逻辑 from django.shortcuts import render,HttpResponse,redirectfrom django.views import Viewfrom django.conf.urls import urlfrom blog import viewsurlpatterns = [# 注册功能 url(r'^register/', views.Register.as_view()), url(r'^login/', views.Login.as_view()),] from django.shortcuts import render, HttpResponse, redirect# Create your views here.from django.views import Viewfrom blog import modelsfrom blog import myformsfrom django.http import JsonResponseclass Register(View): form = myforms.MyForm() def get(self, request): return render(request, 'register.html', &#123;'form': self.form&#125;) def post(self, request): # 前端提交后进行校验，提交就是post请求 # &#123;'csrfmiddlewaretoken': ['FELJgdjWNKdUXizMQ2GAqF6QMtZxYHvquEXJodcjrL8GRaVBknZ8VINjud6bX52X'], # 'username': ['lxx'], # 'password': ['123'], # 'confirm_password': ['123'], # 'email': ['123@qq.com']&#125; response = &#123;'status': False, 'msg': None&#125; form = myforms.MyForm(request.POST) print(form.is_valid()) print(form.cleaned_data) if form.is_valid(): # 校验通过，数据库查数据 response['status'] = True response['msg'] = '注册成功' # &#123;'username': 'lxx', 'password': '123', 'confirm_password': '123', 'email': '123@qq.com'&#125; clean_data = form.cleaned_data clean_data.pop('confirm_password') # &#123;'username': 'lxx', 'password': '123', 'email': '123@qq.com'&#125; if request.FILES: # &lt; MultiValueDict: &#123;'file_obj': [ &lt; InMemoryUploadedFile: timg.jpeg(image / jpeg) &gt;]&#125; &gt; clean_data['avatar'] = request.FILES.get('file_obj') # 前面数据准备成功了，写入数据库 # &#123;'username': 'lxx', 'password': '123', 'email': '123@qq.com', 'avatar': &lt; InMemoryUploadedFile: timg.jpeg(image / jpeg) &gt;&#125; models.Userinfo.objects.create_user(**clean_data) else: # 校验不通过，返回错误信息 response['msg'] = form.errors return JsonResponse(response, json_dumps_params=&#123;'ensure_ascii': False&#125;) 前端业务逻辑 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;注册&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"/static/blog/bs/css/bootstrap.css\"&gt; &lt;script src=\"/static/blog/bs/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 class=\"text-primary text-center panel-body\"&gt;注册页面&lt;/h2&gt;&lt;div class=\"container\" style=\"margin-top: 26px\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6 col-md-offset-3\"&gt; &lt;form id=\"form\"&gt; &#123;% csrf_token %&#125; &#123;% for foo in form %&#125; &lt;div class=\"form form-group\"&gt; &lt;label for=\"&#123;&#123; foo.auto_id &#125;&#125;\"&gt;&#123;&#123; foo.label &#125;&#125;&lt;/label&gt; &#123;&#123; foo &#125;&#125; &lt;span class=\"pull-right error\"&gt;&lt;/span&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;div class=\"form-group\"&gt; &lt;label for=\"avatar\"&gt;头像 &lt;img src=\"/static/blog/images/default.jpg\" id=\"avatar_img\" alt=\"\" width=\"50px\"&gt; &lt;/label&gt; &lt;input type=\"file\" id=\"avatar\" class=\"hidden\"&gt; &lt;/div&gt; &lt;/form&gt; &lt;input type=\"button\" class=\"btn btn-primary btn-group-justified reg_btn\" value=\"注册\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; $('.reg_btn').click(function () &#123; //console.log($('#form').serializeArray().val()); var formdata = new FormData(); var request_data = $('#form').serializeArray(); $.each(request_data, function (index, data) &#123; formdata.append(data.name, data.value); &#125;); //$.each(request_data, function (index, data) &#123; // formdata.append(data.name, data.value) //&#125;); // 加入图片对象 formdata.append('file_obj', $('#avatar')[0].files[0]); //File &#123;name: \"1P512151355-2.jpg\", // lastModified: 1564212672633, // lastModifiedDate: Sat Jul 27 2019 15:31:12 GMT+0800 (中国标准时间), // webkitRelativePath: \"\", size: 365545, …&#125; $.ajax(&#123; url: '', type: 'post', data: formdata, contentType: false, processData: false, success: function (data) &#123; console.log(data.status); if (data.status) &#123; //跳转到登录界面 location.href = '/login/'; &#125; else &#123; //如果注册不能够，在按钮旁边显示报错信息 // $('.error').html(data.msg); $.each(data.msg, function (index, error_list) &#123; // 根据form表单自动生成id的规律拼出id，并在其下一个标签添加错误信息 tag_id = '#id_' + index; $(tag_id).next().html(error_list[0]).css(&#123;'color':'red'&#125;).parent().addClass('has-error') &#125;); $('input').focus(function () &#123; $(this).next().text('').parent().removeClass('has-error') &#125;) &#125; &#125; &#125;) &#125;)&lt;/script&gt;&lt;script&gt; // 使得图片能够在前台显示缩略图 //获取文件对象的路径 $('#avatar').change(function () &#123; //获取用户选中的文件对象 var file_obj=$(this)[0].files[0]; //使用文件阅读器读取文件 var reader=new FileReader(); // 定义阅读器 reader.readAsDataURL(file_obj) //读取文件对象的路径 //reader.result 最后的结果保存在result方法中 //修改img的src属性 // reader.onload表示当执行完reader的代码再执行onload方法中定义的代码 reader.onload=function () &#123; $('#avatar_img').attr(\"src\",reader.result) &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 登录功能后端业务逻辑 from django.conf.urls import urlfrom django.contrib import adminfrom blog import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), # 注册功能 url(r'^register/', views.Register.as_view()), # 登录功能 url(r'^login/', views.Login.as_view()), url(r'^get_valid_img/', views.Login.get_valid_img), url(r'^logout/', views.Login.logout), url(r'^set_password/', views.Login.set_password), # 主页 url(r'^index/', views.index)] from django.contrib import authdef index(request): return render(request, 'index.html')class Login(View): def get(self, request): return render(request, 'login.html') def post(self, request): response = &#123;'status': False, 'msg': None&#125; print(request.POST) user = request.POST.get('user') pwd = request.POST.get('pwd') valid_code = request.POST.get('valid_code') if not valid_code.upper() == request.session['valid_code'].upper(): response['msg'] = '验证码错误' return JsonResponse(response, json_dumps_params=&#123;'ensure_ascii': False&#125;) # 参数传入用户名和密码，他会去系统表中进行查找，有相同的返回对象，没有就返回None usr = auth.authenticate(request, username=user, password=pwd) if not usr: response['msg'] = '用户不存在' return JsonResponse(response, json_dumps_params=&#123;'ensure_ascii': False&#125;) else: auth.login(request, usr) # 调用login系统相当于做了以下三部 # 1.设置session和cookie # 2.生成request.user对象，这个对象是可以在函数视图中使用的(详情见auth中间件) # 3.request.user 相当于request.session response['status'] = True response['msg'] = '登录成功' return JsonResponse(response, json_dumps_params=&#123;'ensure_ascii': False&#125;) @staticmethod def get_valid_img(request): def get_random_color(): import random return (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)) from PIL import Image, ImageDraw, ImageFont from io import BytesIO import random img = Image.new('RGB', (270, 35), color=get_random_color()) draw = ImageDraw.Draw(img) kumo_font = ImageFont.truetype('static/font/大梁体繁简精全2016版(9月版).ttf', size=28) random_num = str(random.randint(0, 9)) random_low_alpha = chr(random.randint(65, 90)) random_upper_alpha = chr(random.randint(97, 122)) valid_code_str = \"\" for i in range(6): res = random.choice([random_num, random_low_alpha, random_upper_alpha]) draw.text([i * 40 + 20, 5], res, get_random_color(), font=kumo_font) # 保存验证码字符串 valid_code_str += res print(111111, valid_code_str) request.session['valid_code'] = valid_code_str print(request.session) # img.show() # 设置噪点燥线 width = 270 height = 35 for i in range(10): x1 = random.randint(0, width) x2 = random.randint(0, width) y1 = random.randint(0, height) y2 = random.randint(0, height) draw.line((x1, y1, x2, y2), fill=get_random_color()) for i in range(200): draw.point([random.randint(0, width), random.randint(0, height)], fill=get_random_color()) x = random.randint(0, width) y = random.randint(0, height) draw.arc((x, y, x + 1, y + 1), 0, 90, fill=get_random_color()) f = BytesIO() img.save(f, 'png') data = f.getvalue() return HttpResponse(data) @staticmethod def logout(request): auth.logout(request) return redirect('/login/') @staticmethod def set_password(request): if request.method == 'POST': old_password = request.POST.get('old_password') new_password = request.POST.get('new_password') if request.user.check_password(old_password): request.user.set_password(new_password) request.user.save() return redirect('/login/') return render(request, 'set_password.html') 前端业务逻辑 login.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"/static/blog/bs/css/bootstrap.css\"&gt; &lt;script src=\"/static/blog/bs/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body style=\"background-color: #cccccc\"&gt;&lt;h3 class=\"text-info text-center\"&gt;登录页面&lt;/h3&gt;&lt;div class=\"container\" style=\"margin-top: 26px\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6 col-md-offset-3\"&gt; &lt;form&gt; &#123;% csrf_token %&#125; &lt;div class=\"form-group\"&gt; &lt;label for=\"user\"&gt;用户名&lt;/label&gt; &lt;input type=\"text\" id=\"user\" class=\"form-control\" placeholder=\"用户名\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"pwd\"&gt;密码&lt;/label&gt; &lt;input type=\"password\" id=\"pwd\" class=\"form-control\" placeholder=\"密码\"&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=\"\"&gt;验证码&lt;/label&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt; &lt;input type=\"text\" id=\"valid_code\" class=\"form-control\"&gt; &lt;/div&gt; &lt;div class=\"col-md-6\"&gt; &lt;img width=\"260\" height=\"35\" src=\"/get_valid_img/\" id=\"valid_code_img\" alt=\"\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;input type=\"button\" class=\"btn btn-primary login_btn btn-group-justified\" style=\"\" value=\"登录\"&gt; &lt;span class=\"error h4 pull-left\" style=\"margin-top: 10px\"&gt;&lt;/span&gt; &lt;a href=\"/register/\" class=\"pull-right h4\" style=\"color: rebeccapurple\"&gt;注册&lt;/a&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; $('#valid_code_img').click(function () &#123; $(this)[0].src += '?' &#125;); $('.login_btn').click(function () &#123; $.ajax(&#123; url: '', type: 'post', data: &#123; user: $('#user').val(), pwd: $('#pwd').val(), valid_code: $('#valid_code').val(), csrfmiddlewaretoken: $(\"[name='csrfmiddlewaretoken']\").val() &#125;, success: function (data) &#123; if (data.status) &#123; location.href = '/index/' &#125; else &#123; $('.login_btn').next().html(data.msg).css(&#123;\"color\": \"red\"&#125;); &#125; setTimeout(function () &#123; $('.error').html('') &#125;, 1000) &#125; &#125;) &#125;)&lt;/script&gt;&lt;/html&gt; set_password.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"/static/app01/bs/css/bootstrap.css\"&gt; &lt;script src=\"/static/app01/bs/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body style=\"background-color: #cccccc\"&gt;&lt;h3 class=\"has-error\" style=\"text-align: center\"&gt;修改密码&lt;/h3&gt;&lt;div class=\"container\" style=\"padding-top: 50px\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6 col-md-offset-3\"&gt; &lt;form action=\"\" method=\"post\"&gt; &#123;% csrf_token %&#125; &lt;div class=\"form-group\"&gt; &lt;label for=\"user\"&gt;用户名&lt;/label&gt; &lt;input type=\"text\" id=\"user\" class=\"form-control\" value=\"&#123;&#123; request.user.username &#125;&#125;\" disabled&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"pwd\"&gt;旧密码&lt;/label&gt; &lt;input type=\"password\" id=\"old_password\" name=\"old_password\" class=\"form-control\" placeholder=\"旧密码\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"pwd\"&gt;新密码&lt;/label&gt; &lt;input type=\"password\" id=\"new_password\" name=\"new_password\" class=\"form-control\" placeholder=\"新密码\"&gt; &lt;/div&gt; &lt;input type=\"submit\" class=\"btn btn-primary login_btn btn-group-justified\" value=\"确认修改\" style=\"margin-top: 10px\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; $('#old_password').focus(function () &#123; $(this).removeAttr('placeholder') &#125;); $('#new_password').focus(function () &#123; $(this).removeAttr('placeholder') &#125;);&lt;/script&gt;&lt;/html&gt; 后台管理创建超级用户 manage.py@bbs3 &gt; createsuperuserbash -cl \"/usr/local/bin/python3.6 /Applications/PyCharm.app/Contents/helpers/pycharm/django_manage.py createsuperuser /Users/cjw/Desktop/bbs3\"Tracking file by folder pattern: migrationsUsername: cjwnbEmail address: Warning: Password input may be echoed.Password: cjw123456Warning: Password input may be echoed.Password (again): cjw123456Superuser created successfully.Process finished with exit code 0 注册表到admin后台 admin.py from blog import modelsadmin.site.register(models.Userinfo)admin.site.register(models.Blog)admin.site.register(models.Category)admin.site.register(models.Comment)admin.site.register(models.Article)admin.site.register(models.Tag)admin.site.register(models.Article2tag)admin.site.register(models.ArticleUpDown) media配置settings.py MEDIA_ROOT = os.path.join(BASE_DIR, 'media') urls.py from django.views.static import servefrom BBS import settingsurl(r'^media/(?P&lt;path&gt;.*)', serve, &#123;'document_root': settings.MEDIA_ROOT&#125;), 然后注册个用户就会自动生成media目录，最后把所有需要用到的图片都放进media/avata下 个人站点功能urls.py \"\"\"bbs3 URL ConfigurationThe `urlpatterns` list routes URLs to views. For more information please see: https://docs.djangoproject.com/en/1.11/topics/http/urls/Examples:Function views 1. Add an import: from my_app import views 2. Add a URL to urlpatterns: url(r'^$', views.home, name='home')Class-based views 1. Add an import: from other_app.views import Home 2. Add a URL to urlpatterns: url(r'^$', Home.as_view(), name='home')Including another URLconf 1. Import the include() function: from django.conf.urls import url, include 2. Add a URL to urlpatterns: url(r'^blog/', include('blog.urls'))\"\"\"from django.conf.urls import urlfrom django.contrib import adminfrom blog import viewsfrom bbs3 import settingsfrom django.views.static import serveurlpatterns = [ url(r'^admin/', admin.site.urls), # 注册功能 url(r'^register/', views.Register.as_view()), # 登录功能 url(r'^login/', views.Login.as_view()), url(r'^get_valid_img/', views.Login.get_valid_img), url(r'^logout/', views.Login.logout), url(r'^set_password/', views.Login.set_password), # 主页 url(r'^index/', views.index), # 配置media路由 url(r'^media/(?P&lt;path&gt;.*)', serve, &#123;'document_root': settings.MEDIA_ROOT&#125;), # 侧边栏筛选功能 url(r'^(?P&lt;username&gt;\\w+)/(?P&lt;conditions&gt;tag|category|archive)/(?P&lt;param&gt;.*)', views.site), # 配置文章详情页 url(r'^(?P&lt;username&gt;\\w+)/articles/(?P&lt;article_id&gt;\\d+)$', views.article_detail), # 点赞点踩 url(r'^digg/', views.digg), # 父评论页面 url(r'^comment', views.comment), # 配置404页面 url(r'^(?P&lt;username&gt;\\w+)/$', views.site),] views.py from django.db.models.functions import TruncMonthfrom django.shortcuts import render, HttpResponse, redirect# Create your views here.from django.views import Viewfrom blog import modelsfrom blog import myformsfrom django.http import JsonResponsefrom django.db.models import Countdef index(request): # 查出所有的文章 article_list = models.Article.objects.all() category_list = models.Category.objects.annotate(c=Count('article')).values_list('title', 'c', 'nid', 'blog__userinfo__username') tag_list = models.Tag.objects.annotate(c=Count('article')).values_list('title', 'c', 'nid', 'blog__userinfo__username') month_list = models.Article.objects.annotate(month=TruncMonth('create_time')).values('month').annotate( c=Count('pk')).values_list('month', 'c', 'blog__userinfo__username') return render(request, 'index.html', locals())class Register(View): form = myforms.MyForm() def get(self, request): return render(request, 'register.html', &#123;'form': self.form&#125;) def post(self, request): # 前端提交后进行校验，提交就是post请求 # &#123;'csrfmiddlewaretoken': ['FELJgdjWNKdUXizMQ2GAqF6QMtZxYHvquEXJodcjrL8GRaVBknZ8VINjud6bX52X'], # 'username': ['lxx'], # 'password': ['123'], # 'confirm_password': ['123'], # 'email': ['123@qq.com']&#125; response = &#123;'status': False, 'msg': None&#125; form = myforms.MyForm(request.POST) print(form.is_valid()) print(form.cleaned_data) if form.is_valid(): # 校验通过，数据库查数据 response['status'] = True response['msg'] = '注册成功' # &#123;'username': 'lxx', 'password': '123', 'confirm_password': '123', 'email': '123@qq.com'&#125; clean_data = form.cleaned_data clean_data.pop('confirm_password') # &#123;'username': 'lxx', 'password': '123', 'email': '123@qq.com'&#125; if request.FILES: # &lt; MultiValueDict: &#123;'file_obj': [ &lt; InMemoryUploadedFile: timg.jpeg(image / jpeg) &gt;]&#125; &gt; clean_data['avatar'] = request.FILES.get('file_obj') # 前面数据准备成功了，写入数据库 # &#123;'username': 'lxx', 'password': '123', 'email': '123@qq.com', 'avatar': &lt; InMemoryUploadedFile: timg.jpeg(image / jpeg) &gt;&#125; models.Userinfo.objects.create_user(**clean_data) else: # 校验不通过，返回错误信息 response['msg'] = form.errors return JsonResponse(response, json_dumps_params=&#123;'ensure_ascii': False&#125;)from django.contrib import authclass Login(View): def get(self, request): return render(request, 'login.html') def post(self, request): response = &#123;'status': False, 'msg': None&#125; print(request.POST) user = request.POST.get('user') pwd = request.POST.get('pwd') valid_code = request.POST.get('valid_code') if not valid_code.upper() == request.session['valid_code'].upper(): response['msg'] = '验证码错误' return JsonResponse(response, json_dumps_params=&#123;'ensure_ascii': False&#125;) # 参数传入用户名和密码，他会去系统表中进行查找，有相同的返回对象，没有就返回None usr = auth.authenticate(request, username=user, password=pwd) if not usr: response['msg'] = '用户不存在' return JsonResponse(response, json_dumps_params=&#123;'ensure_ascii': False&#125;) else: auth.login(request, usr) # 调用login系统相当于做了以下三部 # 1.设置session和cookie # 2.生成request.user对象，这个对象是可以在函数视图中使用的(详情见auth中间件) # 3.request.user 相当于request.session response['status'] = True response['msg'] = '登录成功' return JsonResponse(response, json_dumps_params=&#123;'ensure_ascii': False&#125;) @staticmethod def get_valid_img(request): def get_random_color(): import random return (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)) from PIL import Image, ImageDraw, ImageFont from io import BytesIO import random img = Image.new('RGB', (270, 35), color=get_random_color()) draw = ImageDraw.Draw(img) kumo_font = ImageFont.truetype('static/font/大梁体繁简精全2016版(9月版).ttf', size=28) random_num = str(random.randint(0, 9)) random_low_alpha = chr(random.randint(65, 90)) random_upper_alpha = chr(random.randint(97, 122)) valid_code_str = \"\" for i in range(6): res = random.choice([random_num, random_low_alpha, random_upper_alpha]) draw.text([i * 40 + 20, 5], res, get_random_color(), font=kumo_font) # 保存验证码字符串 valid_code_str += res print(111111, valid_code_str) request.session['valid_code'] = valid_code_str print(request.session) # img.show() # 设置噪点燥线 width = 270 height = 35 for i in range(10): x1 = random.randint(0, width) x2 = random.randint(0, width) y1 = random.randint(0, height) y2 = random.randint(0, height) draw.line((x1, y1, x2, y2), fill=get_random_color()) for i in range(200): draw.point([random.randint(0, width), random.randint(0, height)], fill=get_random_color()) x = random.randint(0, width) y = random.randint(0, height) draw.arc((x, y, x + 1, y + 1), 0, 90, fill=get_random_color()) f = BytesIO() img.save(f, 'png') data = f.getvalue() return HttpResponse(data) @staticmethod def logout(request): auth.logout(request) return redirect('/login/') @staticmethod def set_password(request): if request.method == 'POST': old_password = request.POST.get('old_password') new_password = request.POST.get('new_password') if request.user.check_password(old_password): request.user.set_password(new_password) request.user.save() return redirect('/login/') return render(request, 'set_password.html')def site(request, username, **kwargs): blog = models.Blog.objects.filter(site_name=username).first() print(blog) if not blog: return render(request, 'error.html') else: article_list = models.Article.objects.filter(blog=blog) category_list = models.Category.objects.filter(blog=blog).annotate(c=Count('article')).values_list('title', 'c', 'nid') tag_list = models.Tag.objects.annotate(c=Count('article')).values_list('title', 'c', 'nid') month_list = models.Article.objects.filter(blog=blog).annotate(month=TruncMonth('create_time')).values( 'month').annotate(c=Count('pk')).values_list('month', 'c') print(tag_list) if kwargs: conditions = kwargs.get('conditions') param = kwargs.get('param') if conditions == 'category': article_list = article_list.filter(category=param) if conditions == 'tag': article_list = article_list.filter(tags=param) if conditions == 'archive': year, month = param.split('/') article_list = article_list.filter(create_time__year=year, create_time__month=month) return render(request, 'site.html', locals())def article_detail(request, username, article_id): article_obj = models.Article.objects.filter(nid=article_id).first() blog = article_obj.blog comment_list = models.Comment.objects.filter(article=article_obj) return render(request, 'article_detail.html', locals())# 点赞视图函数import jsonfrom django.db.models import Fdef digg(request): print(request.POST) article_id = request.POST.get('article_id') print('article_id', article_id) # 点赞人就是当前登录人 user_id = request.user.pk print(user_id) # 生成点赞记录 send_dic = &#123;'state': False, 'msg': None&#125; # 判断用户没有登录 print(11111111, request.user.is_authenticated) if not request.user.is_authenticated: send_dic['msg'] = '你未登录' return JsonResponse(send_dic, json_dumps_params=&#123;'ensure_ascii': False&#125;) # 下面的情况用户都是登录的 # 登录用户就是文章的作者 if request.user.username == models.Article.objects.filter(pk=article_id).first().blog.userinfo.username: print(1111, request.user) print(2222, models.Article.objects.filter(pk=article_id).first().blog.userinfo.username) send_dic['msg'] = '臭不要脸，给自己点赞' return JsonResponse(send_dic, json_dumps_params=&#123;'ensure_ascii': False&#125;) is_up = json.loads(request.POST.get('is_up')) obj = models.ArticleUpDown.objects.filter(user_id=user_id, article_id=article_id) if not obj: models.ArticleUpDown.objects.create(user_id=user_id, article_id=article_id) query_set = models.Article.objects.filter(pk=article_id) if is_up: query_set.update(up_count=F('up_count') + 1) send_dic['state'] = True send_dic['msg'] = '点赞成功' else: query_set.update(down_count=F('down_count') + 1) send_dic['state'] = True send_dic['msg'] = '点踩成功' else: send_dic['msg'] = '你已经点过赞' return JsonResponse(send_dic, json_dumps_params=&#123;'ensure_ascii': False&#125;)# 评论视图函数from django.db import transactionfrom django.db.models import Ffrom django.contrib.auth.decorators import login_required@login_required(login_url='/login/')def comment(request): send_dic = &#123;'state': False, 'msg': None&#125; if request.is_ajax(): print(request.POST) # &#123;'comment': ['dfddffd'], 'article_id': ['2'],&#125; parent_id = request.POST.get('parent_id') comment = request.POST.get('comment') article_id = request.POST.get('article_id') user_id = request.user.pk with transaction.atomic(): # 写入数据库 models.Comment.objects.create(content=comment, article_id=article_id, user_id=user_id, parent_comment_id=parent_id) models.Article.objects.filter(pk=article_id).update(comment_count=F('comment_count') + 1) send_dic['state'] = True send_dic['msg'] = '评论成功' return JsonResponse(send_dic, json_dumps_params=&#123;'ensure_ascii': False&#125;) base.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"/static/blog/bs/css/bootstrap.css\"&gt; &lt;script src=\"/static/blog/bs/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&#123;#&lt;h2&gt;hi, &#123;&#123; request.user &#125;&#125;&lt;/h2&gt;#&#125;&lt;nav class=\"navbar navbar-inverse\"&gt; &lt;div class=\"container-fluid\"&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class=\"navbar-header\"&gt; &lt;button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#bs-example-navbar-collapse-1\" aria-expanded=\"false\"&gt; &lt;span class=\"sr-only\"&gt;Toggle navigation&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=\"navbar-brand\" href=\"/index/\"&gt;首页&lt;/a&gt; &lt;a class=\"navbar-brand\" href=\"/&#123;&#123; user.username &#125;&#125;/\"&gt;&#123;&#123; user.blog.title &#125;&#125;的页面&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class=\"collapse navbar-collapse\" id=\"bs-example-navbar-collapse-1\"&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &#123;% if request.user.is_authenticated %&#125; &lt;li&gt;&lt;a href=\"#\"&gt;&#123;&#123; request.user.username &#125;&#125;&lt;/a&gt;&lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\" role=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\"&gt;更多操作 &lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"/set_password/\"&gt;修改密码&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;修改头像&lt;/a&gt;&lt;/li&gt; &lt;li role=\"separator\" class=\"divider\"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/logout/\"&gt;注销&lt;/a&gt;&lt;/li&gt; &#123;% else %&#125; &lt;li&gt;&lt;a href=\"/login/\"&gt;登录&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/register/\"&gt;注册&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt;&lt;/nav&gt;&lt;div class=\"container-fluid\"&gt; &lt;div class=\"row\"&gt; &#123;% block css %&#125; &#123;% endblock %&#125; &#123;% block content %&#125; &#123;% endblock %&#125; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; site.html &#123;% extends 'base.html' %&#125;&#123;% block content %&#125; &lt;div class=\"col-md-3\"&gt; &#123;% load mytags %&#125; &#123;% get_classification_style username %&#125; &lt;/div&gt; &lt;div class=\"col-md-9\"&gt; &#123;% for article in article_list %&#125; &lt;div class=\"media\"&gt; &lt;div class=\"media-left\"&gt; &lt;a href=\"#\"&gt; &lt;img class=\"media-object\" src=\"/media/&#123;&#123; article.blog.userinfo.avatar &#125;&#125;\" alt=\"...\" width=\"60\"&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=\"media-body\"&gt; &lt;h4 class=\"media-heading\"&gt;&lt;a href=\"/&#123;&#123; username &#125;&#125;/articles/&#123;&#123; article.pk &#125;&#125;\"&gt;&#123;&#123; article.title &#125;&#125;&lt;/a&gt;&lt;/h4&gt; &lt;p&gt;&#123;&#123; article.desc &#125;&#125;&lt;/p&gt; &lt;div class=\"pull-right\"&gt; &lt;span&gt;posted @&amp;nbsp;&#123;&#123; article.create_time|date:\"Y-m-d h:m:s\" &#125;&#125;&amp;nbsp;&lt;/span&gt; &lt;span&gt;&#123;&#123; article.blog.userinfo.username &#125;&#125;&amp;nbsp;&lt;/span&gt; &lt;span&gt;评论(&#123;&#123; article.comment_count &#125;&#125;)&amp;nbsp;&lt;/span&gt; &lt;span&gt;点赞(&#123;&#123; article.down_count &#125;&#125;)&lt;/span&gt; &lt;span&gt;&lt;a href=\"\"&gt;编辑&lt;/a&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;hr&gt; &#123;% endfor %&#125; &lt;/div&gt;&#123;% endblock %&#125; error.html &lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;&lt;html lang=\"zh-cn\"&gt;&lt;head&gt; &lt;meta http-equiv=\"Page-Enter\" content=\"blendTrans(Duration=0.5)\"&gt; &lt;meta http-equiv=\"Page-Exit\" content=\"blendTrans(Duration=0.5)\"&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt; &lt;title&gt;出错啦! - 你做了什么&lt;/title&gt; &lt;style type=\"text/css\"&gt; body &#123; vertical-align: middle; &#125; div.center &#123; position: absolute; top: 50%; left: 50%; margin: -25% 0 0 -320px; width: 640px; min-height: 427px; padding: 0px; &#125; div.errmsg &#123; text-align: left; width: 640px; line-height: 150%; &#125; a &#123; text-decoration: none; color: red &#125; .center &#123; display: none &#125; &lt;/style&gt; &lt;link rel=\"shortcut icon\" href=\"//static.hdslb.com/images/favicon.ico\"&gt; &lt;link href=\"//static.hdslb.com/error/dist/error.css\" rel=\"stylesheet\"&gt; &lt;script type=\"text/javascript\"&gt; var options = &#123; type: 'defaultError' &#125; &lt;/script&gt; &lt;script type=\"text/javascript\" src=\"//s1.hdslb.com/bfs/static/jinkela/long/js/jquery/jquery1.7.2.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body style=\"direction: ltr;\"&gt; &lt;div class=\"z-top-container\"&gt;&lt;/div&gt; &lt;div class=\"error-container\"&gt; &lt;div class=\"error-panel server-error\"&gt; &lt;img src=\"//static.hdslb.com/error/very_sorry.png\"&gt; &lt;div&gt; &lt;div class=\"left-panel\"&gt; &lt;a href=\"/index/\" class=\"rollback-btn\"&gt;返回上一页&lt;/a&gt; &lt;/div&gt; &lt;div class=\"right-panel\"&gt; &lt;b&gt;错误号:&lt;/b&gt; 404&amp;nbsp;&amp;nbsp;&lt;br /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"error-split\"&gt; &lt;/div&gt; &lt;div class=\"error-manga\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; classfication.html &lt;div&gt; &lt;div class=\"panel panel-success\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3 class=\"panel-title\"&gt;文章分类&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &#123;% for category in category_list %&#125; &lt;p&gt;&lt;a href=\"/&#123;&#123; username &#125;&#125;/category/&#123;&#123; category.2 &#125;&#125;\"&gt;&#123;&#123; category.0 &#125;&#125;&lt;/a&gt;&amp;nbsp;(&#123;&#123; category.1 &#125;&#125;)&lt;/p&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"panel panel-danger\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3 class=\"panel-title\"&gt;文章标签&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &#123;% for tag in tag_list %&#125; &lt;p&gt;&lt;a href=\"/&#123;&#123; username &#125;&#125;/tag/&#123;&#123; tag.2 &#125;&#125;\"&gt;&#123;&#123; tag.0 &#125;&#125;&lt;/a&gt;&amp;nbsp;(&#123;&#123; tag.1 &#125;&#125;)&lt;/p&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"panel panel-info\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3 class=\"panel-title\"&gt;日期归档 &lt;/h3&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &#123;% for month in month_list %&#125; &lt;p&gt; &lt;a href=\"/&#123;&#123; username &#125;&#125;/archive/&#123;&#123; month.0|date:'Y/m' &#125;&#125;\"&gt;&#123;&#123; month.0 |date:'Y年m月' &#125;&#125;&lt;/a&gt;&amp;nbsp;(&#123;&#123; month.1 &#125;&#125;) &lt;/p&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 后台管理urls.py \"\"\"bbs3 URL ConfigurationThe `urlpatterns` list routes URLs to views. For more information please see: https://docs.djangoproject.com/en/1.11/topics/http/urls/Examples:Function views 1. Add an import: from my_app import views 2. Add a URL to urlpatterns: url(r'^$', views.home, name='home')Class-based views 1. Add an import: from other_app.views import Home 2. Add a URL to urlpatterns: url(r'^$', Home.as_view(), name='home')Including another URLconf 1. Import the include() function: from django.conf.urls import url, include 2. Add a URL to urlpatterns: url(r'^blog/', include('blog.urls'))\"\"\"from django.conf.urls import urlfrom django.contrib import adminfrom blog import viewsfrom bbs3 import settingsfrom django.views.static import serveurlpatterns = [ url(r'^admin/', admin.site.urls), # 注册功能 url(r'^register/', views.Register.as_view()), # 登录功能 url(r'^login/', views.Login.as_view()), url(r'^get_valid_img/', views.Login.get_valid_img), url(r'^logout/', views.Login.logout), url(r'^set_password/', views.Login.set_password), # 主页 url(r'^index/', views.index), # 配置media路由 url(r'^media/(?P&lt;path&gt;.*)', serve, &#123;'document_root': settings.MEDIA_ROOT&#125;), # 侧边栏筛选功能 url(r'^(?P&lt;username&gt;\\w+)/(?P&lt;conditions&gt;tag|category|archive)/(?P&lt;param&gt;.*)', views.site), # 配置文章详情页 url(r'^(?P&lt;username&gt;\\w+)/articles/(?P&lt;article_id&gt;\\d+)$', views.article_detail), # 点赞点踩 url(r'^digg/', views.digg), # 父评论页面 url(r'^comment', views.comment), # 后台管理 url(r'^backend/$', views.backend), url(r'^add_article/$', views.add_article), url(r'^upload_img/$', views.upload_img), # 配置404页面 url(r'^(?P&lt;username&gt;\\w+)/$', views.site),] views.py from django.shortcuts import render, HttpResponse, redirect# Create your views here.from blog import modelsfrom django.http import JsonResponsefrom blog.utils.my_page import Pagination@login_required(login_url='/login/')def backend(request): print(request.user.blog) article_list = models.Article.objects.filter(blog=request.user.blog) print(article_list.query) page_obj = Pagination(current_page=request.GET.get('page', 1), all_count=article_list.count()) page_queryset = article_list[page_obj.start:page_obj.end] return render(request, 'backend/backend.html', locals())from bs4 import BeautifulSoupdef add_article(request): if request.method == 'POST': print(request.POST) title = request.POST.get('title') content = request.POST.get('content') # 能够帮我拿到当前用户写的所有的标签 将script删除 res = BeautifulSoup(content, 'html.parser') print(type(res)) tags = res.find_all() print(0000, tags) for tag in tags: print(1111, tag.name, type(tag.name)) # 将script全部删除 if tag.name == \"script\": tag.decompose() # 删除指定的标签 print(2222, tag.name) desc = res.text[0:150] # 写入数据库 models.Article.objects.create(title=title, content=str(res), desc=desc, blog=request.user.blog) return redirect('/backend/backend.html') return render(request, 'backend/add_article.html')from bbs3 import settingsimport osdef upload_img(request): back_dic = &#123;'error': ''&#125; if request.method == 'POST': print(request.FILES) img_obj = request.FILES.get('imgFile') # 规定编辑器上传的图片全部放到media文件夹里面的upload_img文件夹下 # 1.将文件存储到media文件夹下 path = os.path.join(settings.BASE_DIR, 'media', 'upload_img') if not os.path.exists(path): os.mkdir(path) file_path = os.path.join(path, img_obj.name) with open(file_path, 'wb') as f: for line in img_obj: f.write(line) # 2.将文件路径返回给前端 back_dic['error'] = 0 back_dic['url'] = '/media/upload_img/%s' % img_obj.name \"\"\" //成功时 &#123; \"error\" : 0, \"url\" : \"http://www.example.com/path/to/file.ext\" &#125; //失败时 &#123; \"error\" : 1, \"message\" : \"错误信息\" &#125; \"\"\" return JsonResponse(back_dic) backendbase.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;后台管理&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"/static/blog/bs/css/bootstrap.css\"&gt; &lt;script src=\"/static/blog/bs/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;nav class=\"navbar navbar-inverse\"&gt; &lt;div class=\"container-fluid\"&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class=\"navbar-header\"&gt; &lt;button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#bs-example-navbar-collapse-1\" aria-expanded=\"false\"&gt; &lt;span class=\"sr-only\"&gt;Toggle navigation&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=\"navbar-brand\" href=\"#\"&gt;后台管理&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class=\"collapse navbar-collapse\" id=\"bs-example-navbar-collapse-1\"&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&#123;&#123; request.user.username &#125;&#125;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt;&lt;/nav&gt;&lt;div class=\"container-fluid\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-2\"&gt; &lt;div class=\"panel-group\" id=\"accordion\" role=\"tablist\" aria-multiselectable=\"true\"&gt; &lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-heading\" role=\"tab\" id=\"headingOne\"&gt; &lt;h4 class=\"panel-title\"&gt; &lt;a role=\"button\" data-toggle=\"collapse\" data-parent=\"#accordion\" href=\"#collapseOne\" aria-expanded=\"true\" aria-controls=\"collapseOne\"&gt; 操作 &lt;/a&gt; &lt;/h4&gt; &lt;/div&gt; &lt;div id=\"collapseOne\" class=\"panel-collapse collapse in\" role=\"tabpanel\" aria-labelledby=\"headingOne\"&gt; &lt;div class=\"panel-body\"&gt;&lt;a href=\"/add_article/\"&gt;添加文章&lt;/a&gt;&lt;/div&gt; &lt;div class=\"panel-body\"&gt;&lt;a href=\"#\"&gt;添加随笔&lt;/a&gt;&lt;/div&gt; &lt;div class=\"panel-body\"&gt;&lt;a href=\"#\"&gt;个人设置&lt;/a&gt;&lt;/div&gt; &lt;div class=\"panel-body\"&gt;&lt;a href=\"#\"&gt;文件搬家&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-md-10\"&gt; &lt;div&gt; &lt;!-- Nav tabs --&gt; &lt;ul class=\"nav nav-tabs\" role=\"tablist\"&gt; &lt;li role=\"presentation\" class=\"active\"&gt;&lt;a href=\"#home\" aria-controls=\"home\" role=\"tab\" data-toggle=\"tab\"&gt;文章&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a href=\"#profile\" aria-controls=\"profile\" role=\"tab\" data-toggle=\"tab\"&gt;随笔&lt;/a&gt; &lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a href=\"#messages\" aria-controls=\"messages\" role=\"tab\" data-toggle=\"tab\"&gt;设置&lt;/a&gt; &lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a href=\"#settings\" aria-controls=\"settings\" role=\"tab\" data-toggle=\"tab\"&gt;更多&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- Tab panes --&gt; &lt;div class=\"tab-content\"&gt; &lt;div role=\"tabpanel\" class=\"tab-pane active\" id=\"home\"&gt; &#123;% block css %&#125; &#123;% endblock %&#125; &#123;% block content %&#125; &#123;% endblock %&#125; &lt;/div&gt; &lt;div role=\"tabpanel\" class=\"tab-pane\" id=\"profile\"&gt;随笔页面&lt;/div&gt; &lt;div role=\"tabpanel\" class=\"tab-pane\" id=\"messages\"&gt;设置页面&lt;/div&gt; &lt;div role=\"tabpanel\" class=\"tab-pane\" id=\"settings\"&gt;更多页面&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; backend.html &#123;% extends 'backend/backendbase.html' %&#125;&#123;% block content %&#125; &lt;table class=\"table table-hover table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt;标题&lt;/td&gt; &lt;td&gt;作者&lt;/td&gt; &lt;td&gt;评论&lt;/td&gt; &lt;td&gt;点赞&lt;/td&gt; &lt;td&gt;点踩&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for article in page_queryset %&#125; &lt;tr&gt; &lt;th&gt;&lt;a href=\"/&#123;&#123; article.blog.userinfo.username &#125;&#125;/articles/&#123;&#123; article.pk &#125;&#125;\"&gt;&#123;&#123; article.title &#125;&#125;&lt;/a&gt;&lt;/th&gt; &lt;th&gt;&#123;&#123; article.blog.userinfo.username &#125;&#125;&lt;/th&gt; &lt;th style=\"color: red;\"&gt;&#123;&#123; article.comment_count &#125;&#125;&lt;/th&gt; &lt;th&gt;&#123;&#123; article.up_count &#125;&#125;&lt;/th&gt; &lt;th&gt;&#123;&#123; article.down_count &#125;&#125;&lt;/th&gt; &lt;th&gt;&lt;a href=\"#\"&gt;编辑&lt;/a&gt;&lt;/th&gt; &lt;th&gt;&lt;a href=\"#\"&gt;删除&lt;/a&gt;&lt;/th&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt; &#123;&#123; page_obj.page_html|safe &#125;&#125;&#123;% endblock %&#125; add_article.html &#123;% extends 'backend/backendbase.html' %&#125;&#123;% block css %&#125; &lt;style&gt; div.CollapsibleTitle &#123; font-size: 105%; background: #E5EEF7; border-top: 1px solid #AAAAAA; border-bottom: 1px dashed #AAAAAA; font-weight: bold; color: #333333; width: auto; padding: 2px 12px; margin: 12px 0px 5px 0px; clear: left; &#125; &lt;/style&gt;&#123;% endblock %&#125;&#123;% block content %&#125; &lt;div id=\"Editor_Edit_Header\" class=\"CollapsibleTitle\"&gt; &lt;span id=\"Editor_Edit_headerTitle\"&gt;添加文章&lt;/span&gt; &lt;/div&gt; &lt;hr&gt; &lt;form action=\"\" method=\"post\"&gt; &#123;% csrf_token %&#125; &lt;h5&gt;标题&lt;/h5&gt; &lt;input type=\"text\" name=\"title\" id=\"id_title\" class=\"form-control\"&gt; &lt;p&gt;内容(kindeditor编辑器，支持拖放/粘贴上传图片)&lt;/p&gt; &lt;p&gt;&lt;textarea name=\"content\" id=\"id_content\" cols=\"30\" rows=\"10\"&gt;&lt;/textarea&gt;&lt;/p&gt; &lt;input type=\"submit\" value=\"发布文章\" class=\"btn btn-info\"&gt; &lt;/form&gt; &lt;script charset=\"utf-8\" src=\"/static/kindeditor/kindeditor-all-min.js\"&gt;&lt;/script&gt; &lt;script&gt; KindEditor.ready(function (K) &#123; window.editor = K.create('#id_content', &#123; width: '100%', height: '700px', resizeType: 0, // 控制文件上传的位置 uploadJson: '/upload_img/', extraFileUploadParams: &#123; 'csrfmiddlewaretoken': '&#123;&#123; csrf_token &#125;&#125;' &#125; &#125;); &#125;); &lt;/script&gt;&#123;% endblock %&#125;","categories":[{"name":"项目","slug":"项目","permalink":"http://cjwnb.top/categories/项目/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"项目","slug":"项目","permalink":"http://cjwnb.top/tags/项目/"}]},{"title":"Django操作session和cookie","slug":"session和cookie","date":"2019-07-21T16:26:12.563Z","updated":"2019-07-22T13:25:09.596Z","comments":true,"path":"2019/07/22/session和cookie/","link":"","permalink":"http://cjwnb.top/2019/07/22/session和cookie/","excerpt":"","text":"http协议四大特性 基于TCP/IP作用于应用层的协议 基于请求响应 无状态: 同一个客户端发送多次请求没有任何关联 无连接 会话跟踪技术多次请求之间记录消息来弥补http无状态保存的缺点（使多次请求有联系）、 cookie 具体一个浏览器针对一个服务器存储其消息的键值对（key=value） 客户端-服务端 客户端第一次访问服务端的某一个功能，比如login功能，一开始客户端的请求头里是带着空字典去访问的，访问成功后，服务器后生成一个cookie给到客户端，比如说下面的cookie: Cookie: BAIDUID=F00480318ED42C27C35D3A2FBE2B0AD7:FG=1; BIDUPSID=F00480318ED42C27C35D3A2FBE2B0AD7; PSTM=1561713680; BD_UPN=123253; BDUSS=npyYVNyVEMwaldpTUxBV1BCUlhBfmVRTGZJclFlaENWQ0tDeGJyVFQ3a09rRnBkSVFBQUFBJCQAAAAAAAAAAAEAAABYUcuESmF2YV93aW5uZXIyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4DM10OAzNdf; BD_HOME=1; H_PS_PSSID=26525_1453_21121_29522_29518_28518_29098_28838_29071 当客户端再次去访问的时候，客户端就带着这个味cookie来访问，服务器就判定了这个客户端访问过该功能，则不再生成cookie，直接让客户端访问其功能 cookie一旦生成，每次访问都会带着，除非失效，cookie是存在磁盘上的 访问不同的web服务的cookie是不同的，不同客户端访问同一个web服务的cookie也是不同的 session 保存在服务端上的键值对服务端产生随机的串儿返回给客户端，服务端找一个地方将串儿与对应的信息存起来{‘随机字符串’:’敏感信息’} 客户端第一次骑牛携带的cookie：{} 服务器设置session： Request.session[‘username’]=’yuan’ 设置session实现了3步 生成随机字符串 123ghrjsdg 把这次给浏览器的响应体里设置set_cookie, key是sessionid,值就是生成的随机字符串 123ghrjsdg 在django-session表中添加记录， session-key 是生成的随机字符串 123ghrjsdg，session-data是 {‘username’:’yuan’} 客户端第二次请求携带的cookie: {sessionid=123ghrjsdg}到某一个视图函数（访问某个功能） 服务器中的视图函数取session request.session[‘username’] 实现了3步 客户端携带着cookie: {sessionid=123ghrjsdg}， 视图函数会先读取到cookie中的随机字符串 123ghrjsdg 然后视图函数会去django-session表中找到session-key为cookie中的随机字符串 123ghrjsdg的记录 然后从这条记录中找到{‘username’:’yuan’}，从而取出值，如果视图函数是登入功能的话，就可以判定这个发请求来的客户端登录成功了，而且登录名字是yuan 没有cookie,session没有任何存在的意义，当我们在浏览器上禁用了cookie,我们就无法登陆京东或者淘宝，因为服务器并没有session,验证无法通过，就无法登入了，session的查看方式在console下的application下的cookies可以查看 设置cookiecookie语法 响应体： HttpResponse() ,render(), redirect() 设置cookie必须用响应体设置 obj.set_cookie(key,value) 设置完cookie，可以在响应头中查看 request.COOKIE.get(key) / request.COOKIE[key] cookie超时时间： max_age(ie不支持)， expires(ie支持，支持时间对象) 如果不设置超时时间，cookie就远生效 有效路径（path）: 针对哪些路径下的视图函数能取到设置的cookie 代码验证models.py from django.db import modelsclass Userinfo(models.Model): user=models.CharField(max_length=32) pwd=models.CharField(max_length=32) 数据库测试数据 urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login/', views.login), url(r'^index/', views.index),] views.py from django.shortcuts import render, HttpResponse, redirect# Create your views here.from app01.models import Userinfodef login(request): if request.method == 'POST': user = request.POST.get('user') pwd = request.POST.get('pwd') s_user = Userinfo.objects.filter(user=user, pwd=pwd).first() print(s_user.user, s_user.pwd) if s_user: # 登录成功 response = HttpResponse('登录成功') response.set_cookie('name', s_user.user) response.set_cookie('pwd', s_user.pwd, path='/index/') # 设置用户的上次访问时间 import datetime now = datetime.datetime.now().strftime('%Y-%m-%d %X') response.set_cookie('now', now) return response else: # 登录失败 pass return render(request, 'login.html')def index(request): print('index', request.COOKIES) name = request.COOKIES.get('name') now = request.COOKIES.get('now', \"\") if name: return render(request, 'index.html', locals()) return redirect('/login/')def test(request): print('test', request.COOKIES) return HttpResponse('test') login.html &lt;body&gt;&lt;form action=\"\" method=\"post\"&gt; &#123;% csrf_token %&#125; 用户名 &lt;input type=\"text\" name=\"user\"&gt; 密码 &lt;input type=\"text\" name=\"pwd\"&gt; &lt;input type=\"submit\" value=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt; index.html &lt;body&gt;&lt;h1&gt;hi &#123;&#123; name &#125;&#125;&lt;/h1&gt;&lt;/body&gt; 当用户访问http://127.0.0.1:8000/login/,如果验证通过，则登录成功，成功返回设置的cookies，以及可以看到返回的消息 当浏览器输入网址http://127.0.0.1:8000/index/，可以查看到在login视图函数中设置的cookies 当浏览器输入网址http://127.0.0.1:8000/test/，不可以查看login函数中设置的pwd这个cookies 案例urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^reg/', views.reg), url(r'^login/', views.login), url(r'^index/', views.index), url(r'^home/', views.home), url(r'^xxx/', views.xxx),] views.py from django.shortcuts import render, HttpResponse, redirect# Create your views here.def login(request): if request.method == 'POST': username = request.POST.get('username') password = request.POST.get('password') if username == 'lyysb' and password == '123': old_path = request.GET.get('next') if old_path: obj = redirect(old_path) else: obj = redirect('/home/') # 用户登录成功 朝浏览器设置一个cookie obj.set_cookie('name', 'lyysb') # 设置上次访问时间 import datetime now = datetime.datetime.now().strftime('%Y-%m-%d %X') obj.set_cookie('time', now) return obj return render(request, 'login.html')from functools import wrapsdef login_auth(func): @wraps(func) def inner(request, *args, **kwargs): print(request.get_full_path()) old_path = request.get_full_path() # 校验cookie if request.COOKIES.get('name'): return func(request, *args, **kwargs) return redirect('/login/?next=%s' % old_path) return inner@login_authdef index(request): # print(request.COOKIES.get('name')) # if request.COOKIES.get('name'): last_time = request.COOKIES.get('time',\"\") return render(request, 'index.html', &#123;'last_time': last_time&#125;)@login_authdef home(request): return HttpResponse('我是home页面，只有登陆了才能看')@login_authdef xxx(request): return HttpResponse('我是xxx页面，只有登陆了才能看') login.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; &lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt; &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\"&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js\" integrity=\"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"\" method=\"post\"&gt; &lt;p&gt;username&lt;input type=\"text\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;password&lt;input type=\"text\" name=\"password\"&gt;&lt;/p&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; index.html &lt;body&gt;&lt;h1&gt;index&lt;/h1&gt;&lt;p&gt;上次访问时间：&#123;&#123; last_time &#125;&#125;&lt;/p&gt;&lt;/body&gt;` 设置Sessionsession语法 设置Sessions值 request.session[‘session_name’]=’admin’ 获取Session值 session_name=request.session[‘session_name’] 删除Session值 del request.session[‘session_name’] Flush() 删除当前的会话数据并删除会话的Cookie 这用于确保前面的会话数据不可以再次被用户的浏览器访问 代码验证models.py from django.db import modelsclass Userinfo(models.Model): user=models.CharField(max_length=32) pwd=models.CharField(max_length=32) 数据库测试数据 urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^login_session/', views.login_session), url(r'^index_session/', views.index_session),] views.py from django.shortcuts import render, HttpResponse, redirect# Create your views here.from app01.models import Userinfodef login_session(request): if request.method == 'POST': user = request.POST.get('user') pwd = request.POST.get('pwd') user = Userinfo.objects.filter(user=user, pwd=pwd).first() if user: request.session['is_login'] = True request.session['username'] = 'hppsb' import datetime now = datetime.datetime.now().strftime('%Y-%m-%d %X') request.session['now'] = now return HttpResponse('登录成功') ''' 1. 生成一个随机字符串 0ps4avkhy95v4hbh1f0bae4266zlsddd 2. response.set_cookie('sessionid',dfrtghhtyr) 3. 在django session 表中创建记录 session-key session-data 0ps4avkhy95v4hbh1f0bae4266zlsddd &#123;'is_login':True,'username':'hhpsb'&#125; ''' return render(request, 'login.html')def index_session(request): is_login = request.session.get('is_login') if is_login: name = request.session.get('username') now=request.session.get('now') return render(request, 'index.html', locals()) return redirect('/login_session/') login.html &lt;body&gt;&lt;form action=\"\" method=\"post\"&gt; &#123;% csrf_token %&#125; 用户名 &lt;input type=\"text\" name=\"user\"&gt; 密码 &lt;input type=\"text\" name=\"pwd\"&gt; &lt;input type=\"submit\" value=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt; index.html &lt;body&gt;&lt;h1&gt;hi &#123;&#123; name &#125;&#125;&lt;/h1&gt;&lt;/body&gt; 浏览访问http://127.0.0.1:8000/login_session/，验证通过后产生cookie 查看django_session表 浏览器访问http://127.0.0.1:8000/index_session/ 更新session 更新操作，如果用户访问过页面，则第二次访问会带着sessionid这个cookie字段来访问，数据库表django_session中的session_key字段不变，如果添加新的session数据，数据库表中的session_data会变化 views.py def index_session(request): is_login = request.session.get('is_login') if is_login: name = request.session.get('username') now=request.session.get('now') request.session['xxx']='xxx' # 把这条数据加入session，session_data字段立马变化 return render(request, 'index.html', locals()) return redirect('/login_session/') 基于session的注销功能models.py from django.db import modelsclass Userinfo(models.Model): user=models.CharField(max_length=32) pwd=models.CharField(max_length=32) 数据库测试数据 urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^login_session/', views.login_session), url(r'^index_session/', views.index_session), url(r'^logout/', views.logout),] views.py def login_session(request): if request.method == 'POST': user = request.POST.get('user') pwd = request.POST.get('pwd') user = Userinfo.objects.filter(user=user, pwd=pwd).first() if user: request.session['is_login'] = True request.session['username'] = 'hppsb' import datetime now = datetime.datetime.now().strftime('%Y-%m-%d %X') request.session['now'] = now return redirect('/index_session/') ''' 1. 生成一个随机字符串 0ps4avkhy95v4hbh1f0bae4266zlsddd 2. response.set_cookie('sessionid',dfrtghhtyr) 3. 在django session 表中创建记录 session-key session-data 0ps4avkhy95v4hbh1f0bae4266zlsddd &#123;'is_login':True,'username':'hhpsb'&#125; ''' return render(request, 'login.html')def index_session(request): is_login = request.session.get('is_login') if is_login: name = request.session.get('username') now=request.session.get('now') return render(request, 'index.html', locals()) return redirect('/login_session/')def logout(request): request.session.flush() ''' 做的三步操作： 1. randon_str=request.COOKIE.get('sessionid') 2. django-session.objects.filter(session-key=randon_str).delete() 3. response.delete_cookie(\"sessionid\",randon_str) ''' return redirect('/login_session/') login.html &lt;body&gt;&lt;form action=\"\" method=\"post\"&gt; &#123;% csrf_token %&#125; 用户名 &lt;input type=\"text\" name=\"user\"&gt; 密码 &lt;input type=\"text\" name=\"pwd\"&gt; &lt;input type=\"submit\" value=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt; index.html &lt;body&gt;&lt;h1&gt;hi &#123;&#123; name &#125;&#125;&lt;/h1&gt;&lt;/body&gt; 浏览器访问http://127.0.0.1:8000/index_session/ 按注销跳转到登录页面 session的配置参数 配置settings.py SESSION_ENGINE = 'django.contrib.sessions.backends.db' # 引擎(默认)SESSION_COOKIE_NAME = \"sessionid\" # Session的cookie保存在浏览器上时的key, 即: sessionid=随机字符串(默认)SESSION_COOKIE_PATH = \"/\" # Session的cookie保存的路径(默认)SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名(默认)SESSION_COOKIE_SECURE = False # 是否Https传输Cookie(默认)SESSION_COOKIE_HTTPONLY = True # 是否Session的Cookie只支持http传输(默认)SESSION_COOKIE_AGE = 1209600 # Session的Cookie失效日期(默认)SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期(默认)SESSION_SAVE_EVERY_REQUEST = False # 是否每次请求都保存Session， 默认修改后才保存(默认)","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"前端","slug":"前端","permalink":"http://cjwnb.top/tags/前端/"}]},{"title":"模块","slug":"模块","date":"2019-07-21T12:47:43.161Z","updated":"2019-07-21T12:47:43.161Z","comments":true,"path":"2019/07/21/模块/","link":"","permalink":"http://cjwnb.top/2019/07/21/模块/","excerpt":"","text":"importlibimport importlibs='yyy.b'res=importlib.import_module(s)print(res) # &lt;module 'yyy.b' from '/Users/cjw/Desktop/Django_projects/xxx/yyy/b.py'&gt;","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"前端","slug":"前端","permalink":"http://cjwnb.top/tags/前端/"}]},{"title":"form组件","slug":"form组件","date":"2019-07-21T12:13:35.354Z","updated":"2019-07-22T07:06:52.568Z","comments":true,"path":"2019/07/21/form组件/","link":"","permalink":"http://cjwnb.top/2019/07/21/form组件/","excerpt":"","text":"更详细理论知识查看博客： https://www.cnblogs.com/Dominic-Ji/p/9240365.html 注册功能实现 1.渲染前端标签获取用户输入 &gt;&gt;&gt; 渲染标签2.获取用户输入传递到后端校验 &gt;&gt;&gt; 校验数据3.校验未通过展示错误信息 &gt;&gt;&gt; 展示信息 校验前端后端都可以做，但是前端可以不做，后端必须得做!!! 手动实现urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^reg/', views.reg),] views.py from django.shortcuts import render# Create your views here.def reg(request): errors = &#123;'username': '', 'password': ''&#125; if request.method == 'POST': username = request.POST.get('username') password = request.POST.get('password') if 'sb' in username: errors['username'] = '用户名里不能有sb,你这个dsb' if password == '123': errors['password'] = '密码太简单了，你这个bb' return render(request, 'reg.html', locals()) reg.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;注册页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;注册页面&lt;/h1&gt;&lt;form action=\"\" method=\"post\"&gt; &lt;p&gt; username:&lt;input type=\"text\" name=\"username\"&gt; &lt;span&gt;&#123;&#123; errors.username &#125;&#125;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;password:&lt;input type=\"password\" name=\"password\"&gt; &lt;span&gt;&#123;&#123; errors.password &#125;&#125;&lt;/span&gt; &lt;/p&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1.渲染标签2.校验数据3.展示信息 校验数据需要一个form类from django import formsclass MyForm(forms.Form): name = forms.CharField(max_length=6) password = forms.CharField(max_length=8,min_length=3) email = forms.EmailField(required=True) 实例化form对象form_obj = MyForm(&#123;'name':'jason'&#125;) 查看数据校验是否合法form_obj.is_valid() # 只有当所有的字段都校验通过才会返回True 查看校验错误的信息form_obj.errors # 这个里面放的是所有校验未通过的字段及错误提示 \"\"\" &#123; 'name': ['Ensure this value has at most 6 characters (it has 7).'], 'password': ['Ensure this value has at least 3 characters (it has 2).'], 'email': ['Enter a valid email address.'] &#125; \"\"\" 查看校验通过的数据form_obj.cleaned_data # 符合校验规则数据都会被放到该对象中 form组件校验数据的规则从上往下依次取值校验 校验通过的放到cleaned_data 校验失败的放到errors注意 form组件校验数据的规则从上往下依次取值校验 校验通过的放到cleaned_data 校验失败的放到errors form中所有的字段默认都是必须传值的(required=True)校验数据的时候可以都传(多传的数据不会做任何的校验&gt;&gt;&gt;不会影响form校验规则) 测试代码views.py from django import formsclass MyForm(forms.Form): name = forms.CharField(max_length=6) password = forms.CharField(max_length=8, min_length=3) email = forms.EmailField() 字段名全部传错校验不通过 &gt;&gt;&gt; from app01 import views&gt;&gt;&gt; form_obj=views.MyForm(&#123;'name':'egondsb','password':'12','email':'123'&#125;)&gt;&gt;&gt; form_obj.is_valid()False&gt;&gt;&gt; form_obj.errors&#123;'name': ['Ensure this value has at most 6 characters (it has 7).'], 'password': ['Ensure this value has at least 3 characters (it has 2).'], 'email': ['Enter &#125; 传错一个字段校验不通过 &gt;&gt;&gt; from app01 import views&gt;&gt;&gt; form_obj=views.MyForm(&#123;'name':'egon','password':'1234','email':'123'&#125;)&gt;&gt;&gt; form_obj.is_valid()False&gt;&gt;&gt; form_obj.errors&#123;'email': ['Enter a valid email address.']&#125;&gt;&gt;&gt; form_obj.cleaned_data&#123;'name': 'egon', 'password': '1234'&#125; 少传一个字段校验不通过 &gt;&gt;&gt; from app01 import views&gt;&gt;&gt; form_obj=views.MyForm(&#123;'name':'egon','password':'1234'&#125;)&gt;&gt;&gt; form_obj.is_valid()False&gt;&gt;&gt; form_obj.errors&#123;'email': ['This field is required.']&#125;&gt;&gt;&gt; form_obj.cleaned_data&#123;'name': 'egon', 'password': '1234'&#125; 字段全部传对校验通过 &gt;&gt;&gt; from app01 import views&gt;&gt;&gt; form_obj=views.MyForm(&#123;'name':'egon','password':'1234','email':'123@qq.com'&#125;)&gt;&gt;&gt; form_obj.is_valid()True&gt;&gt;&gt; form_obj.cleaned_data&#123;'name': 'egon', 'password': '1234', 'email': '123@qq.com'&#125;&gt;&gt;&gt; form_obj.errors&#123;&#125; 多传一个字段校验通过 &gt;&gt;&gt; from app01 import views&gt;&gt;&gt;form_obj=views.MyForm(&#123;'name':'egon','password':'1234','email':'123@qq.com','hobby':'read'&#125;)&gt;&gt;&gt; form_obj.is_valid()True&gt;&gt;&gt; form_obj.cleaned_data&#123;'name': 'egon', 'password': '1234', 'email': '123@qq.com'&#125;&gt;&gt;&gt; form_obj.errors&#123;&#125; 渲染标签 form组件只帮你渲染获取用户输入的标签(输入框 选择框 下拉框…),不会帮你渲染提交按钮，需要手动添加 form表单取消前端校验功能 &lt;form action=\"\" method=\"post\" novalidate&gt; forms组件当前端输入的信息不合法的时候 页面上的数据保留不会刷新 这样方便用户修改 第一种渲染方式 (可扩展性较差) &lt;h1&gt;第一种渲染方式(可扩展性较差)&lt;/h1&gt; &#123;&#123; form_obj.as_p &#125;&#125; &#123;&#123; form_obj.as_ul &#125;&#125; urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^reg/', views.reg),] views.py from django.shortcuts import render# Create your views here.from django import formsclass MyForm(forms.Form): name = forms.CharField(max_length=6) password = forms.CharField(max_length=8, min_length=3) email = forms.EmailField()def reg(request): # 生成一个空对象 form_obj = MyForm() return render(request, 'reg.html', locals()) index.html &lt;body&gt;&lt;h1&gt;第一种渲染方式&lt;/h1&gt;&#123;&#123; form_obj.as_p &#125;&#125;&lt;/body&gt; 第二种渲染方式 form组件只帮你渲染获取用户输入的标签,不会帮你渲染提交按钮，需要手动添加 如果类名中未指定label名字，则以定义的字段名首字母大写作为lable名字展示到前端 &lt;h1&gt;第二种渲染方式&lt;/h1&gt; &lt;form action=\"\"&gt; &lt;p&gt;&#123;&#123; form_obj.name.label &#125;&#125;&#123;&#123; form_obj.name &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; form_obj.password.label &#125;&#125;&#123;&#123; form_obj.password &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; form_obj.email.label &#125;&#125;&#123;&#123; form_obj.email &#125;&#125;&lt;/p&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^reg/', views.reg),] views.py from django.shortcuts import render# Create your views here.from django import formsclass MyForm(forms.Form): name = forms.CharField(max_length=6,label='用户名') password = forms.CharField(max_length=8, min_length=3) email = forms.EmailField()def reg(request): # 生成一个空对象 form_obj = MyForm() return render(request, 'reg.html', locals()) reg.html &lt;body&gt;&lt;h1&gt;第二种渲染方式&lt;/h1&gt;&lt;form action=\"\"&gt; &lt;p&gt; &#123;&#123; form_obj.name.label &#125;&#125;&#123;&#123; form_obj.name &#125;&#125;&lt;/p&gt; &lt;p&gt; &#123;&#123; form_obj.password.label &#125;&#125;&#123;&#123; form_obj.password &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; form_obj.email.label &#125;&#125;&#123;&#123; form_obj.email &#125;&#125;&lt;/p&gt;&lt;/form&gt;&lt;/body&gt; 第三种渲染方式 &lt;h1&gt;第三种渲染标签的方式&lt;/h1&gt; &lt;form action=\"\"&gt; &#123;% for foo in form_obj %&#125; &lt;p&gt;&#123;&#123; foo.label &#125;&#125;&#123;&#123; foo &#125;&#125;&lt;/p&gt; &#123;% endfor %&#125; &lt;/form&gt; urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^reg/', views.reg),] views.py from django.shortcuts import render# Create your views here.from django import formsclass MyForm(forms.Form): name = forms.CharField(max_length=6,label='用户名') password = forms.CharField(max_length=8, min_length=3) email = forms.EmailField()def reg(request): # 生成一个空对象 form_obj = MyForm() return render(request, 'reg.html', locals()) index.html &lt;body&gt;&lt;h1&gt;第二种渲染方式&lt;/h1&gt;&lt;form action=\"\"&gt; &lt;p&gt; &#123;&#123; form_obj.name.label &#125;&#125;&#123;&#123; form_obj.name &#125;&#125;&lt;/p&gt; &lt;p&gt; &#123;&#123; form_obj.password.label &#125;&#125;&#123;&#123; form_obj.password &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; form_obj.email.label &#125;&#125;&#123;&#123; form_obj.email &#125;&#125;&lt;/p&gt;&lt;/form&gt;&lt;/body&gt; reg.html &lt;body&gt;&lt;h1&gt;第三种渲染方式&lt;/h1&gt;&lt;form action=\"\"&gt; &#123;% for foo in form_obj %&#125; &lt;p&gt;&#123;&#123; foo.label &#125;&#125; &#123;&#123; foo &#125;&#125;&lt;/p&gt; &#123;% endfor %&#125;&lt;/form&gt;&lt;/body&gt; 展示提示信息&#123;% for foo in form_obj %&#125; &lt;p&gt; &#123;&#123; foo.label &#125;&#125;&#123;&#123; foo &#125;&#125; &lt;span&gt;&#123;&#123; foo.errors.0 &#125;&#125;&lt;/span&gt; &lt;/p&gt; &#123;% endfor %&#125; 钩子函数 钩子函数是最后一步校验，前面的校验过了才会由钩子函数进行校验 钩子函数只能操作cleaned_data的数据 widget=widgets.PasswordInput() 设置为密文widget=widgets.PasswordInput(attrs=&#123;'class':'c1 form-control'&#125; 给密码框设置bootstrap样式 局部钩子函数 （单个字段的校验利用局部钩子函数） 全局钩子函数 （多个字段的校验利用全局钩子函数） from django.shortcuts import render, HttpResponse# Create your views here.from django import formsfrom app01 import modelsfrom django.forms import widgets# widget=widgets.PasswordInput() 设置为密文class MyForm(forms.Form): name = forms.CharField(max_length=6, label='用户名', error_messages=&#123; 'max_length': '用户名最长6位', 'required': '用户名不能为空', &#125;) password = forms.CharField(max_length=8, min_length=3, error_messages=&#123; 'max_length': '用户名最长6位', 'required': '用户名不能为空', 'min_length': '密码最少3位' &#125;,widget=widgets.PasswordInput()) confirm_password = forms.CharField(max_length=8, min_length=3, error_messages=&#123; 'max_length': '用户名最长6位', 'required': '用户名不能为空', 'min_length': '密码最少3位' &#125;,widget=widgets.PasswordInput()) email = forms.EmailField(error_messages=&#123; 'invalid': '邮箱格式不正确', 'required': '邮箱不能为空', &#125;) # 钩子函数是最后一步校验，前面的校验过了才会由钩子函数进行校验 # 钩子函数只能操作cleaned_data的数据 # 局部钩子函数 （单个字段的校验利用局部钩子函数） def clean_name(self): name = self.cleaned_data.get('name') if '666' in name: self.add_error('name', '666不行的') return name # 全局钩子函数 def clean(self): print(self.cleaned_data) password=self.cleaned_data.get('password') confirm_password=self.cleaned_data.get('confirm_password') if not password==confirm_password: self.add_error('confirm_password','两次密码不一致') return self.cleaned_datadef reg(request): # 生成一个空对象 form_obj = MyForm() if request.method == 'POST': # &lt;QueryDict: &#123;'name': ['lyysb'], 'password': ['lyysb123'], 'email': ['123@qq.com']&#125;&gt; form_obj = MyForm(request.POST) if form_obj.is_valid(): print(form_obj.cleaned_data) models.User.objects.create(**form_obj.cleaned_data) else: error = form_obj.errors return render(request, 'reg.html', locals()) 设置标签样式from django import forms from django.forms import widgets password = forms.CharField(max_length=8,min_length=3,error_messages=&#123; 'max_length': '密码最长8位', 'required': '密码不能为空', 'min_length':'密码最少3位' &#125;,widget=widgets.PasswordInput(attrs=&#123;'class':'c1 form-control'&#125;)) hobby = forms.ChoiceField( choices=((1, \"篮球\"), (2, \"足球\"), (3, \"双色球\"),), label=\"爱好\", initial=3, widget=forms.widgets.Select() ) hobby1 = forms.MultipleChoiceField( choices=((1, \"篮球\"), (2, \"足球\"), (3, \"双色球\"),), label=\"爱好\", initial=[1, 3], widget=forms.widgets.SelectMultiple() ) keep = forms.ChoiceField( label=\"是否记住密码\", initial=\"checked\", widget=forms.widgets.CheckboxInput() ) 使用form表单实现注册 前端取消校验 &lt;form action=\"\" method=\"post\" novalidate&gt;&lt;/form&gt; form组件提交数据如果数据不合法，页面上会保留之前用户输入的信息在使用form组件对模型表进行数据校验的时候，只需要保证字段一致, 那么在创建的对象的时候你就直接**form_obj.cleaned_data &lt;form action=\"\" method=\"post\" novalidate&gt; &#123;% for foo in form_obj %&#125; &lt;p&gt; &#123;&#123; foo.label &#125;&#125;&#123;&#123; foo &#125;&#125; &lt;span&gt;&#123;&#123; foo.errors.0 &#125;&#125;&lt;/span&gt; &lt;/p&gt; &#123;% endfor %&#125; &lt;input type=\"submit\"&gt; &lt;/form&gt; urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^reg/', views.reg),] views.py from django.shortcuts import render, HttpResponse# Create your views here.from django import formsfrom app01 import modelsfrom django.forms import widgets# widget=widgets.PasswordInput() 设置为密文# widget=widgets.PasswordInput(attrs=&#123;'class':'c1 form-control'&#125; 给密码框设置bootstrap样式class MyForm(forms.Form): name = forms.CharField(max_length=6, label='用户名', error_messages=&#123; 'max_length': '用户名最长6位', 'required': '用户名不能为空', &#125;) password = forms.CharField(max_length=8, min_length=3, error_messages=&#123; 'max_length': '用户名最长6位', 'required': '用户名不能为空', 'min_length': '密码最少3位' &#125;,widget=widgets.PasswordInput()) confirm_password = forms.CharField(max_length=8, min_length=3, error_messages=&#123; 'max_length': '用户名最长6位', 'required': '用户名不能为空', 'min_length': '密码最少3位' &#125;,widget=widgets.PasswordInput(attrs=&#123;'class':'c1 form-control'&#125;)) email = forms.EmailField(error_messages=&#123; 'invalid': '邮箱格式不正确', 'required': '邮箱不能为空', &#125;) # 钩子函数是最后一步校验，前面的校验过了才会由钩子函数进行校验 # 钩子函数只能操作cleaned_data的数据 # 局部钩子函数 （单个字段的校验利用局部钩子函数） def clean_name(self): name = self.cleaned_data.get('name') if '666' in name: self.add_error('name', '666不行的') return name # 全局钩子函数 def clean(self): print(self.cleaned_data) password=self.cleaned_data.get('password') confirm_password=self.cleaned_data.get('confirm_password') if not password==confirm_password: self.add_error('confirm_password','两次密码不一致') return self.cleaned_datadef reg(request): # 生成一个空对象 form_obj = MyForm() if request.method == 'POST': # &lt;QueryDict: &#123;'name': ['lyysb'], 'password': ['lyysb123'], 'email': ['123@qq.com']&#125;&gt; form_obj = MyForm(request.POST) if form_obj.is_valid(): print(form_obj.cleaned_data) models.User.objects.create(**form_obj.cleaned_data) else: error = form_obj.errors return render(request, 'reg.html', locals()) models.py from django.db import models# Create your models here.class User(models.Model): name=models.CharField(max_length=32) password=models.CharField(max_length=32) email=models.EmailField() 执行manager.py创建表 菜单-tools-Run manager.py Task$ makemigrations$ migrate reg.html &lt;body&gt;&lt;h1&gt;第三种渲染方式&lt;/h1&gt;&lt;form action=\"\" method=\"post\" novalidate&gt; &#123;% for foo in form_obj %&#125; &lt;p&gt;&#123;&#123; foo.label &#125;&#125; &#123;&#123; foo &#125;&#125;&lt;span&gt;&#123;&#123; foo.errors.0 &#125;&#125;&lt;/span&gt;&lt;/p&gt; &#123;% endfor %&#125; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt; 浏览器测试，最后去数据库查看结果 查看钩子函数是否生效","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"前端","slug":"前端","permalink":"http://cjwnb.top/tags/前端/"}]},{"title":"批量插入数据以及分页","slug":"批量插入数据以及分页","date":"2019-07-21T12:05:35.163Z","updated":"2019-07-21T12:06:01.819Z","comments":true,"path":"2019/07/21/批量插入数据以及分页/","link":"","permalink":"http://cjwnb.top/2019/07/21/批量插入数据以及分页/","excerpt":"","text":"批量插入数据l = [] for i in range(10000): l.append(models.Book2(name='第%s本书'%i)) models.Book2.objects.bulk_create(l) # 批量插入数据 urls.py rom django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^booklist/', views.book_list),] views.py from app01 import modelsdef book_list(request): # 动态插入100000条数据 l=[] for i in range(10000): l.append(models.Book2(name=\"第%s本书\"%i)) models.Book2.objects.bulk_create(l) # 查询所有的书籍展示到前端页面 book_list=models.Book2.objects.all() return render(request,'booklist.html',locals()) models.py from django.db import modelsclass Book2(models.Model): name=models.CharField(max_length=64) 执行manage.py命令创建表 菜单-tools-Run manager.py Task$ makemigrations$ migrate booklist.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;link href=\"https://cdn.bootcss.com/twitter-bootstrap/3.4.1/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;script src=\"https://cdn.bootcss.com/twitter-bootstrap/3.4.1/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-8 col-md-offset-2\"&gt; &lt;table class=\"table table-hover table-bordered table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for book in book_list %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; book.pk &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; book.name &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 分页 导入模块 from django.core.paginator import Paginator,EmptyPage Paginator 实现分页功能，跳转到那一页默认情况下需要通过浏览器手动输入 EmptyPage: 跳转到那一页默认情况下需要通过浏览器手动输入，如果输入的页数是负数或者超出范围就会有一场场EmptyPage，主要用作捕获异常 版本1urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index/', views.index),] models.py from django.db import models# Create your models here.class Book(models.Model): title = models.CharField(max_length=32) price = models.DecimalField(decimal_places=2, max_digits=8) def __str__(self): return '对象：%s'%self.title views.py from django.shortcuts import render, HttpResponse# Create your views here.from .models import Bookfrom django.core.paginator import Paginator,EmptyPagedef index(request): # book_list = [] # for i in range(100): # book = Book(title='book_%s' % i, price=i * i) # book_list.append(book) # Book.objects.bulk_create(book_list) booklist=Book.objects.all() # 分页器 paginator=Paginator(booklist,106) print(paginator.count) # 数据总数 print(paginator.num_pages) # 总页数 print(paginator.page_range) #页码的列表 page_range=paginator.page_range try: current_pag=int(request.GET.get('page',1)) page1=paginator.page(current_pag) # 第一页数据的对象列表 # 显示某一页具体数据的两种方式: print(page1.object_list) # &lt;QuerySet[ &lt; Book: 对象：book_0 &gt;, &lt; Book: 对象：book_1 &gt;, &lt; Book: 对象：book_2 &gt;, &lt; Book: 对象：book_3 &gt;, &lt; Book: 对象：book_4 &gt;] &gt; for i in page1: print(i) # 对象：book_0 # 对象：book_1 # 对象：book_2 # 对象：book_3 # 对象：book_4 except EmptyPage as e: page1=paginator.page(1) return render(request, 'index.html', &#123;'page': page1,'page_range':page_range,'current_page':current_pag&#125;) bootstrap中文网找到一个分页的样式 https://v3.bootcss.com/components/#pagination放入index.html，用户通过点击页码，就能跳转到页面 index.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;link href=\"https://cdn.bootcss.com/twitter-bootstrap/3.4.1/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;script src=\"https://cdn.bootcss.com/twitter-bootstrap/3.4.1/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-8 col-md-offset-2\"&gt; &lt;table class=\"table table-hover table-bordered table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;title&lt;/th&gt; &lt;th&gt;price&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for book in page %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; book.pk &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; book.title &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; book.price &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; &lt;nav aria-label=\"Page navigation\"&gt; &lt;ul class=\"pagination\"&gt; &lt;li&gt; &lt;a href=\"?page=&#123;&#123; current_page|add:-1 &#125;&#125;\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;上一页&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &#123;% for item in page_range %&#125; &#123;% if current_page == item %&#125; &lt;li class=\"active\"&gt;&lt;a href=\"?page=&#123;&#123; item &#125;&#125;\"&gt;&#123;&#123; item &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% else %&#125; &lt;li&gt;&lt;a href=\"?page=&#123;&#123; item &#125;&#125;\"&gt;&#123;&#123; item &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;li&gt; &lt;a href=\"?page=&#123;&#123; current_page|add:1&#125;&#125;\" aria-label=\"Next\"&gt; &lt;span aria-hidden=\"true\"&gt;下一页&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt;&lt;/body&gt;&lt;/html&gt; 最终版本urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index/', views.index),] views.py from django.shortcuts import render, HttpResponse# Create your views here.from .models import Bookfrom django.core.paginator import Paginator, EmptyPagedef index(request): # book_list = [] # for i in range(100): # book = Book(title='book_%s' % i, price=i * i) # book_list.append(book) # Book.objects.bulk_create(book_list) booklist = Book.objects.all() # 分页器 paginator = Paginator(booklist, 60) # 分页，每一页106条数据对象 print(paginator.count) # 数据总数 print(paginator.num_pages) # 总页数 print(paginator.page_range) # 页码的列表 last_page=paginator.page_range[-1] current_pag = int(request.GET.get('page', 1)) if paginator.num_pages &gt; 11: if current_pag - 5 &lt; 1: page_range = range(1, 12) elif current_pag + 5 &gt; paginator.num_pages: page_range = range(paginator.num_pages - 11, paginator.num_pages + 1) else: page_range = range(current_pag - 5, current_pag + 6) else: page_range = paginator.page_range try: page1 = paginator.page(current_pag) # 某一页数据的对象列表 print(page1.has_next) # page1这一页是否有下一页 print(page1.next_page_number) # # page1这一页的下一页的页码 print(page1.has_previous) # page1这一页是否有上一页 print(page1.previous_page_number) #page1这一页的上一页的代码 # 显示某一页具体数据的两种方式: print(page1.object_list) # &lt;QuerySet[ &lt; Book: 对象：book_0 &gt;, &lt; Book: 对象：book_1 &gt;, &lt; Book: 对象：book_2 &gt;, &lt; Book: 对象：book_3 &gt;, &lt; Book: 对象：book_4 &gt;] &gt; for i in page1: print(i) # 对象：book_0 # 对象：book_1 # 对象：book_2 # 对象：book_3 # 对象：book_4 except EmptyPage as e: page1 = paginator.page(1) return render(request, 'index.html', &#123;'page': page1, 'page_range': page_range, 'current_page': current_pag,'last_page':last_page&#125;) models.py from django.db import modelsclass Book2(models.Model): name=models.CharField(max_length=64) 执行manage.py命令创建表 菜单-tools-Run manager.py Task$ makemigrations$ migrate index.html bootstap不会提示的问题，解决方案是在本地导入bootstrap文件 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\"&gt; &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap-theme.min.css\" integrity=\"sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp\" crossorigin=\"anonymous\"&gt; &lt;script src=\"https://cdn.bootcss.com/twitter-bootstrap/3.4.1/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-8 col-md-offset-2\"&gt; &lt;table class=\"table table-hover table-bordered table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;title&lt;/th&gt; &lt;th&gt;price&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for book in page %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; book.pk &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; book.title &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; book.price &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-8 col-md-offset-2\"&gt; &lt;nav aria-label=\"Page navigation\"&gt; &lt;ul class=\"pagination center line-block\"&gt; &lt;li&gt; &lt;a href=\"?page=1\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;第一页&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &#123;% if page.has_previous %&#125; &lt;li&gt; &lt;a href=\"?page=&#123;&#123; page.previous_page_number &#125;&#125;\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;上一页&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &#123;% else %&#125; &lt;li&gt; &lt;span aria-hidden=\"true\"&gt;上一页&lt;/span&gt; &lt;/li&gt; &#123;% endif %&#125; &#123;% for item in page_range %&#125; &#123;% if current_page == item %&#125; &lt;li class=\"active\"&gt;&lt;a href=\"?page=&#123;&#123; item &#125;&#125;\"&gt;&#123;&#123; item &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% else %&#125; &lt;li class=\"disabled\"&gt;&lt;a href=\"?page=&#123;&#123; item &#125;&#125;\"&gt;&#123;&#123; item &#125;&#125;&lt;/a&gt;&lt;/li&gt; &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% if page.has_next %&#125; &lt;li&gt; &lt;a href=\"?page=&#123;&#123; page.next_page_number &#125;&#125;\" aria-label=\"Next\"&gt; &lt;span aria-hidden=\"true\"&gt;下一页&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &#123;% else %&#125; &lt;li class=\"disabled\"&gt; &lt;span aria-hidden=\"true\"&gt;下一页&lt;/span&gt; &lt;/li&gt; &#123;% endif %&#125; &lt;li&gt; &lt;a href=\"?page=&#123;&#123; last_page &#125;&#125;\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;最后一页&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"ORM","slug":"ORM","permalink":"http://cjwnb.top/tags/ORM/"},{"name":"前端","slug":"前端","permalink":"http://cjwnb.top/tags/前端/"}]},{"title":"ORM之查询","slug":"ORM之查询","date":"2019-07-20T13:56:26.691Z","updated":"2019-07-31T02:26:42.360Z","comments":true,"path":"2019/07/20/ORM之查询/","link":"","permalink":"http://cjwnb.top/2019/07/20/ORM之查询/","excerpt":"","text":"正向与反向查询一对一 正向：author—关联字段在author表里—&gt;authordetail 按字段 反向：authordetail—关联字段在author表里—&gt;author 按表名小写 查询egon作者的手机号 正向查询 查询地址是 :北京市昌平区海定校区11号 的作者名字 反向查询 一对多 正向：book—关联字段在book表里—&gt;publish 按字段 反向：publish—关联字段在book表里—&gt;book 按表名小写_set.all() 因为一个出版社对应着多个图书 多对多 正向：book—关联字段在book表里—&gt;author 按字段 反向：author—关联字段在book表里—&gt;book 按表名小写_set.all() 因为一个作者对应着多个图 基于对象的跨表查询 查询书籍是三国演义的出版社的邮箱（一对多.正向查询） book_obj=models.Book.objects.filter(pk=11).first()# 一本书只会被一个出版社出版，所以直接调用和publish表的字段就可以拿到这本书所关联的出版社的那个数据对象 print(book_obj.publish) # 出版社对象的名字 空军军医大学 print(book_obj.publish.email) # 222222@163.com 查询书籍是python开发的作者姓名（多对多.正向查询） book_obj=models.Book.objects.filter(title='python开发').first()# 一本书可以被多个作者出版，所以直接调用和author表关联的字段返回就是None，调用all()方法拿到全部作者信息 print(book_obj.author) # app01.Author.None print(book_obj.author.all()) # &lt;QuerySet [&lt;Author: 作者对象的名字 egon&gt;, &lt;Author: 作者对象的名字 lyysb&gt;, &lt;Author: 作者对象的名字 szksb&gt;, &lt;Author: 作者对象的名字 lxxsb&gt;]&gt; author_name=[] for author in book_obj.author.all(): author_name.append(author.name) print(author_name) 查询作者为egon的电话号码(一对一.正向查询) user_obj=models.Author.objects.filter(name='egon').first()print(user_obj.authordetail.phone) 基于对象的反向查询， 除了一对一直接表名小写就可以拿到关联对象一对多，多对多反向查询必须 表名_set.all() 查询出版社是华中师范大学出版社的书籍(一对多，反向查询，需要加_set) publish_obj=models.Publish.objects.filter(name='华中师范大学出版社').first()# AttributeError: '报错 Publish' object has no attribute 'book'# 因为publish表中并没有字段book,这个时候就要加上_set获得publish_obj关联的book对象# print(publish_obj.book)# print(publish_obj.book_set) #app01.Book.None, 因为这个publish_obj这个对象关联多本书，所以返回None，加上all()print(publish_obj.book_set.all()) # 获得了publish_obj这个对象关联的所有的book表中的对象book_list=[]for book in publish_obj.book_set.all(): book_list.append(book.title)print(book_list) 查询作者电话号码是87665454445的作者姓名(一对一反向查询，不需要加_set) authordetail_obj=models.Authordetail.objects.filter(phone='87665454445').first()print(authordetail_obj.author) 查询作者egon写过的所有的书(多对多反向查询，需要加_set) author_obj=models.Author.objects.filter(name='egon').first()book_list=[]for book in author_obj.book_set.all(): book_list.append(book.title)print(book_list) 基于双下划线的跨表查询正向查询 查询书籍为三国演义的出版社地址,并打印名字 res=models.Book.objects.filter(title='三国演义').values('publish__addr','title')print(res.first()) # &#123;'publish__addr': '西安市长乐西路17号', 'title': '三国演义'&#125;print(res.first().get('publish__addr'))print(res.first().get('titile')) 查询书籍为docker入门的作者的姓名 res=models.Book.objects.filter(title='docker入门').values('author__name')print(res.first()) # &#123;'author__name': 'egon'&#125;print(res.first().get('author__name')) 查询作者为egon的地址 res=models.Author.objects.filter(name='egon').values('authordetail__addr')print(res.first().get('authordetail__addr')) 查询华中师范大学出版社的价格大于50的书 res=models.Publish.objects.filter(name='华中师范大学出版社',book__price__gt=50).values_list('book__title','book__price')book_list=[]for book in res: book_list.append(book[0])print(book_list) 反向查询 查询华中师范大学出版社出版的书的名字 publish_obj=models.Publish.objects.filter(name='华中师范大学出版社').values_list('book__title')# &lt;QuerySet [('python开发',), ('docker入门',), ('web集群',), ('红楼梦',), ('红楼梦',), ('红楼梦',)]&gt;book_list=[]for book_name in publish_obj: book_list.append(book_name[0])print(book_list) 查询电话号码为23456321234 的作者姓名 author_detail=models.Authordetail.objects.filter(phone='23456321234').values('author__name')print(author_detail.first().get('author__name')) 查询作者为egon写过的书的名字 author_object=models.Author.objects.filter(name='egon').values_list('book__title') book_list=[] for book in author_object: book_list.append(book[0]) print(book_list) 查询书籍docker入门的作者的电话号码 book_obj=models.Book.objects.filter(title='docker入门').values('author__authordetail__phone')print(book_obj.first().get('author__authordetail__phone')) 查询egon作者的手机号 res=models.Authordetail.objects.filter(author__name='egon').values('phone')print(res.first().get('phone')) 查询出版社为 北京大学出版社的图书的名字和价格 res=models.Book.objects.filter(publish__name='北京大学出版社').values_list('title','price') print(res.first()[0],res.first()[1]) 查询华中师范大学出版社的价格大于50的书 res=models.Book.objects.filter(publish__name='华中师范大学出版社',price__gt=50).values_list('title')book_list=[]for book in res: book_list.append(book[0])print(book_list) 聚合查询 aggregate()实现 就是实现mysql里的聚合函数功能 导入模块 from django.db.models import Max,Min,Count,Avg 查询python开发这本书籍对应的作者个数 from django.db.models import Max,Min,Count,Avgres = models.Book.objects.filter(pk=3).aggregate(count_num=Count('author')) print(res) 查询所有出版社的平均价格 from django.db.models import Max,Min,Count,Avg res = models.Publish.objects.aggregate(avg_price=Avg('book__price')) print(res) 分组查询annotate()实现 统计每本书的作者个数 res=models.Book.objects.annotate(count_num=Count('author')).values('title','count_num') print(res) 统计出每个出版社卖的最便宜的书的价格 res = models.Publish.objects.annotate(min_num=Min('book__price')).values('name','min_num')print(res) 查询各个作者的书的总价格 res=models.Author.objects.annotate(sum_price=Sum('book__price')).values('name','sum_price')print(res)","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"ORM","slug":"ORM","permalink":"http://cjwnb.top/tags/ORM/"}]},{"title":"ajax","slug":"ajax","date":"2019-07-20T13:35:03.598Z","updated":"2019-07-22T02:47:04.006Z","comments":true,"path":"2019/07/20/ajax/","link":"","permalink":"http://cjwnb.top/2019/07/20/ajax/","excerpt":"","text":"编码格式contenttype urlencoded 对应的数据格式:name=jason&amp;password=666后端获取数据:request.POSTps；django会将urlencoded编码的数据解析自动放到request.POST index.html &lt;body&gt;&lt;form action=\"\" method=\"post\"&gt; &lt;input type=\"text\" name=\"name\"&gt; &lt;input type=\"text\" name=\"password\"&gt; &lt;input type=\"file\" name=\"file\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt; urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index/', views.index),] views.py from django.shortcuts import renderdef index(request): print(request.POST) return render(request,'index.html') 浏览器测试查看结果,查看到默认编码是application/x-www-form-urlencoded,并且post多个数据之间用&amp;传递 查看request.POST的输出，是以字典的形式输出，上传的文件的值最后接收到的是一个文件名 formdata form表单传输文件的编码格式 后端获取文件格式数据:request.FILES 后端获取普通键值对数据:request.POST index.html &lt;form action=\"\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"text\" name=\"name\"&gt; &lt;input type=\"text\" name=\"password\"&gt; &lt;input type=\"file\" name=\"file\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index/', views.index),] views.py from django.shortcuts import renderdef index(request): print(request.FILES) print(request.POST) return render(request,'index.html') 浏览器上查看到编码方式换成了multipart/form-data 查看request.POST,request.FILES的输出 application/json ajax发送json格式数据 需要注意的点: 编码与数据格式要一致 AJAX简介向服务器发送请求的途径 浏览器地址栏，默认get请求 form表单 get请求 post请求 a 标签 AJAX 特点：1. 异步请求 AJAX 使用Javascript技术向服务器发送异步请求2. 局部刷新 AJAX无需刷新整个页面 基本语法提交的地址(url) 提交的方式(type) 提交的数据(data) 回调函数(success) $('#d1').click(function () &#123; $.ajax(&#123; // 提交的地址 url:'/index/', // 提交的方式 type:'post', // 提交的数据 data:&#123;'name':'jason','password':'123'&#125;, // 回调函数 success:function (data) &#123; // data接收的就是异步提交返回的结果 alert(data) &#125; &#125;) &#125;) ###前端 通过ajax发送数据 test.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;this is index！&lt;/h2&gt;&lt;button class=\"Ajax\"&gt;Ajax&lt;/button&gt;&lt;p class=\"content\"&gt;&lt;/p&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script&gt; $(\".Ajax\").click(function () &#123; // 发送ajax请求 $.ajax(&#123; url:\"/test_ajax/\", //请求url type:\"get\", //请求方式get/post data:&#123;a:1,b:2&#125;, //请求的数据 success:function (data) &#123; //回调函数 console.log(data); $(\".content\").html(data); &#125; &#125;) &#125;)&lt;/script&gt;&lt;/html 后端反馈数据给前端中的ajax中的data字段 ####创建视图函数 views.py from django.shortcuts import render, HttpResponsedef index(request): return render(request, \"index.html\")def test_ajax(request): print(request.GET) return HttpResponse('hello world') 绑定视图函数url.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index/', views.index), url(r'^test_ajax/', views.test_ajax),] 客户端效果####未点击Ajax按钮的状态 点击Ajax按钮的状态 实现计算器效果 前端写ajax请求test.html 通过ajax发送请求,如果使用ajax发送请求到后端，请求数据是以键值对的方式发送给后端，并不需要在input标签中指定name属性，而如果是通过form表单进行发送，是需要指定的 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"text\" id=\"num1\"&gt;+&lt;input type=\"text\" id=\"num2\"&gt;=&lt;input type=\"text\" class=\"ret\"&gt;&lt;button class=\"cal\"&gt;计算&lt;/button&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script&gt; //计算求值 $(\".cal\").click(function () &#123; $.ajax(&#123; url: \"/cal/\", type: \"post\", //&lt;input type=\"text\" id=\"num1\"&gt;+&lt;input type=\"text\" id=\"num2\"&gt; //不需要有name,只需要找到标签,通过id或class就行 //data 前端向后端发送的数据 data: &#123; n1:$(\"#num1\").val(), n2:$(\"#num2\").val(), &#125;, //success 对后端给前端反馈的数据进行处理反馈到浏览器 success:function (data) &#123; $(\".ret\").val(data) &#125; &#125;) &#125;) &lt;/script&gt;&lt;/html&gt; 创建视图函数views.py from django.shortcuts import render, HttpResponsedef cal(request): print(request.POST) n1 = request.POST.get('n1') n2 = request.POST.get('n2') ret = int(n1) + int(n2) return HttpResponse(ret) 绑定视图函数urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index/', views.index), url(r'^test_ajax/', views.test_ajax), url(r'^cal/', views.cal),] 报错信息报错1Uncaught TypeError 原因： 前端部分 在发送ajax请求时候未取到表单输入的值,找到标签后没有加 .val取值 data: &#123; n1:$(\"#num1\"), n2:$(\"#num2\"), &#125;,# 正确写法：data: &#123; n1:$(\"#num1\").val(), n2:$(\"#num2\").val(), &#125;, 报错2Uncaught ReferenceError 原因：ajax没有接受后台传送的值 $(\".cal\").click(function () &#123; $.ajax(&#123; type: 'post', url: '/cal/', data: &#123;n1: $('.n1').val(), n2: $('.n2').val()&#125;, success: function () &#123; $('.ret').val(data); &#125; &#125;) &#125;)# 正确写法 $(\".cal\").click(function () &#123; $.ajax(&#123; type: 'post', url: '/cal/', data: &#123;n1: $('.n1').val(), n2: $('.n2').val()&#125;, success: function (data) &#123; $('.ret').val(data); &#125; &#125;) &#125;) 报错3Failed to load resource: the server responded with a status of 500 (Internal Server Error) 原因: 视图函数未返回http协议的数据 def cal(request): n1 = request.POST.get('n1') n2 = request.POST.get('n2') ret = int(n1) + int(n2) return ret# 正确写法def cal(request): n1 = request.POST.get('n1') n2 = request.POST.get('n2') ret = int(n1) + int(n2) return HttpResponse(ret) 基于AJAX的登录验证index.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"\"&gt; 用户名 &lt;input type=\"text\" class=\"user\"&gt; 密码 &lt;input type=\"password\" class=\"pwd\"&gt; &lt;input type=\"button\" value=\"submit\" class=\"login-btn\"&gt; &lt;span class=\"error\"&gt;&lt;/span&gt;&lt;/form&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script&gt;$('.login-btn').click(function () &#123; $.ajax(&#123; url:\"/login/\", type:\"post\", data:&#123; user:$(\".user\").val(), pwd:$(\".pwd\").val(), &#125;, success:function (data) &#123; console.log(data); //json字符串 console.log(typeof data); //string var return_data=JSON.parse(data); //把json字符串解析成object console.log(return_data); // &#123;'user':'lyysb','msg':None&#125; console.log(typeof return_data); //object // 判断,前端把接收到的数据转换成原来的格式 &#123;'user':'lyysb','msg':None&#125; // 后台返回的数据,如果数据数据库中有用户，则返回 &#123;'user':'lyysb','msg':None&#125;,user属性不为空 // 如果数据库中没有，则返回 &#123;'user':None,'msg':'用户名或密码错误'&#125;，msg属性不为空 // 如果数据中有user属性，则跳转 // 如果没有，则插入一条错误数据，错误数据从return_data的msg属性取值 if (return_data.user)&#123; location.href=\"http://www.cjwnb.top\" &#125; else &#123; // .html 在标签内插入文本内容，.css 为标签设置css样式 $(\".error\").html(return_data.msg).css(&#123;\"color\":\"red\",\"margin-left\":0&#125;) &#125; &#125; &#125;)&#125;)&lt;/script&gt;&lt;/html&gt; urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index/', views.index), url(r'^login/', views.login),] views.py from django.shortcuts import render, HttpResponsedef login(request): if request.method == 'POST': user = request.POST.get('user') pwd = request.POST.get('pwd') obj = User.objects.filter(name=user, pwd=pwd).first() res = &#123;'user': None, 'msg': None&#125; if obj: res['user'] = obj.name else: res['msg'] = '用户名或密码错误' import json return HttpResponse(json.dumps(res, ensure_ascii=False)) models.py from django.db import modelsclass User(models.Model): name=models.CharField(max_length=32) pwd=models.CharField(max_length=32) 随意插入几条数据 浏览器测试结果 失败的结果 成功则跳转到网页 AJAX传递JSON文件请求体中的格式不再是a=1&amp;b=2，而是一个json格式 $('.标签类名').click(function () &#123; $.ajax(&#123; url:\"\", type:\"post\", contentType:\"application/json\", // 将数据序列化成json字符串 data:JSON.stringify(&#123; a:1, b:2 &#125;), success:function (data) &#123; console.log(data) &#125; &#125; ) &#125;) test.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;基于form表单的文件上传&lt;/title&gt;&lt;/head&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;body&gt;&lt;form action=\"\" method=\"post\"&gt; 用户名 &lt;input type=\"text\" name=\"user\"&gt; &lt;input type=\"button\" class=\"btn\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;script&gt; $('.btn').click(function () &#123; $.ajax(&#123; url:\"\", type:\"post\", contentType:\"application/json\", // 将数据序列化成json字符串 data:JSON.stringify(&#123; a:1, b:2 &#125;), success:function (data) &#123; console.log(data) &#125; &#125; ) &#125;)&lt;/script&gt;&lt;/html&gt; urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^file_put/', views.file_put),] views.py def file_put(request): if request.method == 'POST': print('post',request.POST) #只有contentType=urlencoded, request.POST才有数据 # post &lt;QueryDict: &#123;&#125;&gt; print('body',request.body) # 请求报文中的请求体 # body b'&#123;\"a\":1,\"b\":2&#125;' return HttpResponse('OK') return render(request, 'file_put.html') 查看到请求体中的数据是json格式的字符串 传输文件复习基于form表单的文件上传file_put.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;基于form表单的文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;基于form表单的文件上传&lt;/h3&gt;&lt;form action=\"\" method=\"post\" enctype=\"multipart/form-data\"&gt; 用户名 &lt;input type=\"text\" name=\"user\"&gt; 头像 &lt;input type=\"file\" name=\"avatar\" class=\"avatar\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^file_put/', views.file_put),] views.py def file_put(request): if request.method == 'POST': print(request.POST) # &lt;QueryDict: &#123;'user': ['changwei']&#125;&gt; print(request.FILES) file=request.FILES # &lt;MultiValueDict: &#123;'avatar': [&lt;InMemoryUploadedFile: timg (3).jpeg (image/jpeg)&gt;]&#125;&gt; file_obj=file.get('avatar') with open(file_obj.name,'wb') as f: for line in file_obj: f.write(line) return HttpResponse('OK') return render(request, 'file_put.html') 基于ajax的文件上传利用js代码找到我们要上传的文件test.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;test&lt;/title&gt; &lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"\" method=\"post\"&gt; 用户名 &lt;input type=\"text\" name=\"user\"&gt; 头像 &lt;input type=\"file\" name=\"avatar\" class=\"avatar\"&gt; &lt;input type=\"button\" class=\"btn\" value=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 浏览器console窗口 $(\".avatar\")[0] # 拿到类名是avatar的标签$(\".avatar\")[0].files[0] # 取到标签内的文件对象 file_input.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;基于ajax的文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;基于ajax的文件上传&lt;/h3&gt;&lt;form action=\"\" method=\"post\"&gt; 用户名 &lt;input type=\"text\" id=\"user\"&gt; 头像 &lt;input type=\"file\" id=\"avatar\"&gt; &lt;input type=\"button\" id=\"btn\" value=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt; $(\"#btn\").click(function () &#123; var formdata = new FormData(); formdata.append(\"user\", $(\"#user\").val()); console.log(formdata); formdata.append(\"avatar\", $(\"#avatar\")[0].files[0]); console.log(formdata); $.ajax(&#123; url: \"\", type: \"post\", contentType: false, processData: false, data: formdata, success: function (data) &#123; console.log(data) &#125; &#125;) &#125;)&lt;/script&gt;&lt;/html&gt; urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^file_put/', views.file_put),] views.py def file_put(request): print(request.method) if request.method == 'POST': print('body', request.body) print('post',request.POST) print('files',request.FILES) file_obj=request.FILES.get('avatar') with open(file_obj.name,'wb') as f: for line in file_obj: f.write(line) return HttpResponse('OK') return render(request, 'file_put.html') 坑点在上述请求中，视图函数views.py中，如果想要看请求体的内容（request.body），又想看POST请求的内容(request.POST)，那么必须将请求体的打印信息写在POST请求之前 报错代码 def file_put(request): print(request.method) if request.method == 'POST': print('post',request.POST) print('body', request.body) print('files',request.FILES) file_obj=request.FILES.get('avatar') with open(file_obj.name,'wb') as f: for line in file_obj: f.write(line) return HttpResponse('OK') return render(request, 'file_put.html') 报错信息 django.http.request.RawPostDataException: You cannot access body after reading from request’s data stream","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"前后台交互","slug":"前后台交互","permalink":"http://cjwnb.top/tags/前后台交互/"},{"name":"AJAX","slug":"AJAX","permalink":"http://cjwnb.top/tags/AJAX/"}]},{"title":"多对多表的创建方式以及分页","slug":"多对多表的三种创建方式","date":"2019-07-20T13:21:22.402Z","updated":"2019-07-21T12:04:53.105Z","comments":true,"path":"2019/07/20/多对多表的三种创建方式/","link":"","permalink":"http://cjwnb.top/2019/07/20/多对多表的三种创建方式/","excerpt":"","text":"多对多表三种创建方式第一种django orm自动创建 class Book(models.Model): name = models.CharField(max_length=32) authors = models.ManyToManyField(to='Author')class Author(models.Model): name = models.CharField(max_length=32) 第二种手动创建第三张表 class Book(models.Model): name = models.CharField(max_length=32) class Author(models.Model): name = models.CharField(max_length=32) class Book2Author(models.Model): book = models.ForeignKey(to='Book') author = models.ForeignKey(to='Author') info = models.CharField(max_length=32) 第三种半自动创建第三张表(可扩展性高，并且能够符合orm查询) class Book(models.Model): name = models.CharField(max_length=32) # 第三种创建表的方式 authors = models.ManyToManyField(to='Author',through='Book2Author',through_fields=('book','author'))class Author(models.Model): name = models.CharField(max_length=32) book = models.ManyToManyField(to='Book',through='Book2Author',through_fields=('author','book'))class Book2Author(models.Model): book = models.ForeignKey(to='Book') author = models.ForeignKey(to='Author') info = models.CharField(max_length=32) 案例 查询书籍对应的作者 ​ models.py from django.db import models# Create your models here.class Book(models.Model): name = models.CharField(max_length=32) authors=models.ManyToManyField(to='Author',through='Book2Author',through_fields=('book','author'))class Author(models.Model): name = models.CharField(max_length=32)class Book2Author(models.Model): book = models.ForeignKey(to='Book') author = models.ForeignKey(to='Author') info=models.CharField(max_length=64) tests.py import osif __name__ == \"__main__\": os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"ajax.settings\") import django django.setup() from app01 import models res=models.Book.objects.filter(pk=1).values('authors__name') print(res) # &lt;QuerySet [&#123;'authors__name': 'lyysb'&#125;, &#123;'authors__name': 'hhpsb'&#125;]&gt; book_obj=models.Book.objects.filter(pk=1).first() res=book_obj.authors.all() print(res)","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"ORM","slug":"ORM","permalink":"http://cjwnb.top/tags/ORM/"},{"name":"模型层","slug":"模型层","permalink":"http://cjwnb.top/tags/模型层/"}]},{"title":"F查询和Q查询，事务及其他","slug":"F查询和Q查询，事务及其他","date":"2019-07-20T06:19:22.020Z","updated":"2019-07-22T01:22:52.723Z","comments":true,"path":"2019/07/20/F查询和Q查询，事务及其他/","link":"","permalink":"http://cjwnb.top/2019/07/20/F查询和Q查询，事务及其他/","excerpt":"","text":"更多资料： https://www.cnblogs.com/Dominic-Ji/p/9213887.html F与Q查询在上面所有的例子中，我们构造的过滤器都只是将字段值与某个我们自己设定的常量做比较。如果我们要对两个字段的值做比较，那该怎么做呢？ Django 提供 F() 来做这样的比较。F() 的实例可以在查询中引用字段，来比较同一个 model 实例中两个不同字段的值。 settings.py MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',]DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'ORM2', 'PORT': 3306, 'HOST': '127.0.0.1', 'USER': 'root', 'PASSWORD': 123 &#125;&#125; init.py import pymysqlpymysql.install_as_MySQLdb() models.py from django.db import models# Create your models here.class Product(models.Model): name = models.CharField(max_length=32) price = models.DecimalField(max_digits=8, decimal_places=2) maichu = models.IntegerField() kucun = models.IntegerField() def __str__(self): return '对象的名字：%s'%self.name 执行命令创建表 pycharm菜单-tools-run manage.py TASK$ makemigrations$ migrate tests.py from django.test import TestCase# Create your tests here.import osif __name__ == \"__main__\": os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"ORM2.settings\") import django django.setup() from app01 import models 初始数据 F查询 查询卖出数大于库存数的商品 from django.db.models import F,Q # F查询 给一个字段就能拿到字段的值 res=models.Product.objects.filter(maichu__gt=F('kucun')) print(res) 将所有商品的价格提高100块 models.Product.objects.update(price=F('price')+100) 将所有商品的名字后面都加上一个爆款 from django.db.models.functions import Concat from django.db.models import Value models.Product.objects.update(name=Concat(F('name'),Value('爆款'))) Q查询 查询价格是288.88并且名字是衣服同款爆款的商品 与查询 from django.db.models import Q from django.db.models import Q res = models.Product.objects.filter(Q(price='288.88'),Q(name='衣服爆款')) # 这里 第一个Q参数后面必须是传字符串，如果传数字（Q(price=288.88)），无法查询出对象 print(res) 或查询 查询价格是288.88或者名字是帽子同款爆款的商品 from django.db.models import Qres = models.Product.objects.filter(Q(price='288.88') | Q(name='裤子爆款')) # or print(res) # &lt;QuerySet [&lt;Product: 对象的名字：衣服爆款&gt;, &lt;Product: 对象的名字：裤子爆款&gt;]&gt; 混合使用 需要注意的是Q对象必须放在普通的过滤条件前面 查询价格不是288.88并且名字是裤子爆款的商品 res=models.Product.objects.filter(~Q(price='288.88'),Q(name='裤子爆款'))print(res) 查询价格不是288.88或者名字是裤子爆款的商品 res=models.Product.objects.filter(Q(name='裤子爆款')|~Q(price='288.88'))print(res) Q对象补充Q的源码 class Q(tree.Node): \"\"\" Encapsulates filters as objects that can then be combined logically (using `&amp;` and `|`). \"\"\" # Connection types AND = 'AND' OR = 'OR' default = AND def __init__(self, *args, **kwargs): super(Q, self).__init__(children=list(args) + list(kwargs.items() Q本身就是一个类，实例化一个对象，将所有的条件传入children这个属性中，而children这个属性是是列表，将条件写成一个小元组的方式作为一个整体传入children这个列表，小元组的第一个元素是字段名，第二个元素是写希望字段名符合的条件 例如 Q=q()q.children.append((‘字段名’，‘条件’)) 查询价格是288.88或者名字是帽子同款爆款的商品 from django.db.models import F, Q q = Q()q.connector = 'or'q.children.append(('price', '288.88'))q.children.append(('name', '裤子爆款'))res = models.Product.objects.filter(q) # # Q对象查询默认也是and print(res) 查询价格是288.88或者名字是衣服爆款的商品 from django.db.models import F, Q q = Q()q.children.append(('price', '288.88'))q.children.append(('name', '衣服爆款'))res = models.Product.objects.filter(q) # # Q对象查询默认也是and print(res) 事务事务的ACID 原子性一致性 隔离性持久性 id=1的商品卖出去一件 from django.db import transactionfrom django.db.models import Fwith transaction.atomic(): # 在with代码块儿写你的事务操作 models.Product.objects.filter(id=1).update(kucun=F('kucun') - 1) models.Product.objects.filter(id=1).update(maichu=F('maichu') + 1) 自定义ORM字段models.py from django.db import modelsclass MycharField(models.Field): def __init__(self,max_length,*args,**kwargs): self.max_length=max_length super().__init__(max_length=max_length,*args,**kwargs) def db_type(self,connection): return 'char(%s)'%self.max_lengthclass Product(models.Model): name = models.CharField(max_length=32) # 都是类实例化的对象 price = models.DecimalField(max_digits=8, decimal_places=2) maichu = models.IntegerField() kucun = models.IntegerField() info=MycharField(max_length=32,null=True) # 该字段可以为空 def __str__(self): return '对象的名字：%s'%self.name 执行manage.py命令 菜单-tools-Run manager.py Task$ makemigrations$ migrate only与defer res = models.Product.objects.filter(id=1).values('name').first()print(res) 这个过程中执行了3条sql语句 (0.000) SELECT @@SQL_AUTO_IS_NULL; args=None(0.000) SELECT VERSION(); args=None(0.000) SELECT `app01_product`.`name` FROM `app01_product` WHERE `app01_product`.`id` = 1 LIMIT 21; args=(1,) only 如果取only指定的字段，不去数据库取值，直接在应用程序的缓存中取值 案例1res=models.Product.objects.filter(pk=1).only('name').first()print(res.name) 这个过程执行了3条SQL语句 (0.000) SELECT @@SQL_AUTO_IS_NULL; args=None(0.000) SELECT VERSION(); args=None(0.000) SELECT `app01_product`.`id`, `app01_product`.`name` FROM `app01_product` WHERE `app01_product`.`id` = 1 ORDER BY `app01_product`.`id` ASC LIMIT 1; args=(1,) 案例2res=models.Product.objects.filter(pk=1).only('name').first()print(res.price) 这个过程中执行了4条SQL语句，因为price字段不在only里面配置，所以price字段的值是去数据库里面取 (0.000) SELECT @@SQL_AUTO_IS_NULL; args=None(0.000) SELECT VERSION(); args=None(0.000) SELECT `app01_product`.`id`, `app01_product`.`name` FROM `app01_product` WHERE `app01_product`.`id` = 1 ORDER BY `app01_product`.`id` ASC LIMIT 1; args=(1,)(0.000) SELECT `app01_product`.`id`, `app01_product`.`price` FROM `app01_product` WHERE `app01_product`.`id` = 1; args=(1,) defer 与only相反，如果取defer指定的字段，则是去数据库取值，其他的字段直接在应用程序的缓存中取值 案例1res=models.Product.objects.filter(pk=1).defer('name').first()print(res.name) 执行了4条SQL语句 (0.000) SELECT @@SQL_AUTO_IS_NULL; args=None(0.000) SELECT VERSION(); args=None(0.000) SELECT `app01_product`.`id`, `app01_product`.`price`, `app01_product`.`maichu`, `app01_product`.`kucun`, `app01_product`.`info` FROM `app01_product` WHERE `app01_product`.`id` = 1 ORDER BY `app01_product`.`id` ASC LIMIT 1; args=(1,)(0.000) SELECT `app01_product`.`id`, `app01_product`.`name` FROM `app01_product` WHERE `app01_product`.`id` = 1; args=(1,) 案例2res=models.Product.objects.filter(pk=1).defer('name').first()print(res.price) 执行了3条SQL语句 (0.000) SELECT @@SQL_AUTO_IS_NULL; args=None(0.000) SELECT VERSION(); args=None(0.001) SELECT `app01_product`.`id`, `app01_product`.`price`, `app01_product`.`maichu`, `app01_product`.`kucun`, `app01_product`.`info` FROM `app01_product` WHERE `app01_product`.`id` = 1 ORDER BY `app01_product`.`id` ASC LIMIT 1; args=(1,) 字段choicesmodels.py from django.db import modelsclass Product(models.Model): name = models.CharField(max_length=32) # 都是类实例化的对象 price = models.DecimalField(max_digits=8, decimal_places=2) maichu = models.IntegerField() kucun = models.IntegerField() info=MycharField(max_length=32,null=True) # 该字段可以为空 choices=((1,'男'),(2,'女'),(3,'其他')) gender=models.IntegerField(choices=choices,default=2) def __str__(self): return '对象的名字：%s'%self.name 更新字段操作 菜单-tools-Run manager.py Task$ makemigrations$ migrate tests.py import osif __name__ == \"__main__\": os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"ORM2.settings\") import django django.setup() from app01 import models res=models.Product.objects.filter(id=1).first() print(res.get_gender_display()) # 获取编号对应的中文注释","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"ORM","slug":"ORM","permalink":"http://cjwnb.top/tags/ORM/"}]},{"title":"ORM基础","slug":"ORM基础","date":"2019-07-18T12:14:06.052Z","updated":"2019-07-20T14:05:03.289Z","comments":true,"path":"2019/07/18/ORM基础/","link":"","permalink":"http://cjwnb.top/2019/07/18/ORM基础/","excerpt":"","text":"更多资料： https://www.cnblogs.com/Dominic-Ji/p/9203990.html Django终端打印SQL语句 如果你想知道你对数据库进行操作时，Django内部到底是怎么执行它的sql语句时可以加下面的配置来查看, 在Django项目的settings.py文件中，在最后复制粘贴如下代码： LOGGING = &#123; 'version': 1, 'disable_existing_loggers': False, 'handlers': &#123; 'console':&#123; 'level':'DEBUG', 'class':'logging.StreamHandler', &#125;, &#125;, 'loggers': &#123; 'django.db.backends': &#123; 'handlers': ['console'], 'propagate': True, 'level':'DEBUG', &#125;, &#125;&#125; 配置好之后，再执行任何对数据库进行操作的语句时，会自动将Django执行的sql语句打印到pycharm终端上 补充： 除了配置外，还可以通过.query即可查看查询语句，具体操作如下： 单表操作环境准备settings.py MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',]DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'orm', 'HOST': '127.0.0.1', 'PORT': 3306, 'USER': 'root', 'PASSWORD': 123 &#125;&#125; __init__.py import pymysqlpymysql.install_as_MySQLdb() models.py from django.db import modelsclass User(models.Model): name = models.CharField(max_length=32) pwd = models.IntegerField() register_time = models.DateTimeField() def __str__(self): return self.name tests.py 所有测试数据库操作都在这个文件里做 import osif __name__ == \"__main__\": os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"ORM.settings\") import django django.setup() from app01 import models # 必须在这里导入，如果写在上面就会报错 新增数据基于create创建from django.utils import timezone from datetime import date ctime=date.today() models.User.objects.create(name='lyysb', pwd=123, register_time=ctime) # &lt;class 'app01.models.User'&gt; 数据插入成功了，但是有如下报错 /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/django/db/models/fields/__init__.py:1393: RuntimeWarning: DateTimeField User.register_time received a naive datetime (2019-07-18 00:00:00) while time zone support is active. RuntimeWarning) 解决方案: 导入django时间模块 from django.utils import timezone ctime = date.today() 改为 ctime = timzone.now() 或者在 settings.py 文件中设置：USE_TZ = False (这个参数指的是是否用UTC时间存入数据库) from django.utils import timezonectime = timezone.now()models.User.objects.create(name='lyysb', pwd=123, register_time=ctime) 基于对象的绑定方法创建from django.utils import timezonectime = timezone.now()user_obj = models.User(name='lxxsb', pwd=123, register_time=ctime)user_obj.save() 修改数据基于对象user_obj = models.User.objects.filter(name='lyysb').first()user_obj.name = 'xxx'user_obj.save() 基于queryset对象models.User.objects.filter(name='xxx').update(pwd=456) 删除数据基于对象user_obj = models.User.objects.filter(name='xxx').first() user_obj.delete() 基于querysetmodels.User.objects.filter(name='hppsb').delete() 查询数据 queryset对象是一个集合，这个集合里面存着数据库里每一行的数据的对象 queryset对象都是通过 models.类名.objects.方法 获得 queryset 对象可以通过 models.类名.objects.方法.query 获得具体的SQL语句 all() 查询所有结果,返回queryset对象 要取出对象，使用for循环或者索引取值 注意 : 索引取值不支持负数索引 user_obj = models.User.objects.all() # queryset对象for user in user_obj: print(user.name) 不能用负数取索引 报错 AssertionError: Negative indexing is not supported. res=models.User.objects.all() print(res[-1]) filter(**kwargs) 它包含了与所给筛选条件相匹配的对象 filter内可以放多个限制条件但是需要注意的是多个条件之间是and关系 queryset对象里只有一条数据，直接用first方法取出数据 # &lt;QuerySet [&lt;User: 对象的名字: hhp&gt;]&gt;obj = models.User.objects.filter(name='hhp', pwd=11)res = obj.first()print(res, res.name, res.pwd, res.register_time) queryset对象里有两条条数据，使用for循环或者索引方式取值 obj = models.User.objects.filter(name='lvsb', pwd=66)for res in obj: print(res, res.name, res.pwd, res.register_time) get(**kwargs) 返回与所给筛选条件相匹配的对象，返回结果有且只有一个，如果符合筛选条件的对象超过一个或者没有都会抛出错误, 所以不推荐使用 查询成功的案例 obj=models.User.objects.get(name='zf1')print(obj) 查询失败的案例 出现报错 &gt;&gt;&gt; app01.models.MultipleObjectsReturned: get() returned more than one User – it returned 2! obj=models.User.objects.get(name='lvsb',pwd=66) exclude(**kwargs) 包含了与所给筛选条件不匹配的对象 res = models.User.objects.exclude(name='zf2')for user in res: if user.name == 'zf2': print('exclude失败') else: print('exclude成功') order_by(*field) 对查询结果排序 默认是升序，models.类名.objects.order_by(‘字段名’) 如果要降序，models.类名.objects.order_by(‘-字段名’) order_nor = models.User.objects.order_by('id')res_abnor = models.User.objects.order_by('-id')print(order_nor)print(res_abnor) reverse() 对查询结果反向排序 &gt;&gt; &gt; 前面要先有排序才能反向 res=models.User.objects.order_by('id').reverse() print(res) count() 返回数据库中匹配查询(QuerySet) 的对象数量, 不加filter默认查询所有 统计所有的数量 res=models.User.objects.count() # 等同于res=models.User.objects.all().count()print(res) 统计符合条件的数量 res=models.User.objects.filter(name='hhp').count() print(res) first() 返回queryset对象的第一条记录 res=models.User.objects.all().first() # 等同于 res=models.User.objects.first() print(res) last() 返回queryset对象的最后一条记录 res=models.User.objects.all().last() # 等同于 res=models.User.objects.last() print(res) exists() 如果QuerySet包含数据，就返回True，否则返回False res=models.User.objects.exists()print(res)res1=models.User.objects.filter(name='hhp',pwd=11).exists()print(res1)res2=models.User.objects.filter(name='hhp',pwd=123222).exists()print(res2) values(*field) 返回一个ValueQuerySet——一个特殊的QuerySet，运行后得到的并不是一系列model的实例化对象，而是一个可迭代的字典序列 res=models.User.objects.values('name')print(res)# &lt; QuerySet[# &#123;'name': 'hhp'&#125;, &#123;'name': 'hhp'&#125;, &#123;'name': 'hhp3'&#125;,# &#123;'name': 'zzsb1'&#125;, &#123;'name': 'zzsb2'&#125;, &#123;'name': 'lvsb'&#125;,# &#123;'name': 'lvsb'&#125;, &#123;'name': 'zf1'&#125;, &#123;'name': 'zf2'&#125;,# &#123;'name': 'ztsb'&#125;, &#123;'name': 'ztsb2'&#125;, &#123;'name': 'lxxsb'&#125;,# &#123;'name': 'lyysb'&#125;, &#123;'name': 'lzzsb'&#125;, &#123;'name': 'szksb'&#125;] &gt;res2=models.User.objects.values('name','pwd')print(res2)# &lt; QuerySet[&#123;'name': 'hhp', 'pwd': 11&#125;, &#123;'name': 'hhp', 'pwd': 22&#125;, # &#123;'name': 'hhp3', 'pwd': 33&#125;, &#123;'name': 'zzsb1','pwd': 44&#125;, # &#123;'name': 'zzsb2', 'pwd': 55&#125;, &#123;'name': 'lvsb', 'pwd': 66&#125;, # &#123;'name': 'lvsb', 'pwd': 66&#125;, &#123;'name': 'zf1', 'pwd': 88&#125;,# &#123;'name': 'zf2', 'pwd': 99&#125;, &#123;'name': 'ztsb', 'pwd': 111&#125;, # &#123; 'name': 'ztsb2', 'pwd': 222&#125;, &#123;'name': 'lxxsb', 'pwd': 333&#125;, # &#123;'name': 'lyysb', 'pwd': 444&#125;, &#123;'name': 'lzzsb', 'pwd': 555&#125;, # &#123;'name': 'szksb', 'pwd': 666&#125;] &gt; values_list(*field) 它与values() 非常相似，它返回的是一个元组序列，values返回的是一个字典序列,values_list返回的是一个元组序列 res=models.User.objects.values_list('name','pwd')print(res)# &lt; QuerySet[('hhp', 11), ('hhp', 22), ('hhp3', 33), ('zzsb1', 44),# ('zzsb2', 55), ('lvsb', 66), ('lvsb', 66), ('zf1', 88), ('zf2', 99),# ('ztsb', 111), ('ztsb2', 222), ('lxxsb', 333), ('lyysb', 444), # ('lzzsb', 555), ('szksb', 666)] &gt; distinct() 从返回结果中剔除重复纪录 去重的对象必须是完全相同的数据才能去重 res = models.User.objects.values('name', 'pwd').distinct() print(res) # &lt; QuerySet[&#123;'name': 'hhp', 'pwd': 11&#125;, &#123;'name': 'hhp3', 'pwd': 33&#125;, &#123;'name': 'zzsb1', 'pwd': 44&#125;, # &#123;'name': 'zzsb2','pwd': 55&#125;, &#123;'name': 'lvsb', 'pwd': 66&#125;, &#123;'name': 'zf1', 'pwd': 88&#125;, # &#123;'name': 'zf2', 'pwd': 99&#125;, &#123;'name': 'ztsb', 'pwd': 111&#125;, &#123; 'name': 'ztsb2', 'pwd': 222&#125;, # &#123;'name': 'lxxsb', 'pwd': 333&#125;, &#123;'name': 'lyysb', 'pwd': 444&#125;, &#123;'name': 'lzzsb', 'pwd': 555&#125;, # &#123;'name': 'szksb', 'pwd': 666&#125;, &#123;'name': 'hhp', 'pwd': 22&#125;] &gt; res2 = models.User.objects.values('name').distinct() print(res2) # &lt; QuerySet[&#123;'name': 'hhp'&#125;, &#123;'name': 'hhp3'&#125;, &#123;'name': 'zzsb1'&#125;, &#123;'name': 'zzsb2'&#125;, # &#123;'name': 'lvsb'&#125;, &#123;'name': 'zf1'&#125;, &#123;'name': 'zf2'&#125;, &#123;'name': 'ztsb'&#125;, &#123;'name': 'ztsb2'&#125;, # &#123;'name': 'lxxsb'&#125;, &#123;'name': 'lyysb'&#125;, &#123;'name': 'lzzsb'&#125;, &#123;'name': 'szksb'&#125;] &gt; 双下划线查询 查询密码大于44的用户 res=models.User.objects.filter(pwd__gt=44) print(res) 查询密码小于44的用户 res=models.User.objects.filter(pwd__lt=44)print(res) 查询密码大于等于44的用户 res=models.User.objects.filter(pwd__gte=44)print(res) 查询密码小于等于44的用户 res=models.User.objects.filter(pwd__lte=44)print(res) 查询密码是22，33，44的用户 res=models.User.objects.filter(pwd__in=[22,33,44])print(res) 查询密码在22到111之间的用户 res=models.User.objects.filter(pwd__range=[22,111]) #包头包尾print(res) 查询名字中包含字母sb的用户 res=models.User.objects.filter(name__contains='sb')print(res) 查询名字以z开头的用户 res=models.User.objects.filter(name__startswith='z')print(res) 查询名字以sb结尾的用户 res=models.User.objects.filter(name__endswith='sb') print(res) 查询注册是在2017年的用户 res=models.User.objects.filter(register_time__year=2017)print(res) 查询2.14注册的用户 res=models.User.objects.filter(register_time__year=2017,register_time__month=2,register_time__day=14)print(res) 多表操作表与表之间的关系 一对一(OneToOneField):一对一字段无论建在哪张关系表里面都可以，但是推荐建在查询频率比较高的那张表里面 一对多(ForeignKey):一对多字段建在多的那一方 多对多(ManyToManyField):多对多字段无论建在哪张关系表里面都可以，但是推荐建在查询频率比较高的那张表里面 ps:如何判断表与表之间到底是什么关系 换位思考:A能不能有多个BB能不能有多个A 一对多字段名的增删改models.py from django.db import models# Create your models here.from django.db import modelsclass Book(models.Model): title = models.CharField(max_length=32) price = models.DecimalField(max_digits=8, decimal_places=2) # 配置上auto_now=True，每次更新数据记录的时候会更新该字段 publish_date = models.DateField(auto_now=True) publish = models.ForeignKey(to='Publish') # 多对一关系 author = models.ManyToManyField(to='Author') # 多对多关系 def __str__(self): return '书籍对象的名字 %s' % self.titleclass Publish(models.Model): name = models.CharField(max_length=64) addr = models.CharField(max_length=200) email = models.EmailField() def __str__(self): return '出版社对象的名字 %s' % self.nameclass Author(models.Model): name = models.CharField(max_length=32) age = models.IntegerField() authordetail = models.OneToOneField(to='Authordetail') def __str__(self): return '作者对象的名字 %s' % self.nameclass Authordetail(models.Model): phone = models.CharField(max_length=11) addr = models.CharField(max_length=200 tests.py import osif __name__ == \"__main__\": os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"ORM.settings\") import django django.setup() from app01 import models 预先插入一些数据 # pushlish表插入数据models.Publish.objects.create(name='江苏科学技术出版社',addr='南京市湖南路1号凤凰广场18层',email='4222222@ggg.com')#authordetail表插入数据models.Authordetail.objects.create(phone='76654444444',addr='北京市昌平区海定校区11号') 新增数据 直接写id user_obj=models.Book.objects.create(title='红楼梦',price=44.56,publish_id=1) 传数据对象 publish_obj=models.Publish.objects.filter(pk=2).first()models.Book.objects.create(title='三国演义',price=111.11,publish=publish_obj) 修改数据 queryset修改 直接写id models.Book.objects.filter(pk=2).update(publish_id=5) 传数据对象 publish_object=models.Publish.objects.filter(pk=2).first() models.Book.objects.filter(pk=2).update(publish=publish_object) 对象修改 直接修改 book_obj=models.Book.objects.filter(pk=2).first() book_obj.publish_id=5 # 点表中真实存在的字段名 book_obj.save() 传数据对象重新赋值并保存 book_obj=models.Book.objects.filter(pk=2).first()publish_obj=models.Publish.objects.filter(pk=1).first()book_obj.publish=publish_obj # 点orm中字段名 传该字段对应的表的数据对象book_obj.save() 删除models.Book.objects.filter(pk=2).delete() # 删除book表中id等于2的数据models.Publish.objects.filter(pk=5).delete() # 将publish表中的id=5的数据删除，并且将book表中关联这个id的数据也删除 给书籍绑定与作者之间的关系 add() 添加关系，add支持传数字或对象，并且都可以传多个 传1个数字 book_obj=models.Book.objects.filter(pk=3).first()book_obj.author.add(1) 传多个数字 book_obj=models.Book.objects.filter(pk=3).first()book_obj.author.add(2,3,4) 传1个对象 book_obj=models.Book.objects.filter(pk=4).first()author_obj=models.Author.objects.filter(pk=1).first()book_obj.author.add(author_obj) 传多个对象 book_obj=models.Book.objects.filter(pk=4).first()author_obj=models.Author.objects.all()book_obj.author.add(*author_obj) set() 修改书籍与作者的关系 set() set传的必须是可迭代对象！！！ book_obj=models.Book.objects.filter(pk=4).first() # 必须是数据的对象，不能是queryset对象book_obj.author.set((1,)) # set()里面穿的参数必须是可迭代对象 book_obj=models.Book.objects.filter(pk=4).first()book_obj.author.set((2,3)) book_obj=models.Book.objects.filter(pk=4).first()author_list=models.Author.objects.all()book_obj.author.set(author_list) remove() 删除书籍与作者的绑定关系 book_obj=models.Book.objects.filter(pk=4).first()author_obj=models.Author.objects.filter(pk=1).first()book_obj.author.remove(author_obj) book_obj=models.Book.objects.filter(pk=4).first() author_list=models.Author.objects.all() book_obj.author.remove(*author_list) clear() 清空的是你当前这个表记录对应的绑定关系 先将数据加下看效果 book_obj=models.Book.objects.filter(pk=4).first()author_list=models.Author.objects.all()book_obj.author.add(*author_list) 清空数据 book_obj=models.Book.objects.filter(pk=4).first()book_obj.author.clear()","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"ORM","slug":"ORM","permalink":"http://cjwnb.top/tags/ORM/"}]},{"title":"模板层","slug":"模板层","date":"2019-07-17T13:25:13.623Z","updated":"2019-07-20T09:02:11.422Z","comments":true,"path":"2019/07/17/模板层/","link":"","permalink":"http://cjwnb.top/2019/07/17/模板层/","excerpt":"","text":"面向对象复习class Foo(object): def __init__(self, name, age): self.name = name self.age = age def func(self): return self.name @classmethod def cls(cls): return 'cls' @staticmethod def Bar(): return 'bar'obj=Foo(name='lyysb',age=38)print(obj.__dict__) # &#123;'name': 'lyysb', 'age': 38&#125;print(obj.cls()) # clsprint(obj.Bar()) # bar 语法传参 只需要记两种特殊符号： &#123;&#123; &#125;&#125;和 &#123;% %&#125;变量相关的用&#123;&#123;&#125;&#125;，逻辑相关的用&#123;%%&#125;。 后端朝前端页面传递数据的方式# 第一种return render(request,'index.html',&#123;'n':n&#125;)# 第二种return render(request,'index.html',locals()) # 将当前所在的名称空间中的名字全部传递给前端页面 后端传函数名到前端，会自动加括号调用，但是不支持传参后端传对象到前端，就相当于打印了这个对象前端获取后端传过来的容器类型的内部元素 统一采用句点符(.)前端能够调用python后端数据类型的一些不需要传参的内置方法,如果有参数，则前端无法调用 urls.py` from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index',views.index)] views.py from django.shortcuts import render, HttpResponse# Create your views here.def index(request): name = \"lyysb\" i = 10 l = [111, 22, 333] info = &#123;'name': 'lyysb', 'age': 38&#125; b = True def abc(): return 'abc' class Foo(object): def __init__(self, name, age): self.name = name self.age = age def func(self): return self.name @classmethod def cls(cls): return 'cls' @staticmethod def Bar(): return 'bar' obj = Foo(name='lyysb', age=38) return render(request, 'index.html', locals()) index.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&#123;&#123; name &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; i &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; l &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; info &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; b &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; abc &#125;&#125;&lt;/p&gt;&#123;# 取出类对象以及其属性 #&#125;&lt;p&gt;&#123;&#123; obj &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; obj.name &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; obj.age &#125;&#125;&lt;/p&gt;&#123;# 取出列表中的某个元素 #&#125;&lt;p&gt;&#123;&#123; l.0 &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; l.1 &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; l.2 &#125;&#125;&lt;/p&gt;&#123;# 取出字典中的key,value #&#125;&lt;p&gt;&#123;&#123; info.keys &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; info.values &#125;&#125;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 过滤器在Django的模板语言中，通过使用 过滤器 来改变变量的显示。 过滤器的语法： &#123;&#123; value|filter_name:参数 &#125;&#125;使用管道符\"|\"来应用过滤器。例如：&#123;&#123; name|lower &#125;&#125;会将name变量应用lower过滤器之后再显示它的值。lower在这里的作用是将文本全都变成小写。 注意事项 1.过滤器支持“链式”操作。即一个过滤器的输出作为另一个过滤器的输入。2.过滤器可以接受参数，例如：&#123;&#123; sss|truncatewords:30 &#125;&#125;，这将显示sss的前30个词。3.过滤器参数包含空格的话，必须用引号包裹起来。比如使用逗号和空格去连接一个列表中的元素，如：&#123;&#123; list|join:', ' &#125;&#125;4.'|'左右没有空格没有空格没有空格 Django的模板语言中提供了大约六十个内置过滤器 default 如果一个变量是false或者为空，使用给定的默认值。 否则，使用变量的值 &#123;&#123; value|default:\"nothing\"&#125;&#125; 如果value没有传值或者值为空的话就显示nothing length 返回值的长度，作用于字符串和列表。 &#123;&#123; value|length &#125;&#125; 返回value的长度，如 value=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]的话，就显示4. filesizeformat 将值格式化为一个 “人类可读的” 文件尺寸 （例如 &#39;13 KB&#39;, &#39;4.1 MB&#39;, &#39;102 bytes&#39;, 等等 &#123;&#123; value|filesizeformat &#125;&#125; 如果 value 是 123456789，输出将会是 117.7 MB slice 切片 &#123;&#123;value|slice:\"2:-1\"&#125;&#125; date 格式化 &#123;&#123; value|date:\"Y-m-d H:i:s\"&#125;&#125; safe Django的模板中会对HTML标签和JS等语法标签进行自动转义，原因显而易见，这样是为了安全。但是有的时候我们可能不希望这些HTML元素被转义，比如我们做一个内容管理系统，后台添加的文章中是经过修饰的，这些修饰可能是通过一个类似于FCKeditor编辑加注了HTML修饰符的文本，如果自动转义的话显示的就是保护HTML标签的源文件。为了在Django中关闭HTML的自动转义有两种方式，如果是一个单独的变量我们可以通过过滤器“|safe”的方式告诉Django这段代码是安全的不必转义。 &#123;&#123; value|safe&#125;&#125; truncatechars 如果字符串字符多于指定的字符数量，那么会被截断。截断的字符串将以可翻译的省略号序列（“…”）结尾。 参数：截断的字符数 &#123;&#123; value|truncatechars:9&#125;&#125; truncatewords 在一定数量的字后截断字符串。 &#123;&#123; value|truncatewords:9&#125;&#125; cut 移除value中所有的与给出的变量相同的字符串 &#123;&#123; value|cut:' ' &#125;&#125; 如果value为&#39;i love you&#39;，那么将输出&#39;iloveyou&#39;. join 使用字符串连接列表，例如Python的str.join(list) 时间模块复习from time import strptimeblog_date = strptime('2018-1-1', \"%Y-%m-%d\")comment_date = strptime('2018-1-1', \"%Y-%m-%d\")print(blog_date,comment_date)# time.struct_time(tm_year=2018, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=0, tm_yday=1, tm_isdst=-1) # time.struct_time(tm_year=2018, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=0, tm_yday=1, tm_isdst=-1)import datetimeblog_date = datetime.date(2018, 1, 1)comment_date = datetime.date(2019, 1, 1)print(blog_date,comment_date)# 2018-01-01 # 2019-01-01 timesince 将日期格式设为自该日期起的时间（例如，“4天，6小时”） 采用一个可选参数，它是一个包含用作比较点的日期的变量（不带参数，比较点为现在) 例如，如果blog_date是表示2006年6月1日午夜的日期实例，并且comment_date是2006年6月1日08:00的日期实例，则以下将返回“8小时”： &#123;&#123; blog_date|timesince:comment_date &#125;&#125;在后端blog_data,comment_data必须是日期对象,使用datetime模块中的datetime.date()生成 分钟是所使用的最小单位，对于相对于比较点的未来的任何日期，将返回“0分钟”。 timeuntil对于timesince，除了它测量从现在开始直到给定日期或日期时间的时间。 例如，如果今天是2006年6月1日，而conference_date是保留2006年6月29日的日期实例，则&#123;&#123; conference_date | timeuntil &#125;&#125;将返回“4周”。使用可选参数，它是一个包含用作比较点的日期（而不是现在）的变量。 如果from_date包含2006年6月22日，则以下内容将返回“1周”： &#123;&#123; conference_date|timeuntil:from_date &#125;&#125; 案例urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index',views.index)] views.py from django.shortcuts import render# Create your views here.def index(request): n = 6969 s = '您好 我是 23 号技 师 很高兴 为您 服务，希望您 能满意!（不带换的' file_size = 1113 from datetime import datetime ctime = datetime.now() res = 'hello big baby baby baby baby' ht = '&lt;h1&gt;我是h1标签&lt;/h1&gt;' cut = 'i love you' join_str = 'lyysupersb' join_list = [1, 2, 3, '33333'] # 返回日期格式给前端 import datetime blog_date = datetime.date(2018,1,1) comment_date = datetime.date(2019,1,1) # 后端解析为HTML格式的数据传给前端 from django.utils.safestring import mark_safe xxx = mark_safe('&lt;h1&gt;我是h1标签&lt;/h1&gt;') return render(request, 'index.html', locals()) index.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;前端统计字符串的长度 &#123;&#123; s|length &#125;&#125;&lt;/p&gt;&lt;p&gt;前端获取数据，如果是空就返回default后面默认的参数值 &#123;&#123; flag|default:'none' &#125;&#125;&lt;/p&gt;&lt;p&gt;将数字格式化成表示文件大小的单位 &#123;&#123; file_size|filesizeformat &#125;&#125;&lt;/p&gt;&lt;p&gt;格式化事件（不要加%号）&#123;&#123; ctime|date:'Y-m-d' &#125;&#125;&lt;/p&gt;&lt;p&gt;字符串的切片操作 &#123;&#123; res|slice:'0:8' &#125;&#125;&lt;/p&gt;&lt;p&gt;带步长的字符串切片操作 &#123;&#123; res|slice:'0:8:2' &#125;&#125;&lt;/p&gt;&lt;p&gt;截取固定长度的字符串 加上三个点 &#123;&#123; s|truncatechars:5 &#125;&#125;&lt;/p&gt;&lt;p&gt;按照空格截取文本内容 &#123;&#123; res|truncatewords:'4' &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; n|add:1 &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; 'hahaha'|add:'hehehehehe' &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; cut|cut:' ' &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;join_list|join:join_str&#125;&#125;&lt;/p&gt;&lt;p&gt;blog_date和comment_date两个时间的间隔&#123;&#123; blog_date|timesince:comment_date &#125;&#125;&lt;/p&gt;&lt;p&gt;blog_date和现在的时间的间隔&#123;&#123; blog_date|timesince &#125;&#125;&lt;/p&gt;&lt;p&gt;comment_date和blog_date的时间间隔&#123;&#123; comment_date | timeuntil:blog_date &#125;&#125;&lt;/p&gt;&#123;# 重点 #&#125;&lt;p&gt;渲染成HTML标签格式的字符串&#123;&#123; ht &#125;&#125;&lt;/p&gt;&lt;p&gt;渲染成HTML格式&#123;&#123; ht|safe &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; xxx &#125;&#125;&lt;/p&gt; # xxx是后端处理为HTML格式的数据传给前端，前端拿到这个数据直接 &lt;/body&gt;&lt;/html&gt; 标签views.py from django.shortcuts import renderdef index(request): emp=[] s = [111, 222, 3333, 4444] flag = None d = &#123;'name': 'jason', 'password': '222', 'hobby': ['看书', '写字', '琴棋书画']&#125; return render(request, 'index.html', locals()) urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index',views.index)] FOR 语法： &gt; &lt;body&gt;&gt; &#123;% for 自定义变量名 in 后端可迭代对象 %&#125;&gt; &gt; &lt;p&gt;&#123;&#123; 自定义变量名 &#125;&#125;&lt;/p&gt;&gt; &gt; &#123;% endfor %&#125;&gt; &lt;/body&gt;&gt; 循环可迭代对象渲染到前端循环列表index.html &lt;body&gt;&#123;% for i in s %&#125; &lt;p&gt;&#123;&#123; i &#125;&#125;&lt;/p&gt;&#123;% endfor %&#125;&lt;/body&gt; 浏览器查看结果 循环字典index.html &lt;body&gt;&#123;% for i in d.keys %&#125; &lt;p&gt;&#123;&#123; i &#125;&#125;&lt;/p&gt;&#123;% endfor %&#125;&#123;% for i in d.values %&#125; &lt;p&gt;&#123;&#123; i &#125;&#125;&lt;/p&gt;&#123;% endfor %&#125;&#123;% for i in d.items %&#125; &lt;p&gt;&#123;&#123; i &#125;&#125;&lt;/p&gt;&#123;% endfor %&#125;&lt;/body&gt; Forloopindex.html &lt;body&gt;&#123;% for i in s %&#125; &lt;p&gt;&#123;&#123; forloop &#125;&#125;&lt;/p&gt;&#123;% endfor %&#125;&lt;/body&gt; for循环了多少次，页面上就会渲染多少个forloop对象 forloop字段 first: for循环第一次得到的fooloop对象中的first字段肯定是True,其他均为flase last: for循环最后一次得到的fooloop对象中的last字段肯定是True,其他均为flase empty for循环中如果数据是空的，则走empty下面的语句 &lt;body&gt;&#123;% for foo in emp %&#125; &#123;% if forloop.first %&#125; &lt;p&gt;第一次循环&lt;/p&gt; &#123;% elif forloop.last %&#125; &lt;p&gt;第二次循环&lt;/p&gt; &#123;% else %&#125; &lt;p&gt;&#123;&#123; foo &#125;&#125;&lt;/p&gt; &#123;% endif %&#125;&#123;% empty %&#125; &lt;p&gt;数据是空的&lt;/p&gt;&#123;% endfor %&#125;&lt;/body&gt; IFindex.html &lt;body&gt;&#123;% if flag %&#125; &lt;p&gt;flag不为空&lt;/p&gt; &#123;% else %&#125; &lt;p&gt;flag是空&lt;/p&gt;&#123;% endif %&#125;&lt;/body&gt; 关联使用index.html &lt;body&gt;&#123;% for i in s %&#125; &#123;% if forloop.first %&#125; &lt;p&gt;这是第一次for循环&lt;/p&gt; &#123;% elif forloop.last %&#125; &lt;p&gt;这是最后一次for循环&lt;/p&gt; &#123;% else %&#125; &lt;p&gt;&#123;&#123; i &#125;&#125;&lt;/p&gt; &#123;% endif %&#125;&#123;% endfor %&#125;&lt;/body&gt; withindex.html &lt;body&gt;&lt;p&gt;&#123;&#123; d.hobby &#125;&#125;&lt;/p&gt;&#123;% with d.hobby as v %&#125; &lt;p&gt;&#123;&#123; v.0 &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; v.1 &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; v.2 &#125;&#125;&lt;/p&gt;&#123;% endwith %&#125;&lt;/body&gt; 自定义过滤器,标签前提 必须在应用名下新建一个名为templatetags的package文件夹（必须叫这个名字） 在该新建的文件夹内新建一个任意名称的py文件 在该py文件中需要固定写两句代码： from django import template register=template.Library() 注意 自定义过滤器和自定义标签都是来解决复用性问题 自定义过滤器最多只能传2个参数，标签随意 自定义过滤器可以写进条件语句，自定义标签不可以写进条件语句 &gt;&#123;% if 10|multi_filter:20 &gt; 100 %&#125;&gt;&lt;p&gt;100&lt;/p&gt;&gt; &#123;% else %&#125;&gt; &lt;p&gt;200&lt;/p&gt;&gt;&#123;% endif %&#125;&gt; 案例app01/templatetags/my_tag_filter.py from django import templateregister = template.Library()# 自定义过滤器@register.filterdef multi_filter(x, y): return x * y# 自定义标签@register.simple_tagdef multi_tag(x, y): return x * y index.html &lt;body&gt;&lt;h4&gt;自定义过滤器,标签&lt;/h4&gt;&#123;% load my_tag_filter %&#125;&lt;p&gt;&#123;&#123; 10|multi_filter:20 &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;% multi_tag 7 9 %&#125;&lt;/p&gt;&lt;/body&gt; 模板的继承和导入 首先需要在被继承的模板中划分多个区域 &#123;% block 给区域起的名字 %&#125;&#123;% endblock %&#125; 通常情况下一个模板中应该至少有三块 &#123;% block css %&#125;页面css代码块&#123;% endblock %&#125;&#123;% block js %&#125;页面js代码块&#123;% endblock %&#125;&#123;% block content %&#125;页面主体内容&#123;% endblock %&#125; 子板继承模板 先继承模板所有的内容 &#123;% extends 'home.html' %&#125; 然后根据block块的名字修改指定区域的内容 &#123;% block content %&#125; &lt;h1&gt;登录页面&lt;/h1&gt; &lt;form action=\"\"&gt; &lt;p&gt;username:&lt;input type=\"text\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;password:&lt;input type=\"text\" class=\"form-control\"&gt;&lt;/p&gt; &lt;input type=\"submit\" class=\"btn btn-success\"&gt; &lt;/form&gt;&#123;% endblock %&#125; 模板的导入 模板的导入:将一段html当做模块的方式导入到另一个html展示 &#123;% include '想导入的html文件名' %&#125; 静态文件配置&#123;% load static %&#125; &lt;link rel='stylesheet' href=\"&#123;% static 'css/mycss.css'%&#125;\"&gt; # 第一种方式&lt;link rel='stylesheet' href=\"&#123;% get_static_prefix %&#125;css/mycss.css\"&gt; # 第二种方式 案例urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index/', views.index), url(r'^home/',views.home), url(r'^login/',views.login), url(r'^reg/',views.reg),] views.py from django.shortcuts import renderdef home(request): return render(request,'home.html')def login(request): return render(request,'login1.html')def reg(request): return render(request,'reg.html') home.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;link href=\"https://cdn.bootcss.com/twitter-bootstrap/3.4.0/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;script src=\"https://cdn.bootcss.com/twitter-bootstrap/3.4.0/js/bootstrap.min.js\"&gt;&lt;/script&gt; &#123;% block css %&#125; &#123;% endblock %&#125;&lt;/head&gt;&lt;body&gt;&lt;nav class=\"navbar navbar-default\"&gt; &lt;div class=\"container-fluid\"&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class=\"navbar-header\"&gt; &lt;button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#bs-example-navbar-collapse-1\" aria-expanded=\"false\"&gt; &lt;span class=\"sr-only\"&gt;Toggle navigation&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=\"navbar-brand\" href=\"#\"&gt;Brand&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class=\"collapse navbar-collapse\" id=\"bs-example-navbar-collapse-1\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"#\"&gt;Link &lt;span class=\"sr-only\"&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\" role=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\"&gt;Dropdown &lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=\"separator\" class=\"divider\"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;li role=\"separator\" class=\"divider\"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;One more separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class=\"navbar-form navbar-left\"&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"Search\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\" role=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\"&gt;Dropdown &lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=\"separator\" class=\"divider\"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt;&lt;/nav&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-3\"&gt; &lt;div class=\"list-group\"&gt; &lt;a href=\"/login\" class=\"list-group-item active\"&gt; login &lt;/a&gt; &lt;a href=\"/reg\" class=\"list-group-item\"&gt;reg&lt;/a&gt; &lt;a href=\"#\" class=\"list-group-item\"&gt;Morbi leo risus&lt;/a&gt; &lt;a href=\"#\" class=\"list-group-item\"&gt;Porta ac consectetur ac&lt;/a&gt; &lt;a href=\"#\" class=\"list-group-item\"&gt;Vestibulum at eros&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-md-9\"&gt; &#123;% block content %&#125; &lt;div class=\"jumbotron\"&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;p&gt;...&lt;/p&gt; &lt;p&gt;&lt;a class=\"btn btn-primary btn-lg\" href=\"#\" role=\"button\"&gt;Learn more&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &#123;% include 'hualihushao.html' %&#125; &#123;% endblock %&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&#123;% block js %&#125;&#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; login1.html &#123;% extends 'home.html' %&#125;&#123;% block content %&#125;&lt;h1&gt;登录页面&lt;/h1&gt; &lt;form action=\"\"&gt; &lt;p&gt;username:&lt;input type=\"text\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;password:&lt;input type=\"text\" class=\"form-control\"&gt;&lt;/p&gt; &lt;input type=\"submit\" class=\"btn btn-success\"&gt; &lt;/form&gt; &#123;% include 'hualihushao.html' %&#125;&#123;% endblock %&#125; reg.html &#123;% extends 'home.html' %&#125;&#123;% block content %&#125;&lt;h1&gt;注册页面&lt;/h1&gt; &lt;form action=\"\"&gt; &lt;p&gt;username:&lt;input type=\"text\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;password:&lt;input type=\"text\" class=\"form-control\"&gt;&lt;/p&gt; &lt;input type=\"submit\" class=\"btn btn-danger pull-right\"&gt; &lt;/form&gt;&#123;% endblock %&#125; hualihushao.html &lt;h1&gt;我是这条gai最靓的仔&lt;/h1&gt;&lt;form action=\"\"&gt; &lt;p&gt;&lt;input type=\"text\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"text\"&gt;&lt;/p&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"模板层","slug":"模板层","permalink":"http://cjwnb.top/tags/模板层/"}]},{"title":"视图层","slug":"视图层","date":"2019-07-17T08:26:12.757Z","updated":"2019-07-22T07:18:54.388Z","comments":true,"path":"2019/07/17/视图层/","link":"","permalink":"http://cjwnb.top/2019/07/17/视图层/","excerpt":"","text":"FBV与CBV FBV 基于函数的视图 CBV 基于类的视图 FBVurlpatterns = [ path('admin/', admin.site.urls), path('index/&lt;yyyy:id&gt;', views.index),]def index(request, id): print(id, type(id)) # 222 &lt;class 'str'&gt; return HttpResponse('index') CBV​ 无论是FBV还是CBV路由层都是路由对应视图函数内存地址 urlpatterns = [ # url(r'^mycls/',views.view) url(r'^mycls/',views.MyCls.as_view())]class MyCls(View): def get(self,request): return render(request,'index.html') def post(self,request): return HttpResponse('post') CBV源码解析 urls.py from django.contrib import adminfrom django.urls import path, re_pathfrom app01 import viewsurlpatterns = [ url('^admin/', admin.site.urls), url('^test', views.MyCls.as_view())] views.py from django.shortcuts import render, HttpResponse# Create your views here.class MyCls(View): def get(self, request): return render(request, 'test.html') def post(self, request): return HttpResponse('post') test.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;欢迎访问&lt;/h1&gt;&lt;form action=\"/test/\" method=\"post\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 请求对象request 当一个页面被请求时，Django就会创建一个包含本次请求原信息的HttpRequest对象。Django会将这个对象自动传递给响应的视图函数，一般视图函数约定俗成地使用 request 参数承接这个对象。 请求地址格式http://127.0.0.1/index url:协议://IP:port/路径？get请求数据 request方法 常用方法request.get_full_path() 路径加参数，如果输入URL请求是http://127.0.0.1:8000/index/?a=1， 则输出为index/?a=1 request.path() 只输出路径，如果输入URL请求是http://127.0.0.1:8000/index/?a=1， 则输出为index/ urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index',views.index)] views.py from django.shortcuts import render,HttpResponse# Create your views here.def index(request): print(request) print(request.get_full_path()) # /index/?a=1 print(request.path) # /index/ return HttpResponse('ok') 响应对象response 与由Django自动创建的HttpRequest对象相比，HttpResponse对象是我们的职责范围了。我们写的每个视图都需要实例化，填充和返回一个HttpResponse。 HttpResponse类位于django.http模块中。 urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index',views.index)] views.py from django.shortcuts import render,HttpResponse# Create your views here.def index(request): print(request) print(request.get_full_path()) # /index/?a=1 print(request.path) # /index/ return HttpResponse('ok') 浏览器返回Json格式 希望在浏览器返回一个大字典，我们想到了Httpresponse({‘name’:’lyysb’,’password’:123344}) 在django中，通过JsonResponse这个类来完成 测试1urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'test',views.Test.as_view()),] views.py from django.views import Viewfrom django.shortcuts import HttpResponse, render, redirectclass Test(View): def get(self, request): data=&#123;'name': 'lyysb', 'password': 123332&#125; return HttpResponse(data) def post(self, request): pass 浏览器输入http://127.0.0.1:8000/test/ 只是返回来字典的键值 所以如果要这个字典完整在浏览器上渲染，尝试使用json格式字符串 测试2修改views.py里的代码 views.py from django.views import Viewfrom django.shortcuts import HttpResponseimport jsonclass Test(View): def get(self, request): data = &#123;'name': 'lyy傻缺', 'password': 123332&#125; return HttpResponse(json.dumps(data, ensure_ascii=False)) # ensure_ascii=False参数的作用是使得中文能够在浏览器上渲染 def post(self, request): pass 浏览器输入http://127.0.0.1:8000/test/ 测试3 使用 JsonResponse 返回json字符串 JsonResponse 源码 内部调用的也是Json模块，封装了json.dumps() 如果需要传递参数，通过 json_dumps_params 关键字传参，传参的值以字典的形式传值,因为这样 json_dumps_params的值就打散成key=value的形式为json.dumps()传递 比如说 json.dumps(data, ensure_ascii=False)，要使用JsonResponse得到同样的效果 就这么用: JsonResponse(data,json_dumps_params={‘ensure_ascii’:False}) class JsonResponse(HttpResponse): def __init__(self, data, encoder=DjangoJSONEncoder, safe=True, json_dumps_params=None, **kwargs): if safe and not isinstance(data, dict): raise TypeError( 'In order to allow non-dict objects to be serialized set the ' 'safe parameter to False.' ) if json_dumps_params is None: json_dumps_params = &#123;&#125; kwargs.setdefault('content_type', 'application/json') data = json.dumps(data, cls=encoder, **json_dumps_params) super(JsonResponse, self).__init__(content=data, **kwargs) views.py from django.http import JsonResponsefrom django.views import Viewclass Test(View): def get(self, request): data = &#123;'name': 'lyy傻缺', 'password': 123332&#125; return JsonResponse(data,json_dumps_params=&#123;'ensure_ascii':False&#125;) def post(self, request): pass urls.py from django.contrib import adminfrom django.urls import path, re_pathfrom app01 import viewsurlpatterns = [ url('^admin/', admin.site.urls), url('^test', views.MyCls.as_view())] 文件上传实现简单的文件上传 urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'upload', views.Upload_file.as_view()),] views.py from django.views import Viewfrom django.shortcuts import HttpResponse, renderclass Upload_file(View): def get(self, request): return render(request, 'test.html') def post(self, request): file_obj = request.FILES.get('myfile') with open(file_obj.name, 'wb') as f: for line in file_obj.chunks(): f.write(line) return HttpResponse('ok') test.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;上传文件&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"myfile\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"视图层","slug":"视图层","permalink":"http://cjwnb.top/tags/视图层/"}]},{"title":"虚拟环境","slug":"虚拟环境","date":"2019-07-17T06:09:46.748Z","updated":"2019-07-20T11:03:11.056Z","comments":true,"path":"2019/07/17/虚拟环境/","link":"","permalink":"http://cjwnb.top/2019/07/17/虚拟环境/","excerpt":"","text":"虚拟环境不同的项目配置不同的python解释器 django1.0与django2.0之间的区别 django2.0里面的path第一个参数不支持正则，你写什么就匹配，100%精准匹配 django2.0里面的re_path对应着django1.0里面的url urls.py from django.contrib import adminfrom django.urls import path,re_pathfrom app01 import viewsurlpatterns = [ path('admin/', admin.site.urls), re_path('^index/',views.index)] views.py from django.shortcuts import render,HttpResponse# Create your views here.def index(request): return HttpResponse('index') 虽然django2.0里面的path不支持正则表达式，但是它提供五个默认的转换器 str,匹配除了路径分隔符（/）之外的非空字符串，这是默认的形式int,匹配正整数，包含0。slug,匹配字母、数字以及横杠、下划线组成的字符串。uuid,匹配格式化的uuid，如 075194d3-6885-417e-a8a8-6c931e272f00。path,匹配任何非空字符串，包含了路径分隔符（/）（不能用？） urls.py from django.contrib import adminfrom django.urls import path,re_pathfrom app01 import viewsurlpatterns = [ path('admin/', admin.site.urls), path('index/&lt;str:id&gt;', views.index),] views.py from django.shortcuts import HttpResponsedef index(request, id): print(id, type(id)) # 222 &lt;class 'str'&gt; return HttpResponse('index') 自定义转换器 正则表达式 类 注册 class FourDigitYearConverter: regex = '[0-9]&#123;4&#125;' def to_python(self, value): return int(value) def to_url(self, value): return '%04d' % value # 占四位，不够用0填满，超了则就按超了的位数来！ register_converter(FourDigitYearConverter, 'yyyy') PS:路由匹配到的数据默认都是字符串形式 urls.py from django.contrib import adminfrom django.urls import path,re_pathfrom app01 import viewsfrom django.urls import path,re_path,register_converter# 自定义转换器，将浏览器输入路径的最后一个名字转换为4位数字，如果不够用0填充class FourDigitYearConverter: regex = '[0-9]&#123;4&#125;' def to_python(self, value): return int(value) def to_url(self, value): return '%04d' % value # 占四位，不够用0填满，超了则就按超了的位数来！register_converter(FourDigitYearConverter, 'yyyy')urlpatterns = [ path('admin/', admin.site.urls), path('index/&lt;yyyy:id&gt;', views.index),] views.py from django.shortcuts import HttpResponsedef index(request, id): print(id, type(id)) # 2222 &lt;class 'int'&gt; return HttpResponse('index') 浏览器输入http://127.0.0.1:8000/index/2222 测试","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"路由层","slug":"路由层","permalink":"http://cjwnb.top/tags/路由层/"}]},{"title":"django 路由层之反向解析","slug":"Django路由层之反向解析","date":"2019-07-17T05:01:02.257Z","updated":"2019-07-20T09:11:03.345Z","comments":true,"path":"2019/07/17/Django路由层之反向解析/","link":"","permalink":"http://cjwnb.top/2019/07/17/Django路由层之反向解析/","excerpt":"","text":"反向解析根据名字动态获取到对应的路径 可以给每一个路由与视图函数对应关系起一个名字这个名字能够唯一标识出对应的路径注意这个名字不能重复是唯一的 from django.shortcuts import reverseurl(r'^index6668888/$',views.index,name='index') 前端使用 &#123;% url 'index' %&#125;&#123;% url '你给路由与视图函数对应关系起的别名' %&#125; 后端使用 reverse('index')reverse('你给路由与视图函数对应关系起的别名') 有名分组反向解析后端使用 # 后端有名分组和无名分组都可以用这种形式 print(reverse('list',args=(10,))) # 下面这个了解即可 print(reverse('list',kwargs=&#123;'year':10&#125;)) 前端使用 # 前端有名分组和无名分组都可以用这种形式 &#123;% url 'list' 10 %&#125; # 下面这个了解即可 &#123;% url 'list' year=10 %&#125; 无名分组反向解析后端使用 reverse('list',args=(10,)) # 这里的数字通常都是数据的主键值 前端使用 &#123;% url 'list' 10 %&#125; 总结 针对有名分组与无名分组的反向解析统一采用一种格式即可 反向解析的本质:就是获取到一个能够访问名字所对应的视图函数 应用场景 通过别名来传递路径给到前端或者后端，好处是更加灵活，因为是通过别名进行传递，所以只要修改源路径，其他的层都不需要更改，否则如果直接通过源路径传递，则耦合度较高，不够灵活，维护成本太高 案例1前端通过蒙版语法&#123;% url &apos;定义的别名&apos; %&#125;取值 login.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1&gt;登录界面&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\"&gt; &lt;form action=\"&#123;% url 'log' %&#125;/\" method=\"post\"&gt; &lt;p&gt;用户名 &lt;input type=\"text\" name=\"user\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;密码 &lt;input type=\"password\" name=\"pwd\" class=\"form-control\"&gt;&lt;/p&gt; &lt;input type=\"submit\" value=\"登录\" class=\"btn btn-primary\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; views.py from django.shortcuts import render, HttpResponse# Create your views here.# 只要是和请求相关的事情，都需要用到requestdef login(request): if request.method == 'GET': return render(request, 'login.html') else: user = request.POST.get('user') pwd = request.POST.get('pwd') if user == \"lxx\" and pwd == '123': return HttpResponse('登录成功') else: return HttpResponse('用户名或者密码错误') urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login.html/', views.login,name='log'), 案例2后端通过reverse函数取值 urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login.html/', views.login, name='log'), url(r'^test/', views.test, name='t1'),] views.py from django.shortcuts import render, HttpResponse,redirect,reverse# 只要是和请求相关的事情，都需要用到requestdef login(request): if request.method == 'GET': return render(request, 'login.html') else: user = request.POST.get('user') pwd = request.POST.get('pwd') if user == \"lxx\" and pwd == '123': return HttpResponse('登录成功') else: return redirect(reverse('t1')) # 跳转到别名为t1的路径/test/def test(request): return HttpResponse('用户名或者密码错误') 案例3有名分组反向解析 urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login.html/', views.login, name='log'), url(r'^test/([0-9]+)', views.test, name='t1'),] views.py from django.shortcuts import render, HttpResponse, redirect, reversedef test(request, group): # 当输入 http://127.0.0.1:8000/test/2018/， group接收的值就是2018 print(reverse('t1', args=(group,))) # /test/2018 if request.method == 'GET': return render(request, 'group.html', &#123;'group': group&#125;) else: return HttpResponse('test') group.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1&gt;有名分组反向解析测试&lt;/h1&gt; &lt;div class=\"col-md-2 col-md-offset-4\"&gt; &lt;form action=\"&#123;% url 't1' group %&#125;/\" method=\"post\"&gt; &lt;p&gt;用户名 &lt;input type=\"text\" name=\"user\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;密码 &lt;input type=\"password\" name=\"pwd\" class=\"form-control\"&gt;&lt;/p&gt; &lt;input type=\"submit\" class=\"btn btn-success\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; 案例4无名分组反向解析, 和有名分组一模一样 urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login.html/', views.login, name='log'), url(r'^test/(?P&lt;xxx&gt;\\d+)', views.test, name='t1'),] views.py def test(request, xxx): print(reverse('t1', args=(xxx,))) if request.method == 'GET': return render(request, 'group.html', &#123;'group': xxx&#125;) else: return HttpResponse('test') group.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1&gt;无名分组反向解析测试&lt;/h1&gt; &lt;div class=\"col-md-2 col-md-offset-4\"&gt; &lt;form action=\"&#123;% url 't1' group %&#125;/\" method=\"post\"&gt; # 从后端取得url的别名和路径最后的数字 &lt;p&gt;用户名 &lt;input type=\"text\" name=\"user\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;密码 &lt;input type=\"password\" name=\"pwd\" class=\"form-control\"&gt;&lt;/p&gt; &lt;input type=\"submit\" class=\"btn btn-success\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; 名称空间即使不同的APP使用相同的URL名称，URL的命名空间模式也可以让你唯一反转命名的URL。 不使用名称空间，两个app出现同名的路由名字，则匹配到就会匹配，这样的话两个app访问的是同一个网页，并不是不同的 先创建一个新的app manage.py@dj4 &gt; startapp app02 注册app settings.py INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'app01.apps.App01Config', 'app02.apps.App02Config',] 案例1urls.py from django.conf.urls import url, includeurlpatterns = [ url(r'app01/',include('app01.urls')), url(r'app02/',include('app02.urls')),] app01.urls from django.conf.urls import urlfrom app01 import viewsurlpatterns = [ url('^index/',views.index)] app01.views def index(request): return HttpResponse('index1') app02.urls` from django.conf.urls import urlfrom app01 import viewsurlpatterns = [ url('^index/',views.index)] app02.views def index(request): return HttpResponse('index2') 测试 输入 http://127.0.0.1:8000/app01/index/ 输入 http://127.0.0.1:8000/app02/index/ 两个url访问的都是app01下的index的内容，这种是有问题的，如果需要每个app访问的都是自己的网页内容，但是路由名字又和其他app里的是一样的，这种用名称空间解决 案例2给两个app的URL路由关系创建一个名称空间 urls.py from django.conf.urls import url, includeurlpatterns = [ # 第一种写法 # url(r'app01/', include(\"app01.urls\", namespace=\"app01\")), # url(r'app02/', include(\"app02.urls\", namespace=\"app02\")), # 第二种写法 url(r'app01/', include((\"app01.urls\", \"app01\"))), url(r'app02/', include((\"app02.urls\", \"app02\"))),] app01.urls.py from django.conf.urls import urlfrom app01 import viewsurlpatterns = [ url('^index/', views.index)] app02.urls.py from django.conf.urls import urlfrom app02 import viewsurlpatterns = [ url('^index/',views.index)] app01.views.py def index(request): return HttpResponse('index1') app02.views.py def index(request): return HttpResponse('index2')","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"路由层","slug":"路由层","permalink":"http://cjwnb.top/tags/路由层/"}]},{"title":"pycharm快捷键","slug":"pycharm快捷键","date":"2019-07-16T13:40:50.273Z","updated":"2019-07-20T09:20:41.736Z","comments":true,"path":"2019/07/16/pycharm快捷键/","link":"","permalink":"http://cjwnb.top/2019/07/16/pycharm快捷键/","excerpt":"","text":"自动导入模块 默认是ctrl+alt+enter, 但是有时候没用，需要去pycharm里的快捷键配置菜单查看 默认系统配置了2个快捷键，第一个是没用的 第二个设置的快捷键才有用","categories":[{"name":"工具","slug":"工具","permalink":"http://cjwnb.top/categories/工具/"}],"tags":[{"name":"pycharm","slug":"pycharm","permalink":"http://cjwnb.top/tags/pycharm/"}]},{"title":"图书管理系统","slug":"图书管理系统","date":"2019-07-16T05:46:49.629Z","updated":"2019-07-20T10:59:14.078Z","comments":true,"path":"2019/07/16/图书管理系统/","link":"","permalink":"http://cjwnb.top/2019/07/16/图书管理系统/","excerpt":"","text":"图书管理系统表设计书籍表id title price 作者表id name age 出版社id name email 一对多映射关系一本书只能由一个出版社出版，一个出版社可以出版多本书，出版社-书籍 为一对多的关系,所以对书籍表做一个外键 id title price publish_id 多对多映射关系表id book_id author_id 代码实现连接数据库并设置pymysql来连接settings.py 配置数据库并注释中间件’django.middleware.csrf.CsrfViewMiddleware’ MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',]DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'book', 'HOST': '127.0.0.1', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123' &#125;&#125; __init__.py 告诉django用pymysql替换它默认mysql_db模块来连接数据库 import pymysqlpymysql.install_as_MySQLdb() 定义表的字段from django.db import models# Create your models here.class Book(models.Model): # id字段可以不写，默认会帮你创建一个主键id字段 title = models.CharField(max_length=32) price = models.DecimalField(max_digits=8, decimal_places=2) # 一对多外键字段的建立 publish = models.ForeignKey(to='Publish') # 默认是与publish的id字段建立关联 # 多对多外键字段建在关联的两张表的任何一张都可以，建议建在查询评率比较高的那张表里 author = models.ManyToManyField(to='Author') # django orm会自动帮你创建book与author的第三张表 # 注意： 多对多字段不会显示到表的字段中class Publish(models.Model): name = models.CharField(max_length=32) email = models.CharField(max_length=32)class Author(models.Model): name = models.CharField(max_length=32) age = models.IntegerField() 创建表命令行工具执行命令 manage.py@book_mgmt &gt; makemigrationsmanage.py@book_mgmt &gt; migrate 注意外键字段名 orm会自动在字段名后面加_id, 无论你的字段名有没有_id","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"项目","slug":"项目","permalink":"http://cjwnb.top/tags/项目/"}]},{"title":"Django 请求生命周期","slug":"Django 请求生命周期","date":"2019-07-16T03:31:49.436Z","updated":"2019-07-22T01:25:36.181Z","comments":true,"path":"2019/07/16/Django 请求生命周期/","link":"","permalink":"http://cjwnb.top/2019/07/16/Django 请求生命周期/","excerpt":"","text":"简易版本 带中间件","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"}]},{"title":"django小项目","slug":"django小项目","date":"2019-07-15T14:25:52.854Z","updated":"2019-07-17T04:28:58.307Z","comments":true,"path":"2019/07/15/django小项目/","link":"","permalink":"http://cjwnb.top/2019/07/15/django小项目/","excerpt":"","text":"最后需要实现的效果登录，注册，简单的增删改查 后端数据库models.py from django.db import models# Create your models here.class User(models.Model): # User表的主键字段名就是id id = models.AutoField(primary_key=True) # varchar(32) name字段是varchar(32) CharField在定义的时候必须要加max_length参数，不加直接报错 name = models.CharField(max_length=32) # varchar(32) password字段是varchar(32) CharField在定义的时候必须要加max_length参数，不加直接报错 password = models.CharField(max_length=32) def __str__(self): return self.name 路由分发urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login/', views.login), url(r'^reg/', views.reg), url(r'^userlist/', views.userlist), url(r'^delete_user/', views.delete_user), url(r'^edit_user/', views.edit_user), 视图函数views.py from django.shortcuts import render, HttpResponse, redirect# Create your views here.from app01 import modelsdef login(request): if request.method == 'POST': import pymysql # 获取用户输入的用户名和密码 username = request.POST.get('username') password = request.POST.get('password') conn = pymysql.connect( host='127.0.0.1', user=\"root\", password=\"123\", database='django', port=3306, charset='utf8', autocommit=True ) cursors = conn.cursor(pymysql.cursors.DictCursor) cursors.execute('select * from userinfo where name=%s and password=%s', args=(username, password)) user_info = cursors.fetchone() # 如果只查询到一个结果，fetchone直接返回一个字典，而fetchall还是返回一个列表，里面套个字典 if user_info: return HttpResponse('登录成功') return HttpResponse('用户名或密码错误') return render(request, \"login.html\")def reg(request): # 必须要加if判断，如果加的话，永远访问不了网页 # IntegrityError at /reg/ (1048, \"Column 'name' cannot be null\") if request.method == 'POST': # 接收前台通过form表单发送的数据 username = request.POST.get('username') password = request.POST.get('password') print(username, password) # 操作数据库 # 方式1 user_obj = models.User.objects.create(name=username, password=password) # User_obj=User object print(user_obj.pk) # pk获取主键字段对应的值 无论的你主键叫上面名字 print(user_obj.id) # 获取用户数据的id值,可以看到和pk的属性是一样的 print(user_obj.name) # 获取用户数据的name值 print(user_obj.password) # 获取用户数据的password值 # 方式2 # user_obj = models.User(name=username, password=password) # User_obj=User object # models.User.save(user_obj) # 对象调用save方法保存到数据库 # print(user_obj.pk) # pk获取主键字段对应的值 无论的你主键叫上面名字 # print(user_obj.id) # 获取用户数据的id值,可以看到和pk的属性是一样的 # print(user_obj.name) # 获取用户数据的name值 # print(user_obj.password) # 获取用户数据的password值 return redirect('/userlist/') return render(request, 'reg.html')def userlist(request): # 操作数据库 user_obj = models.User.objects.all() # # 获取user表所有的数据 # print(user_obj) # &lt;QuerySet [&lt;User: lyysb&gt;, &lt;User: lyysb&gt;, 。。。&gt; # 只要是QuerySet就可以点query查看获取到当前QuerySet对象的内部sql语句 # print(user_obj.query) # SELECT `app01_user`.`id`, `app01_user`.`name`, `app01_user`.`password` FROM `app01_user` return render(request, 'userlist.html', locals())def delete_user(request): # 删除时候执行的是GET请求，所以在前端提交的时候携带参数传给后端（http://127.0.0.1:8000/delete_user/?id=4） # print(request.GET) id = request.GET.get('id') # 查询操作 最后查询到的是一个queryset对象，里面是一个列表，可以通过first()方法取列表中的第一个元素 # user_obj2 = models.User.objects.filter(id=id) # print(user_obj2) #&lt;QuerySet [&lt;User: luowensg&gt;]&gt; # print(user_obj2.first()) # luowensg models.User.objects.filter(id=id).delete() return redirect('/userlist/')def edit_user(request): ''' [15/Jul/2019 13:35:26] \"GET /userlist/ HTTP/1.1\" 200 3784 访问userlist [15/Jul/2019 13:35:28] \"GET /edit_user/?id=5 HTTP/1.1\" 200 753 通过userlist.html上的修改用户按钮进入edit.html [15/Jul/2019 13:35:33] \"POST /edit_user/?id=5 HTTP/1.1\" 302 0 执行edit.html上的按钮，如果提交的话，就会重定向，因为函数里定义的返回值 return redirect('/userlist/') [15/Jul/2019 13:35:33] \"GET /userlist/ HTTP/1.1\" 200 3780 最后重定向到userlist.html上查看结果，所以是GET请求 :param request: :return: ''' # 4. 我们要操作数据库，更改一条数据，需要拿到表中的id字段的值 # 当用户点击修改用户按钮，跳转到edit.html,这个行为是GET，然后修改完数据之后提交，这个动作是POST # 我们在前端在form表单里面配置form表单中的路径参数携带?id=xx，所以可以通过request.GET.get('id')拿到id的值 # 我们也可以新建一个input标签，type设置为hidden,然后配置value这个属性，value这个属性的值由后台的数据库对象user_obj.id获得 if request.method == 'POST': username = request.POST.get('username') password = request.POST.get('password') # 方式1 新建一个input标签，type设置为hidden,然后配置value这个属性，value这个属性的值由后台的数据库对象user_obj.id获得 id=request.POST.get('id') # 方式2 在前端在form表单里面配置form表单中的路径参数携带?id=xx，通过request.GET.get('id')拿到id的值 # id = request.GET.get('id') # 操作数据库修改数据 # 方式1 # models.User.objects.filter(id=id).update(name=username,password=password) # 方式2 user_obj=models.User.objects.filter(id=id) user=user_obj.first() # lyysb 输出lyysb而不是一个对象，因为在ORM中类定义的时候定义了__str__，限定输出对象的name字段 # lxxsb &lt;class 'app01.models.User'&gt; # user_obj就是一个通过数据库查询到的一个queryset对象，queryset这个对象是一个列表，first方法就是把列表中的第一个元素user取出来了 # 这里通过id进行匹配，id这个字段在数据库中是唯一的，所以最后匹配到的就是只有一行数据对应的一个对象user # 我们可以通过user的.语法对查询到的这一行的数据库的字段进行修改 user.name=username user.password=password user.save() # 操作完数据库重定向到userlist网页查看用户列表，查看是否操作成功 return redirect('/userlist/') # 1.获取用户想要修改的id id = request.GET.get('id') # 2. 将该数据查询出来渲染到一个编辑页面 # 查询数据方式1 # filter当条件不存在的情况下会返回None # 比如说 user_obj = models.User.objects.filter(id=8888).first()，返回None user_obj = models.User.objects.filter(id=id).first() # 查询数据方式2 # 弊端: 如果查询不到数据对象就会报错，所有已不推荐使用 # 比如说 user_obj = models.User.objects.get(id=2222) # 就会报 500的错误 # app01.models.DoesNotExist: User matching query does not exist. # [15/Jul/2019 12:31:27] \"GET /edit_user/?id=5 HTTP/1.1\" 500 69867 # user_obj = models.User.objects.get(id=id) # owensb,这里直接显示name， # 因为在models类里面定义了__str__定义输出为对象的name字段的值（User object.name)， # 如果不设置，输出为对象 User object # print(user_obj) # print(type(user_obj)) # &lt;class 'app01.models.User'&gt; # 3. 将当前数据渲染到一个编辑页面上，只要是渲染页面相关的操作，就应该想到用render return render(request, 'edit.html', &#123;'user_obj': user_obj&#125;) 设置settings.py # 注册app01INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'app01.apps.App01Config',]# 暂时取消'django.middleware.csrf.CsrfViewMiddleware',MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',]# 数据库配置DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'django2', 'HOST': '127.0.0.1', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123' &#125;&#125;# 静态文件配置 (static主要存放bootstrap,css,fonts,img,js等目录)STATIC_URL = '/static/'STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static') __init__.py应用和项目目录都有这个文件，建在任何一个文件里都可以 import pymysqlpymysql.install_as_MySQLdb() # 告诉django用pymysql代替mysqldb连接数据库 前端userlist.html &lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1&gt;用户列表&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\"&gt; &lt;a href=\"/reg/\" class=\"btn btn-success\"&gt;注册用户&lt;/a&gt; &lt;a href=\"/login/\" class=\"btn btn-warning\"&gt;用户登录&lt;/a&gt; &lt;table class=\"table table-hover table-bordered table-striped table-condensed\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;password&lt;/th&gt; &lt;th&gt;action&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for user in user_obj %&#125; &lt;tr&gt; &lt;td&gt; &#123;&#123; user.pk &#125;&#125;&lt;/td&gt; &lt;td&gt; &#123;&#123; user.name &#125;&#125;&lt;/td&gt; &lt;td&gt; &#123;&#123; user.password &#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=\"/delete_user/?id=&#123;&#123; user.pk &#125;&#125;\" class=\"btn btn-danger\"&gt;删除用户&lt;/a&gt; &lt;a href=\"/edit_user/?id=&#123;&#123; user.pk &#125;&#125;\" class=\"btn btn-primary\"&gt;修改用户&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; reg.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;注册&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1&gt;注册页面&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\"&gt; &lt;form action=\"\" method=\"post\"&gt; &lt;p&gt;用户名&lt;input type=\"text\" name=\"username\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;密码&lt;input type=\"password\" name=\"password\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" class=\"btn btn-primary\"&gt;&lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; login.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1 class=\"h2\"&gt;登录页面&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\" &gt; &lt;form action=\"/login/\" method=\"post\"&gt; &lt;p&gt;用户名: &lt;input type=\"text\" class=\"form-control\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;密码: &lt;input type=\"password\" class=\"form-control\" name=\"password\"&gt; &lt;/p&gt; &lt;input type=\"submit\" value=\"登录\" class=\"btn btn-primary\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; edit.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;编辑&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1&gt;修改数据&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\"&gt; &lt;form action=\"/edit_user/?id=&#123;&#123; user_obj.id &#125;&#125;\" method=\"post\"&gt; &lt;p&gt;&lt;input type=\"hidden\" value=\"&#123;&#123; user_obj.id &#125;&#125;\" name=\"id\"&gt;&lt;/p&gt; &lt;p&gt;username&lt;input type=\"text\" name=\"username\" value=\"&#123;&#123; user_obj.name &#125;&#125;\"&gt;&lt;/p&gt; &lt;p&gt;password&lt;input type=\"password\" name=\"password\" value=\"&#123;&#123; user_obj.password&#125;&#125;\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" value=\"修改\" class=\"btn btn-warning\"&gt;&lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"}]},{"title":"django 路由层之分组","slug":"Django路由层之分组","date":"2019-07-09T16:59:06.950Z","updated":"2019-07-20T09:29:02.917Z","comments":true,"path":"2019/07/10/Django路由层之分组/","link":"","permalink":"http://cjwnb.top/2019/07/10/Django路由层之分组/","excerpt":"","text":"正则匹配urls.py urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^test', views.test), url(r'^testadd',views.testadd)] django项目目录中, 路由层就是urls.py这个文件来进行控制 urlpatterns这个变量定义的一个列表，列表中通过url这个函数进行路由分发到视图层 url函数中是通过正则匹配浏览器中输入的网址中的路径中的最后一位,最后一位的字符串就是admin,test,testadd. 证明urls.pyfrom django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url('test', views.test), url('testadd',views.testadd)] views.pydef test(request): return HttpResponse('test')def testadd(request): return HttpResponse('testadd') 浏览器测试 输入 http://127.0.0.1:8000/test/， 返回test 输入 http://127.0.0.1:8000/testadd/， 也是返回test 总结上面的结果并不是我们想要的，我们希望的结果是: 输入 http://127.0.0.1:8000/testadd/，页面返回testadd 输入 http://127.0.0.1:8000/test/，页面返回test 而从上面的结果验证可知道： 路由文件中url函数后面跟着的第一个参数是正则表达式,匹配规则按照从上往下一次匹配,匹配到一个之后立即匹配。 当我们输入 http://127.0.0.1:8000/testadd/, url(‘test’, views.test),这一个元素先匹配到了testadd,就相当于re.findall(‘test’,’testall’),这样就匹配到了test这个字符串，对应的会执行视图层中的test函数，所以最后返回来test &gt;&gt;&gt; import re&gt;&gt;&gt; re.findall('test','testall')['test'] 解决方案1:urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url('test/', views.test), url('testadd/',views.testadd)] 浏览器测试 输入 http://127.0.0.1:8000/test/， 返回test 输入 http://127.0.0.1:8000/testadd/，页面返回testadd 但是这里有个问题： 当我们输入 http://127.0.0.1:8000/test/sdsddsdsfsdf， 正常返回test 当我们输入 http://127.0.0.1:8000/dsdsdsdssdtest/sdsddsdsfsdf, 正常返回test 当我们输入 http://127.0.0.1:8000/testadd/sdsddsdsfsdf， 正常返回testadd 当我们输入 http://127.0.0.1:8000/dsdsdsdssdtestadd/sdsddsdsfsdf， 正常返回testadd 解决方案2因为路由匹配是正则匹配的规律，所以使用正则表达式进行精准匹配 urls.py urlpatterns = [ url(r'^admin/', admin.site.urls), url('^test/$', views.test), url('^testadd/$',views.testadd)] 新需求希望主页也有内容, 用户输错网址给个提示信息 urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^$',views.home), url('^test/$', views.test), url('^testadd/$',views.testadd), url(r'', views.error),] views.py from django.shortcuts import render,redirect,HttpResponse# Create your views here.def home(request): return HttpResponse('这是首页')def error(request): return HttpResponse('你输了什么鬼')def test(request): return HttpResponse('test')def testadd(request): return HttpResponse('testadd') 浏览器测试 路由分发url(&#39;正则表达式&#39;,&#39;视图函数内存地址&#39;) django每一个app下面都可以有自己的url.py 路由层，templates文件夹，static文件夹 项目名下urls.py(总路由)不再做路由与视图函数的匹配关系而是做路由的分发 from django.conf.urls import include# 路由分发 注意路由分发总路由千万不要$结尾url(r'^app01/',include(app01_urls)),url(r'^app02/',include(app02_urls))# 在应用下新建urls.py文件，在该文件内写路由与视图函数的对应关系即可from django.conf.urls import urlfrom app01 import viewsurlpatterns = [ url(r'^index/',views.index)] 案例urls.py from django.conf.urls import url, includeurlpatterns = [ url(r'app01/',include('app01.urls')), url(r'app02/',include('app02.urls')),] app01.urls from django.conf.urls import urlfrom app01 import viewsurlpatterns = [ url('^index/',views.index)] app01.views def index1(request): return HttpResponse('index1') app02.urls` from django.shortcuts import render,HttpResponse# Create your views here.def index(request): return HttpResponse('index2') app02.views def index2(request): return HttpResponse('index2') 分组无名分组将加括号的正则表达式匹配到的内容当做位置参数自动传递给对应的视图函数 默认匹配到后，默认把request一定会传给视图函数，因为url函数是采取正则匹配，正则匹配中如果匹配到分组的内容，则输出分组，所以我们可以通过正则表达式分组的特点将匹配到的分组的内容传递给视图函数，但是视图函数需要增加一个形参来接收正则匹配匹配到的分组的内容 &gt;&gt;&gt; re.findall('test/([0-9]+)','test/2018')['2018']&gt;&gt;&gt; re.findall('test/([0-9]+)','test/20183333333')['20183333333'] url(r'^test/(\\d+)/', views.test), # 匹配一个或多个数字def test(request,xxx): print(xxx) return HttpResponse('test') url.py urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^$', views.home), # url(r'^test/[0-9]&#123;4&#125;/', views.test), url(r'^test/(\\d+)/', views.test), # 匹配一个或多个数字 url(r'^testadd/', views.testadd), # url(r'',views.error)] views.py from django.shortcuts import render,HttpResponse,redirectdef test(request): return HttpResponse('test')def testadd(request): return HttpResponse('testadd')def home(request): return HttpResponse('首页')def error(request): return HttpResponse('广告位招租') 显示的页面 修改代码views.py from django.shortcuts import render,HttpResponse,redirectdef test(request,xxx): print(xxx) return HttpResponse('test') 有名分组将加括号的正则表达式的内容当做关键字参数自动传递给响应的视图函数 正则表达式复习&gt;&gt;&gt; a=re.match('test/(?P&lt;name&gt;[0-9]+)','test/123')&gt;&gt;&gt; a.group('name')'123'&gt;&gt;&gt; a=re.match('test/(?P&lt;name&gt;\\d+)','test/123')&gt;&gt;&gt; a.group('name')'123' 使用 url(r’^test/(?P\\d+)/‘, views.test) urls.py urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^$', views.home), # url(r'^test/[0-9]&#123;4&#125;/', views.test), # 无名分组 # url(r'^test/(\\d+)/', views.test), # 匹配一个或多个数字 # 有名分组 url(r'^test/(?P&lt;year&gt;\\d+)/', views.test), # 匹配一个或多个数字，并可以通过year取值 url(r'^testadd/', views.testadd), # url(r'',views.error) views.py def test(request,year): # 这里的形参year必须和路由层中正则匹配的名字是一样的 print(year) return HttpResponse('test') 注意 有名分组和无名分组不能混着用,但是多个有名分组和多个无名分组可以连用 测试 同时使用无名分组和有名分组, 报错 urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ # 测试 同时使用无名分组和有名分组 url(r'test/(?P&lt;year&gt;\\d+)/[0-9](\\d+)',views.test),] views.py def test(request,xxx,year): print(year) return HttpResponse('test') 使用多个有名分组 urls.py urlpatterns = [ # 测试 使用多个无名分组 url(r'test/(?P&lt;year&gt;\\d+)/(?P&lt;month&gt;\\d+)/(?P&lt;day&gt;\\d+)',views.test),] views.py from django.shortcuts import render,HttpResponse,redirectdef test(request,month,day,year): print(year) return HttpResponse('test')","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"路由层","slug":"路由层","permalink":"http://cjwnb.top/tags/路由层/"}]},{"title":"django基础","slug":"Django基础","date":"2019-07-09T06:13:20.537Z","updated":"2019-07-22T02:02:10.391Z","comments":true,"path":"2019/07/09/Django基础/","link":"","permalink":"http://cjwnb.top/2019/07/09/Django基础/","excerpt":"","text":"MVC M: 模型层（models.py） V: 视图层 (views.py) C:控制器（Controller） urls.py MTVDjango是一种MTV的设计模式，各组件之间保持松耦合关系 本质：Django的MTV也是MVC M 代表模型 (Model): 负责业务对象和数据库的关系映射(ORM)T 代表模板(Template): 负责如何把页面展示给用户(html)V 代表视图(View): 负责业务逻辑，并在适当时候调用Model和Template除了以上三层外，还需要一个URL分发器，它的作用是将一个个URL的页面分发给不同的view处理，View再调用响应的Model和Template 设置浏览器刷新后不读取缓存 下载Django# pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple django==1.11.10 查看Django$ python&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path['', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/lib-dynload', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages']&gt;&gt;&gt; exit()$ cd /Library/Frameworks/Python.framework/Versions$ open 3.6/ 更快速的方法django-admin $ django-adminType 'django-admin help &lt;subcommand&gt;' for help on a specific subcommand.Available subcommands:[django] check compilemessages createcachetable dbshell diffsettings dumpdata flush inspectdb loaddata makemessages makemigrations migrate runserver sendtestemail shell showmigrations sqlflush sqlmigrate sqlsequencereset squashmigrations startapp startproject test testserverNote that only Django core commands are listed as settings are not properly configured (error: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.). Django的创建和启动命令行方式# 创建项目$ cd My_pro/$ django-admin.py startproject mysites# 创建应用$ cd mysites/$ python3 manage.py startapp blog# 启动项目$ python3 manage.py runserver 访问 http://127.0.0.1:8000 pycharm Django目录介绍first_pro:&gt;&gt;&gt; app01: 应用相关的目录 migrations: 数据库迁移相关数据 admin.py: Django后台管理相关 models.py: 模型表相关（数据库） views.py: 视图函数相关&gt;&gt;&gt; first_pro: 项目相关的目录 settings.py: 包含了项目的默认配置，包括数据库信息，调试标志以及其他一些工作的变量 urls.py: 路由文件（控制器）负责把URL模式映射到应用程序 wsgi.py: 启动socket 服务端的文件&gt;&gt;&gt; templates: 项目用到的所有html文件&gt;&gt;&gt;manage.py: Django项目里面的工具，通过它可以调用Django shell和数据库等 案例通过Django查看时间的一个简单页面 后端 url.py 当执行timer函数时候，会把request都传给函数views.timer(request),所以views的函数必须加形参request urlpatterns = [ url('^admin/', admin.site.urls), url('^timer/', views.timer), ] views.py def timer(request): import time ctime = time.time() return render(request, \"timer.html\", &#123;'ctime': ctime&#125;) 前端 timer.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;当前时间:&#123;&#123; ctime &#125;&#125;&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt; Django 静态文件配置通过路径访问 http://127.0.0.1:8000/static/bootstrap.js 无法访问 配置settings.py STATIC_URL = '/static/'STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static'),] time.html &lt;script src=\"/static/bootstrap.js\"&gt;&lt;/script&gt; 地址栏 http://127.0.0.1:8000/static/bootstrap.js， 可以直接访问js文件 注意 在settings.py 中的STATIC_URL定义了什么别名，script标签中导入的路径的根就从哪里开始 # settings.py 配置STATIC_URL = '/xxx/'STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static'),]# time.html&lt;script src=\"/static/bootstrap.js\"&gt;&lt;/script&gt; 以上的情况，地址栏输入什么都会有异常信息。 输入 http://127.0.0.1:8000/static/bootstrap.js映射关系是xxx,访问static当然会报404错误，路径根本就是不存在的 输入 http://127.0.0.1:8000/xxx/bootstrap.js可以正常访问bootstrap.js，但是还是有问题的 当输入 http://127.0.0.1:8000/timer/在network中看到bootstrap.js是飘红的,因为在前端的script标签引入bootstrap的路径写错了 &lt;script src=\"/static/bootstrap.js\"&gt;&lt;/script&gt;# 这个时候映射 /static/bootstrap.js的别名是xxx,所以路径写成 &lt;script src=\"/xxx/bootstrap.js\"&gt;&lt;/script&gt; 就没问题 Django三剑客from django.shortcuts import render,HttpResponse,redirectHttpResponse 返回字符串render 返回一个HTML页面redirect 重定向到一个HTML页面 登录功能form表单触发提交数据的动作的两种方式&gt;&lt;input type=\"submit\"&gt;&gt; &lt;button type=\"submit\"&gt;&lt;/button&gt; form表单提交数据的地址如何指定及方式 action属性控制提交的地址，比如说http://127.0.0.1:8080/login 1. 全路径 &lt;form action=\"http://127.0.0.1:8000/login/\"&gt;2. 只写路径后缀 &lt;form action=\"/login\"&gt;3. 不写 &lt;form action=\"\"&gt; 默认往当前路径提交,当前路径指的是打开页面所在的路径，也就是http://127.0.0.1:8080/login） 获取用户端提交的请求方式request.method 根据客户端请求方式的不同执行不同的逻辑代码views.py def login(request): # 获取用户端提交的请求方式 print(request.method) # 拿到的请求方式是全大写的字符串 if request.method=='GET': return render(request,'login.html') return HttpResponse('接收成功') urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login/', views.login),] login.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1 class=\"h2\"&gt;登录页面&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\" &gt; &lt;form action=\"/login/\" method=\"post\"&gt; &lt;p&gt;用户名: &lt;input type=\"text\" class=\"form-control\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;密码: &lt;input type=\"password\" class=\"form-control\" name=\"password\"&gt; &lt;/p&gt; &lt;input type=\"submit\" value=\"登录\" class=\"btn btn-primary\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; 获取提交的表单的value列表里面所有的元素request.POST.getlist(key) 我们通过input标签提交的表单返回给后台的是一个字典类似于 &lt;QueryDict: &#123;'username': ['lxxsb','lyysb'], 'password': ['123']&#125;&gt;字典中的key就是input标签中name属性定义的名字而value则是用户输入的内容，value是通过一个列表的方式展现给后台默认后台通过request.POST.get 只会取到value列表的最后一个元素如果想要取到所有元素，要使用getlist views.py def login(request): # 获取用户端提交的请求方式 print(request.method) # 拿到的请求方式是全大写的字符串 if request.method == 'POST': print(request.POST) # 把它当成一个大字典，里面存放了客户端post提交的所有数据 # &lt;QueryDict: &#123;'username': ['lxxsb', 'lyysb'], 'password': ['123']&#125;&gt; print(request.POST.get('username')) # value虽然是个列表，但是获取value时候拿到的却是单个元素 # 默认只会取value里面的最后一个元素 print(request.POST.getlist('username')) #要想一次性获取value列表里面所有的数据需要用getlist() # ['lxxsb', 'lyysb'] print(request.POST['password']) # 不推荐使用该方法取数据，如果不存在就直接报错了 return HttpResponse('ok') return render(request, \"login.html\") urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login/', views.login),] login.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1 class=\"h2\"&gt;登录页面&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\" &gt; &lt;form action=\"/login/\" method=\"post\"&gt; &lt;p&gt;用户名: &lt;input type=\"text\" class=\"form-control\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;用户名: &lt;input type=\"text\" class=\"form-control\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;密码: &lt;input type=\"password\" class=\"form-control\" name=\"password\"&gt; &lt;/p&gt; &lt;input type=\"submit\" value=\"登录\" class=\"btn btn-primary\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; 获取get 请求的数据规则和POST请求一模一样 浏览器输入 http://127.0.0.1:8000/login/?username=lyysb&amp;password=123&amp;password=456 views.py (其他文件如上) def login(request): # 获取用户端提交的请求方式 print(request.method) # 拿到的请求方式是全大写的字符串 print(request.GET) # &lt;QueryDict: &#123;'username': ['lyysb'], 'password': ['123', '456']&#125;&gt; print(request.GET.get('password')) # 456 print(request.GET.getlist('password')) # ['123', '456'] return render(request, \"login.html\") pymysql 完成登录功能urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login/', views.login),] views.py from django.shortcuts import render, HttpResponse, redirect# Create your views here.def login(request): if request.method == 'POST': import pymysql # 获取用户输入的用户名和密码 username = request.POST.get('username') password = request.POST.get('password') conn = pymysql.connect( host='127.0.0.1', user=\"root\", password=\"123\", database='django', port=3306, charset='utf8', autocommit=True ) cursors = conn.cursor(pymysql.cursors.DictCursor) cursors.execute('select * from userinfo where name=%s and password=%s', args=(username, password)) user_info = cursors.fetchone() # 如果只查询到一个结果，fetchone直接返回一个字典，而fetchall还是返回一个列表，里面套个字典 if user_info: return HttpResponse('登录成功') return HttpResponse('用户名或密码错误') return render(request, \"login.html\") login.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1 class=\"h2\"&gt;登录页面&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\" &gt; &lt;form action=\"/login/\" method=\"post\"&gt; &lt;p&gt;用户名: &lt;input type=\"text\" class=\"form-control\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;密码: &lt;input type=\"password\" class=\"form-control\" name=\"password\"&gt; &lt;/p&gt; &lt;input type=\"submit\" value=\"登录\" class=\"btn btn-primary\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; pycharm 连接数据库 查看pycharm支持的数据库 下载驱动 测试用户名是否正确 勾选需要显示的库 查看到MYSQL数据库已经在pycharm的数据库列表中 添加数据后同步到数据库 Django 连接数据库 需要修改配置文件settings.py DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': os.path.join(BASE_DIR, 'app01'), 'HOST': '127.0.0.1', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123' &#125;&#125; 告诉django用pymysql替换它默认mysql_db模块来连接数据库 方式1: 在项目文件夹下面的init.py方式2: 在应用文件夹下面的init.py __init__.py import pymysqlpymysql.install_as_MySQLdb() # 告诉django用pymysql代替mysqldb连接数据库","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"}]},{"title":"模拟一个简单的web请求","slug":"模拟一个简单的web请求","date":"2019-07-08T14:42:06.275Z","updated":"2019-07-22T02:11:23.525Z","comments":true,"path":"2019/07/08/模拟一个简单的web请求/","link":"","permalink":"http://cjwnb.top/2019/07/08/模拟一个简单的web请求/","excerpt":"","text":"引子描述下当我们在浏览器输入一个url网址，比如说www,jd.com, 然后显示整个页面的过程1. 当输入http://www.jd.com的时候，先把请求发送到本地DNS服务器里找www.jd.com对应的Ip地址和端口，如果有，返回ip地址和端口，2. 如果本地DNS服务器里面没有字符串 www.jd.com对应的ip地址和端口，则会去DNS根域服务器去找（root-server.net）,根域会把字符串交给顶级域服务器.com DNS服务器，然后会 将字符串交个权威DNS服务器找到jd.com,然后再去二级域名服务器找到www.jd.com3. 当客户端(浏览器)获得了ip地址和端口，客户端发送请求到响应的服务器，服务器响应需求，客户端拿到响应结果，渲染页面。 字符串和字节的转换\\&gt;&gt;&gt; s=\"hello\"\\&gt;&gt;&gt; s'hello'\\&gt;&gt;&gt; bytes(s,encoding=\"utf-8\")b'hello'\\&gt;&gt;&gt; b=bytes(s,encoding=\"utf-8\")\\&gt;&gt;&gt; bb'hello'\\&gt;&gt;&gt; str(b,encoding='utf-8')'hello' 模拟一个简单的web请求from socket import *sock = socket(AF_INET, SOCK_STREAM)sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)sock.bind(('127.0.0.1', 8800))sock.listen(5)while True: # 不断地等待接收客户端的链接,保证服务器不中断 print('\\033[32mserver waiting...\\033[0m') client, addr = sock.accept() # 客户端套接字对象，客户端地址端口 data = client.recv(1024) print('data', data) # client.send(b'hello world') # 浏览器端会显示 127.0.0.1 发送的响应无效 # 浏览器要访问数据必须加上HTTP/1.1 状态码 # HTTP/1.1 200 OK 响应首行 hello world 响应体 响应首行和响应体之前用\\r\\n\\r\\n，否则响应体无法渲染显示 with open('index.html','rb') as f: data=f.read() client.send(b'HTTP/1.1 200 OK\\r\\n\\r\\n%s'%data) client.close() # index.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 style=\"color: red;\"&gt;宝贝 我来了&lt;/h1&gt;&lt;img src=\"http://s14.sinaimg.cn/middle/4b955cd7xcb1739815c4d&amp;690\" alt=\"\"&gt;&lt;a href=\"http://www.w3school.com.cn/\"&gt;click&lt;/a&gt;&lt;div style=\"height: 200px\"&gt;&lt;/div&gt;&lt;div&gt; &lt;h1 style=\"color: yellow; background-color: gray\"&gt;张帆喜欢的类型&lt;/h1&gt; &lt;img src=\"http://s8.sinaimg.cn/bmiddle/005DIuBKgy6KewCX5iv97&amp;690\" alt=\"\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; /usr/local/bin/python3.6 /Users/cjw/Desktop/pycharm_project/Django/Weby应用程序/JDserver.pyserver waiting...data b'GET / HTTP/1.1\\r\\nHost: 127.0.0.1:8800\\r\\nConnection: keep-alive\\r\\nCache-Control: max-age=0\\r\\nUpgrade-Insecure-Requests: 1\\r\\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36\\r\\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\\r\\nAccept-Encoding: gzip, deflate, br\\r\\nAccept-Language: zh-CN,zh;q=0.9\\r\\n\\r\\n'server waiting...data b'GET /favicon.ico HTTP/1.1\\r\\nHost: 127.0.0.1:8800\\r\\nConnection: keep-alive\\r\\nPragma: no-cache\\r\\nCache-Control: no-cache\\r\\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36\\r\\nAccept: image/webp,image/apng,image/*,*/*;q=0.8\\r\\nReferer: http://127.0.0.1:8800/\\r\\nAccept-Encoding: gzip, deflate, br\\r\\nAccept-Language: zh-CN,zh;q=0.9\\r\\n\\r\\n'server waiting... 浏览器会解释url请求发生了什么response: 从客户端接收过来的一堆HTML字符串(要放到页面的一堆字符串)Preview: 浏览器解析服务端发送的的HTML字符串，将这些字符串解析成用户能看到的格式，preview能够看到一个这样的结果所以浏览器也可以看成一个解释期，解释HTML标记语言 HTTP协议主要由请求协议和响应协议构成 请求协议：浏览器给服务器发的格式的限定 响应协议：服务器给浏览器发的格式的限定 HTTP请求协议结构：请求首行+请求头+\\r\\n\\r\\n+请求体服务器通过\\r\\n来识别请求首行，请求头以及请求体请求首行和请求头之间，多个请求体之间用一个\\r\\n分割，最后一个请求头和请求体之间用两个\\r\\n分割请求方法主要分get和postget 没有请求体 post 有请求体 get 和 post请求1. GET请求提交的数据会放在url之后，以？分割URL和传输的数据，参数之间用&amp;相连，比如http://127.0.0.1:8800/?name=changwei&amp;pwd=GET2. GET 提交的数据大小有限制(因为浏览器对URL长度有限制)，而POST方法提交的数据没有限制3. GET与POST都是提交数据的方式，当需要对服务器所在的数据库的数据进行查询的时候提交GET请求，添加或删除提交POST请求 案例1 （get请求）'GET / HTTP/1.1\\r\\nHost: 127.0.0.1:8800\\r\\nConnection: keep-alive\\r\\nCache-Control: max-age=0\\r\\nUpgrade-Insecure-Requests: 1\\r\\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36\\r\\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\\r\\nAccept-Encoding: gzip, deflate, br\\r\\nAccept-Language: zh-CN,zh;q=0.9\\r\\n\\r\\n' 请求首行GET / HTTP/1.1\\r\\nHost: 127.0.0.1:8800格式： 方法(get/post)+发送请求的服务器的路径（URI /form/entry)+协议版本(HTTP/1.1) 请求头请求头 Connection: keep-alive请求头 Pragma: no-cache请求头 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36请求头 Accept: image/webp,image/apng,image/*,*/*;q=0.8请求头 Referer: http://127.0.0.1:8800请求头 Accept-Encoding: gzip, deflate, br请求头 Accept-Language: zh-CN,zh;q=0.9 请求体1. get请求没有请求体 所以最后的请求体部分是空的2. get请求提交的数据会放在url之后，以？分割URL和传输的数据，参数之间用&amp;相连，比如http://127.0.0.1:8800/?name=changwei&amp;pwd=123'GET /?name=changwei&amp;pwd=123 HTTP/1.1\\r\\nHost: 127.0.0.1:8800\\r\\nConnection: keep-alive\\r\\nUpgrade-Insecure-Requests: 1\\r\\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36\\r\\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\\r\\nAccept-Encoding: gzip, deflate, br\\r\\nAccept-Language: zh-CN,zh;q=0.9\\r\\n\\r\\n' 案例2 （post请求）# 服务端from socket import *sock = socket(AF_INET, SOCK_STREAM)sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)sock.bind(('127.0.0.1', 8800))sock.listen(5)while True: # 不断地等待接收客户端的链接,保证服务器不中断 print('\\033[32mserver waiting...\\033[0m') client, addr = sock.accept() # 客户端套接字对象，客户端地址端口 data = client.recv(1024) print('data', data) # client.send(b'hello world') # 浏览器端会显示 127.0.0.1 发送的响应无效 # 浏览器要访问数据必须加上HTTP/1.1 状态码 # HTTP/1.1 200 OK 响应首行 hello world 响应体 响应首行和响应体之前用\\r\\n\\r\\n，否则响应体无法渲染显示 with open('login.html','rb') as f: data=f.read() client.send(b'HTTP/1.1 200 OK\\r\\n\\r\\n%s'%data) client.close()# index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"http://127.0.0.1:8800/\" method=\"post\"&gt; 用户名 &lt;input type=\"text\" name=\"user\"&gt; 密码 &lt;input type=\"password\" name=\"pwd\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 'POST / HTTP/1.1\\r\\nHost: 127.0.0.1:8800\\r\\nConnection: keep-alive\\r\\nContent-Length: 21\\r\\nCache-Control: max-age=0\\r\\nOrigin: http://127.0.0.1:8800\\r\\nUpgrade-Insecure-Requests: 1\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36\\r\\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\\r\\nReferer: http://127.0.0.1:8800/\\r\\nAccept-Encoding: gzip, deflate, br\\r\\nAccept-Language: zh-CN,zh;q=0.9\\r\\n\\r\\nuser=changwei&amp;pwd=123' 请求首行POST / HTTP/1.1\\r\\nHost: 127.0.0.1:8800Cache-Control: max-age=0\\r\\nOrigin: http://127.0.0.1:8800Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Referer: http://127.0.0.1:8800/\\r\\nAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9 请求头Connection: keep-alive\\r\\nContent-Length: 21 请求体user=changwei&amp;pwd=123 HTTP响应协议和请求协议一样，主要由响应首行，响应头，响应体组成 常见的响应状态码1xx Informational(信息性状态码) 接受的请求正在处理2xx Success(成功状态码) 请求正常处理完毕3xx Redirection(重定向状态码) 需要进行附加操作以完成请求 (域名地址变了了,跳转到新的域名地址，这种情况浏览器发2次请求)4xx Client Error (客户端错误状态码) 服务器无法处理请求 404 (not found) 403(forbidden 禁止访问) 5xx Server Error(服务器错误状态码) 服务器处理请求出错 500(服务端代码错误) 502(网关错误 bad gateway) 通过socket实现web框架server.pyimport timefrom socket import *def f1(): # 静态网站 fp = open('index.html', 'r', encoding='utf-8') data = fp.read() fp.close() return bytes(data, encoding='utf-8')def f2(): fp = open('article.html', 'r', encoding='utf-8') data = fp.read() ctime = time.time() data = data.replace(\"@@content@@\", str(ctime)) fp.close() return bytes(data, encoding='utf-8')def f3(): import pymysql conn = pymysql.connect(host='127.0.0.1', user='root', password='123', db='youku', charset='utf8') cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) sql = \"select id,name,password,register_time from user\" cursor.execute(sql) res = cursor.fetchall() print(res) ''' [&#123;'id': 1, 'name': 'lxx', 'password': '202cb962ac59075b964b07152d234b70', 'register_time': '2019-06-26 21:48:47'&#125;, &#123;'id': 2, 'name': '111', 'password': '698d51a19d8a121ce581499d7b701668', 'register_time': '2019-06-26 21:49:10'&#125;] ''' res_list = [] for user in res: res_str = '&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;' % ( user['id'], user['name'], user['password'], user['register_time']) res_list.append(res_str) s = ''.join(res_list) fp = open('content.html', 'r', encoding='utf-8') data = fp.read() data = data.replace(\"@@content@@\", s) return bytes(data, encoding='utf-8') ### 需要将html代码和mysql结果融合def f4(): pass# 路由系统routes = [ ('/xxx', f1), ('/ooo', f2), ('/hhh', f3), ('/kkk', f4)]def run(): sk = socket() sk.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) sk.bind(('127.0.0.1', 8081)) sk.listen(5) while True: conn, addr = sk.accept() buf = conn.recv(8096) data = str(buf, encoding='utf-8') header_list = data.split('\\r\\n\\r\\n')[0].split('\\r\\n')[0] print(header_list) uri = header_list.split(' ')[1] func_name = None for items in routes: if items[0] == uri: func_name = items[1] break if func_name: res = func_name() else: res = b'404 not found' conn.send(b'HTTP/1.1 200 OK\\r\\nCache-Control: private\\r\\n\\r\\n') conn.send(res)if __name__ == '__main__': run() index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;this is index&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; content.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=\"1px\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;password&lt;/th&gt; &lt;th&gt;register_time&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; @@content@@ &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; article.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; @@content@@&lt;/body&gt;&lt;/html&gt; 通过wsgiref实现web框架step 1访问不同的url路径可以跳转到不同的网页from wsgiref.simple_server import make_serverdef application(environ, start_response): # 按着httpd协议解析数据（将所有请求存到一个字典里）: environ # 按着httpd协议组装数据（生成数据 响应首行，响应头）： start_response # 当前的请求路径 path = environ.get('PATH_INFO') start_response('200 OK', [('Content-Type', 'text/html')]) # 生成数据 请求首行，请求头，请求体 if path == \"/login\": with open('login.html', 'rb') as f: global data data = f.read() if path == '/index': with open('index.html', 'rb') as f: data = f.read() return [data]# 封装sockethttped = make_server(\"127.0.0.1\", 8060, application)# 等待客户连接: conn,addr=sock.accept()httped.serve_forever()# login.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"http://127.0.0.1:8800/\" method=\"post\"&gt; 用户名 &lt;input type=\"text\" name=\"user\"&gt; 密码 &lt;input type=\"password\" name=\"pwd\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;# index.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 style=\"color: red;\"&gt;宝贝 我来了&lt;/h1&gt;&lt;img src=\"http://s14.sinaimg.cn/middle/4b955cd7xcb1739815c4d&amp;690\" alt=\"\"&gt;&lt;a href=\"http://www.w3school.com.cn/\"&gt;click&lt;/a&gt;&lt;div style=\"height: 200px\"&gt;&lt;/div&gt;&lt;div&gt; &lt;h1 style=\"color: yellow; background-color: gray\"&gt;张帆喜欢的类型&lt;/h1&gt; &lt;img src=\"http://s8.sinaimg.cn/bmiddle/005DIuBKgy6KewCX5iv97&amp;690\" alt=\"\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 设置页面图标为京东图标from wsgiref.simple_server import make_serverdef application(environ: dict, start_response): start_response('200 ok', [('Content-Type','text/html')]) print(\"PATH\",environ.get('PATH_INFO')) path=environ.get('PATH_INFO') if path=='/favicon.ico': with open('favicon.ico','rb') as f: data=f.read() return [data] return [b'&lt;h1&gt;Hello,web!&lt;/h1&gt;']httped = make_server(\"127.0.0.1\", 8080, application)httped.serve_forever() step 2通过列表的映射来使得访问不同的url路径可以跳转到不同的网页 from wsgiref.simple_server import make_serverdef login(): with open('login.html', 'rb') as f: data = f.read() return datadef index(): with open('index.html', 'rb') as f: data = f.read() return datadef favi(): with open('favicon.ico', 'rb') as f: data = f.read() return datadef application(environ: dict, start_response): start_response('200 ok', [('Content-Type', 'text/html')]) print(\"PATH\", environ.get('PATH_INFO')) # 当前请求路径 global path path = environ.get('PATH_INFO') url_patterns = [ (\"/login\", login), (\"/index\", index), (\"/favicon.ico\", favi) ] func = None for item in url_patterns: print(item) if path == item[0]: func = item[1] break print(func) if func: return [func()] else: return [b'404!']httped = make_server(\"127.0.0.1\", 8080, application)httped.serve_forever()# login.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;登录页面&lt;/h4&gt;&lt;form action=\"http://127.0.0.1:8080/\" method=\"post\"&gt; 用户名 &lt;input type=\"text\" name=\"user\"&gt; 密码&lt;input type=\"password\" name=\"pwd\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;# index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;welcome to here&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"前端","slug":"前端","permalink":"http://cjwnb.top/tags/前端/"}]}]}