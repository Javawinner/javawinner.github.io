{"meta":{"title":"Gorg Chen","subtitle":null,"description":null,"author":"Gorg Chen","url":"http://cjwnb.top","root":"/"},"pages":[{"title":"分类","date":"2019-07-14T14:54:31.000Z","updated":"2019-07-14T15:09:42.107Z","comments":true,"path":"categories/index.html","permalink":"http://cjwnb.top/categories/index.html","excerpt":"","text":""},{"title":"链接","date":"2019-07-14T14:46:05.000Z","updated":"2019-07-14T15:13:02.608Z","comments":true,"path":"link/index.html","permalink":"http://cjwnb.top/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-14T14:30:38.000Z","updated":"2019-07-14T14:37:38.799Z","comments":true,"path":"tags/index.html","permalink":"http://cjwnb.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"django小项目","slug":"django小项目","date":"2019-07-15T14:25:52.854Z","updated":"2019-07-15T14:43:43.031Z","comments":true,"path":"2019/07/15/undefined/","link":"","permalink":"http://cjwnb.top/2019/07/15/undefined/","excerpt":"","text":"最后需要实现的效果 后端数据库models.py from django.db import models# Create your models here.class User(models.Model): # User表的主键字段名就是id id = models.AutoField(primary_key=True) # varchar(32) name字段是varchar(32) CharField在定义的时候必须要加max_length参数，不加直接报错 name = models.CharField(max_length=32) # varchar(32) password字段是varchar(32) CharField在定义的时候必须要加max_length参数，不加直接报错 password = models.CharField(max_length=32) def __str__(self): return self.name 路由分发urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login/', views.login), url(r'^reg/', views.reg), url(r'^userlist/', views.userlist), url(r'^delete_user/', views.delete_user), url(r'^edit_user/', views.edit_user), 视图函数views.py from django.shortcuts import render, HttpResponse, redirect# Create your views here.from app01 import modelsdef login(request): if request.method == 'POST': import pymysql # 获取用户输入的用户名和密码 username = request.POST.get('username') password = request.POST.get('password') conn = pymysql.connect( host='127.0.0.1', user=\"root\", password=\"123\", database='django', port=3306, charset='utf8', autocommit=True ) cursors = conn.cursor(pymysql.cursors.DictCursor) cursors.execute('select * from userinfo where name=%s and password=%s', args=(username, password)) user_info = cursors.fetchone() # 如果只查询到一个结果，fetchone直接返回一个字典，而fetchall还是返回一个列表，里面套个字典 if user_info: return HttpResponse('登录成功') return HttpResponse('用户名或密码错误') return render(request, \"login.html\")def reg(request): # 必须要加if判断，如果加的话，永远访问不了网页 # IntegrityError at /reg/ (1048, \"Column 'name' cannot be null\") if request.method == 'POST': # 接收前台通过form表单发送的数据 username = request.POST.get('username') password = request.POST.get('password') print(username, password) # 操作数据库 # 方式1 user_obj = models.User.objects.create(name=username, password=password) # User_obj=User object print(user_obj.pk) # pk获取主键字段对应的值 无论的你主键叫上面名字 print(user_obj.id) # 获取用户数据的id值,可以看到和pk的属性是一样的 print(user_obj.name) # 获取用户数据的name值 print(user_obj.password) # 获取用户数据的password值 # 方式2 # user_obj = models.User(name=username, password=password) # User_obj=User object # models.User.save(user_obj) # 对象调用save方法保存到数据库 # print(user_obj.pk) # pk获取主键字段对应的值 无论的你主键叫上面名字 # print(user_obj.id) # 获取用户数据的id值,可以看到和pk的属性是一样的 # print(user_obj.name) # 获取用户数据的name值 # print(user_obj.password) # 获取用户数据的password值 return redirect('/userlist/') return render(request, 'reg.html')def userlist(request): # 操作数据库 user_obj = models.User.objects.all() # # 获取user表所有的数据 # print(user_obj) # &lt;QuerySet [&lt;User: lyysb&gt;, &lt;User: lyysb&gt;, 。。。&gt; # 只要是QuerySet就可以点query查看获取到当前QuerySet对象的内部sql语句 # print(user_obj.query) # SELECT `app01_user`.`id`, `app01_user`.`name`, `app01_user`.`password` FROM `app01_user` return render(request, 'userlist.html', locals())def delete_user(request): # 删除时候执行的是GET请求，所以在前端提交的时候携带参数传给后端（http://127.0.0.1:8000/delete_user/?id=4） # print(request.GET) id = request.GET.get('id') # 查询操作 最后查询到的是一个queryset对象，里面是一个列表，可以通过first()方法取列表中的第一个元素 # user_obj2 = models.User.objects.filter(id=id) # print(user_obj2) #&lt;QuerySet [&lt;User: luowensg&gt;]&gt; # print(user_obj2.first()) # luowensg models.User.objects.filter(id=id).delete() return redirect('/userlist/')def edit_user(request): ''' [15/Jul/2019 13:35:26] \"GET /userlist/ HTTP/1.1\" 200 3784 访问userlist [15/Jul/2019 13:35:28] \"GET /edit_user/?id=5 HTTP/1.1\" 200 753 通过userlist.html上的修改用户按钮进入edit.html [15/Jul/2019 13:35:33] \"POST /edit_user/?id=5 HTTP/1.1\" 302 0 执行edit.html上的按钮，如果提交的话，就会重定向，因为函数里定义的返回值 return redirect('/userlist/') [15/Jul/2019 13:35:33] \"GET /userlist/ HTTP/1.1\" 200 3780 最后重定向到userlist.html上查看结果，所以是GET请求 :param request: :return: ''' # 4. 我们要操作数据库，更改一条数据，需要拿到表中的id字段的值 # 当用户点击修改用户按钮，跳转到edit.html,这个行为是GET，然后修改完数据之后提交，这个动作是POST # 我们在前端在form表单里面配置form表单中的路径参数携带?id=xx，所以可以通过request.GET.get('id')拿到id的值 # 我们也可以新建一个input标签，type设置为hidden,然后配置value这个属性，value这个属性的值由后台的数据库对象user_obj.id获得 if request.method == 'POST': username = request.POST.get('username') password = request.POST.get('password') # 方式1 新建一个input标签，type设置为hidden,然后配置value这个属性，value这个属性的值由后台的数据库对象user_obj.id获得 id=request.POST.get('id') # 方式2 在前端在form表单里面配置form表单中的路径参数携带?id=xx，通过request.GET.get('id')拿到id的值 # id = request.GET.get('id') # 操作数据库修改数据 # 方式1 # models.User.objects.filter(id=id).update(name=username,password=password) # 方式2 user_obj=models.User.objects.filter(id=id) user=user_obj.first() # lyysb 输出lyysb而不是一个对象，因为在ORM中类定义的时候定义了__str__，限定输出对象的name字段 # lxxsb &lt;class 'app01.models.User'&gt; # user_obj就是一个通过数据库查询到的一个queryset对象，queryset这个对象是一个列表，first方法就是把列表中的第一个元素user取出来了 # 这里通过id进行匹配，id这个字段在数据库中是唯一的，所以最后匹配到的就是只有一行数据对应的一个对象user # 我们可以通过user的.语法对查询到的这一行的数据库的字段进行修改 user.name=username user.password=password user.save() # 操作完数据库重定向到userlist网页查看用户列表，查看是否操作成功 return redirect('/userlist/') # 1.获取用户想要修改的id id = request.GET.get('id') # 2. 将该数据查询出来渲染到一个编辑页面 # 查询数据方式1 # filter当条件不存在的情况下会返回None # 比如说 user_obj = models.User.objects.filter(id=8888).first()，返回None user_obj = models.User.objects.filter(id=id).first() # 查询数据方式2 # 弊端: 如果查询不到数据对象就会报错，所有已不推荐使用 # 比如说 user_obj = models.User.objects.get(id=2222) # 就会报 500的错误 # app01.models.DoesNotExist: User matching query does not exist. # [15/Jul/2019 12:31:27] \"GET /edit_user/?id=5 HTTP/1.1\" 500 69867 # user_obj = models.User.objects.get(id=id) # owensb,这里直接显示name， # 因为在models类里面定义了__str__定义输出为对象的name字段的值（User object.name)， # 如果不设置，输出为对象 User object # print(user_obj) # print(type(user_obj)) # &lt;class 'app01.models.User'&gt; # 3. 将当前数据渲染到一个编辑页面上，只要是渲染页面相关的操作，就应该想到用render return render(request, 'edit.html', &#123;'user_obj': user_obj&#125;) 设置settings.py # 注册app01INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'app01.apps.App01Config',]# 暂时取消'django.middleware.csrf.CsrfViewMiddleware',MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',]# 数据库配置DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'django2', 'HOST': '127.0.0.1', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123' &#125;&#125;# 静态文件配置 (static主要存放bootstrap,css,fonts,img,js等目录)STATIC_URL = '/static/'STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static') 前端userlist.html &lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1&gt;用户列表&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\"&gt; &lt;a href=\"/reg/\" class=\"btn btn-success\"&gt;注册用户&lt;/a&gt; &lt;a href=\"/login/\" class=\"btn btn-warning\"&gt;用户登录&lt;/a&gt; &lt;table class=\"table table-hover table-bordered table-striped table-condensed\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;password&lt;/th&gt; &lt;th&gt;action&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for user in user_obj %&#125; &lt;tr&gt; &lt;td&gt; &#123;&#123; user.pk &#125;&#125;&lt;/td&gt; &lt;td&gt; &#123;&#123; user.name &#125;&#125;&lt;/td&gt; &lt;td&gt; &#123;&#123; user.password &#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=\"/delete_user/?id=&#123;&#123; user.pk &#125;&#125;\" class=\"btn btn-danger\"&gt;删除用户&lt;/a&gt; &lt;a href=\"/edit_user/?id=&#123;&#123; user.pk &#125;&#125;\" class=\"btn btn-primary\"&gt;修改用户&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; reg.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;注册&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1&gt;注册页面&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\"&gt; &lt;form action=\"\" method=\"post\"&gt; &lt;p&gt;用户名&lt;input type=\"text\" name=\"username\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;密码&lt;input type=\"password\" name=\"password\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" class=\"btn btn-primary\"&gt;&lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; login.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1 class=\"h2\"&gt;登录页面&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\" &gt; &lt;form action=\"/login/\" method=\"post\"&gt; &lt;p&gt;用户名: &lt;input type=\"text\" class=\"form-control\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;密码: &lt;input type=\"password\" class=\"form-control\" name=\"password\"&gt; &lt;/p&gt; &lt;input type=\"submit\" value=\"登录\" class=\"btn btn-primary\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; edit.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;编辑&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1&gt;修改数据&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\"&gt; &lt;form action=\"/edit_user/?id=&#123;&#123; user_obj.id &#125;&#125;\" method=\"post\"&gt; &lt;p&gt;&lt;input type=\"hidden\" value=\"&#123;&#123; user_obj.id &#125;&#125;\" name=\"id\"&gt;&lt;/p&gt; &lt;p&gt;username&lt;input type=\"text\" name=\"username\" value=\"&#123;&#123; user_obj.name &#125;&#125;\"&gt;&lt;/p&gt; &lt;p&gt;password&lt;input type=\"password\" name=\"password\" value=\"&#123;&#123; user_obj.password&#125;&#125;\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" value=\"修改\" class=\"btn btn-warning\"&gt;&lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"}]},{"title":"django基础","slug":"Django基础","date":"2019-07-09T06:13:20.537Z","updated":"2019-07-15T08:07:47.694Z","comments":true,"path":"2019/07/09/undefined/","link":"","permalink":"http://cjwnb.top/2019/07/09/undefined/","excerpt":"","text":"MTVDjango是一种MTV的设计模式，各组件之间保持松耦合关系 M 代表模型 (Model): 负责业务对象和数据库的关系映射(ORM)T 代表模板(Template): 负责如何把页面展示给用户(html)V 代表视图(View): 负责业务逻辑，并在适当时候调用Model和Template除了以上三层外，还需要一个URL分发器，它的作用是将一个个URL的页面分发给不同的view处理，View再调用响应的Model和Template 下载Django# pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple django==1.11.10 查看Django$ python&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path['', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/lib-dynload', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages']&gt;&gt;&gt; exit()$ cd /Library/Frameworks/Python.framework/Versions$ open 3.6/ 更快速的方法django-admin $ django-adminType 'django-admin help &lt;subcommand&gt;' for help on a specific subcommand.Available subcommands:[django] check compilemessages createcachetable dbshell diffsettings dumpdata flush inspectdb loaddata makemessages makemigrations migrate runserver sendtestemail shell showmigrations sqlflush sqlmigrate sqlsequencereset squashmigrations startapp startproject test testserverNote that only Django core commands are listed as settings are not properly configured (error: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.). Django的创建和启动命令行方式# 创建项目$ cd My_pro/$ django-admin.py startproject mysites# 创建应用$ cd mysites/$ python3 manage.py startapp blog# 启动项目$ python3 manage.py runserver 访问 http://127.0.0.1:8000 pycharm Django目录介绍first_pro:&gt;&gt;&gt; app01: 应用相关的目录 migrations: 数据库迁移相关数据 admin.py: Django后台管理相关 models.py: 模型表相关（数据库） views.py: 视图函数相关&gt;&gt;&gt; first_pro: 项目相关的目录 settings.py: 包含了项目的默认配置，包括数据库信息，调试标志以及其他一些工作的变量 urls.py: 路由文件（控制器）负责把URL模式映射到应用程序 wsgi.py: 启动socket 服务端的文件&gt;&gt;&gt; templates: 项目用到的所有html文件&gt;&gt;&gt;manage.py: Django项目里面的工具，通过它可以调用Django shell和数据库等 案例通过Django查看时间的一个简单页面 后端 url.py 当执行timer函数时候，会把request都传给函数views.timer(request),所以views的函数必须加形参request urlpatterns = [ url('^admin/', admin.site.urls), url('^timer/', views.timer), ] views.py def timer(request): import time ctime = time.time() return render(request, \"timer.html\", &#123;'ctime': ctime&#125;) 前端 timer.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;当前时间:&#123;&#123; ctime &#125;&#125;&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt; Django 静态文件配置通过路径访问 http://127.0.0.1:8000/static/bootstrap.js 无法访问 配置settings.py STATIC_URL = '/static/'STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static'),] time.html &lt;script src=\"/static/bootstrap.js\"&gt;&lt;/script&gt; 地址栏 http://127.0.0.1:8000/static/bootstrap.js， 可以直接访问js文件 注意 在settings.py 中的STATIC_URL定义了什么别名，script标签中导入的路径的根就从哪里开始 # settings.py 配置STATIC_URL = '/xxx/'STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static'),]# time.html&lt;script src=\"/static/bootstrap.js\"&gt;&lt;/script&gt; 以上的情况，地址栏输入什么都会有异常信息。 输入 http://127.0.0.1:8000/static/bootstrap.js映射关系是xxx,访问static当然会报404错误，路径根本就是不存在的 输入 http://127.0.0.1:8000/xxx/bootstrap.js可以正常访问bootstrap.js，但是还是有问题的 当输入 http://127.0.0.1:8000/timer/在network中看到bootstrap.js是飘红的,因为在前端的script标签引入bootstrap的路径写错了 &lt;script src=\"/static/bootstrap.js\"&gt;&lt;/script&gt;# 这个时候映射 /static/bootstrap.js的别名是xxx,所以路径写成 &lt;script src=\"/xxx/bootstrap.js\"&gt;&lt;/script&gt; 就没问题 Django三剑客from django.shortcuts import render,HttpResponse,redirectHttpResponse 返回字符串render 返回一个HTML页面redirect 重定向到一个HTML页面 登录功能form表单触发提交数据的动作的两种方式&gt;&lt;input type=\"submit\"&gt;&gt; &lt;button type=\"submit\"&gt;&lt;/button&gt; form表单提交数据的地址如何指定及方式 action属性控制提交的地址，比如说http://127.0.0.1:8080/login 1. 全路径 &lt;form action=\"http://127.0.0.1:8000/login/\"&gt;2. 只写路径后缀 &lt;form action=\"/login\"&gt;3. 不写 &lt;form action=\"\"&gt; 默认往当前路径提交,当前路径指的是打开页面所在的路径，也就是http://127.0.0.1:8080/login） 获取用户端提交的请求方式request.method 根据客户端请求方式的不同执行不同的逻辑代码views.py def login(request): # 获取用户端提交的请求方式 print(request.method) # 拿到的请求方式是全大写的字符串 if request.method=='GET': return render(request,'login.html') return HttpResponse('接收成功') urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login/', views.login),] login.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1 class=\"h2\"&gt;登录页面&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\" &gt; &lt;form action=\"/login/\" method=\"post\"&gt; &lt;p&gt;用户名: &lt;input type=\"text\" class=\"form-control\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;密码: &lt;input type=\"password\" class=\"form-control\" name=\"password\"&gt; &lt;/p&gt; &lt;input type=\"submit\" value=\"登录\" class=\"btn btn-primary\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; 获取提交的表单的value列表里面所有的元素request.POST.getlist(key) 我们通过input标签提交的表单返回给后台的是一个字典类似于 &lt;QueryDict: &#123;'username': ['lxxsb','lyysb'], 'password': ['123']&#125;&gt;字典中的key就是input标签中name属性定义的名字而value则是用户输入的内容，value是通过一个列表的方式展现给后台默认后台通过request.POST.get 只会取到value列表的最后一个元素如果想要取到所有元素，要使用getlist views.py def login(request): # 获取用户端提交的请求方式 print(request.method) # 拿到的请求方式是全大写的字符串 if request.method == 'POST': print(request.POST) # 把它当成一个大字典，里面存放了客户端post提交的所有数据 # &lt;QueryDict: &#123;'username': ['lxxsb', 'lyysb'], 'password': ['123']&#125;&gt; print(request.POST.get('username')) # value虽然是个列表，但是获取value时候拿到的却是单个元素 # 默认只会取value里面的最后一个元素 print(request.POST.getlist('username')) #要想一次性获取value列表里面所有的数据需要用getlist() # ['lxxsb', 'lyysb'] print(request.POST['password']) # 不推荐使用该方法取数据，如果不存在就直接报错了 return HttpResponse('ok') return render(request, \"login.html\") urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login/', views.login),] login.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1 class=\"h2\"&gt;登录页面&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\" &gt; &lt;form action=\"/login/\" method=\"post\"&gt; &lt;p&gt;用户名: &lt;input type=\"text\" class=\"form-control\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;用户名: &lt;input type=\"text\" class=\"form-control\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;密码: &lt;input type=\"password\" class=\"form-control\" name=\"password\"&gt; &lt;/p&gt; &lt;input type=\"submit\" value=\"登录\" class=\"btn btn-primary\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; 获取get 请求的数据规则和POST请求一模一样 浏览器输入 http://127.0.0.1:8000/login/?username=lyysb&amp;password=123&amp;password=456 views.py (其他文件如上) def login(request): # 获取用户端提交的请求方式 print(request.method) # 拿到的请求方式是全大写的字符串 print(request.GET) # &lt;QueryDict: &#123;'username': ['lyysb'], 'password': ['123', '456']&#125;&gt; print(request.GET.get('password')) # 456 print(request.GET.getlist('password')) # ['123', '456'] return render(request, \"login.html\") pymysql 完成登录功能urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login/', views.login),] views.py from django.shortcuts import render, HttpResponse, redirect# Create your views here.def login(request): if request.method == 'POST': import pymysql # 获取用户输入的用户名和密码 username = request.POST.get('username') password = request.POST.get('password') conn = pymysql.connect( host='127.0.0.1', user=\"root\", password=\"123\", database='django', port=3306, charset='utf8', autocommit=True ) cursors = conn.cursor(pymysql.cursors.DictCursor) cursors.execute('select * from userinfo where name=%s and password=%s', args=(username, password)) user_info = cursors.fetchone() # 如果只查询到一个结果，fetchone直接返回一个字典，而fetchall还是返回一个列表，里面套个字典 if user_info: return HttpResponse('登录成功') return HttpResponse('用户名或密码错误') return render(request, \"login.html\") login.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1 class=\"h2\"&gt;登录页面&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\" &gt; &lt;form action=\"/login/\" method=\"post\"&gt; &lt;p&gt;用户名: &lt;input type=\"text\" class=\"form-control\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;密码: &lt;input type=\"password\" class=\"form-control\" name=\"password\"&gt; &lt;/p&gt; &lt;input type=\"submit\" value=\"登录\" class=\"btn btn-primary\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; pycharm 连接数据库 查看pycharm支持的数据库 下载驱动 测试用户名是否正确 勾选需要显示的库 查看到MYSQL数据库已经在pycharm的数据库列表中 添加数据后同步到数据库 Django 连接数据库 需要修改配置文件settings.py DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': os.path.join(BASE_DIR, 'app01'), 'HOST': '127.0.0.1', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123' &#125;&#125; 告诉django用pymysql替换它默认mysql_db模块来连接数据库 方式1: 在项目文件夹下面的init.py方式2: 在应用文件夹下面的init.py __init__.py import pymysqlpymysql.install_as_MySQLdb() # 告诉django用pymysql代替mysqldb连接数据库","categories":[],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"}]},{"title":"模拟一个简单的web请求","slug":"模拟一个简单的web请求","date":"2019-07-08T14:42:06.275Z","updated":"2019-07-14T14:38:45.636Z","comments":true,"path":"2019/07/08/undefined/","link":"","permalink":"http://cjwnb.top/2019/07/08/undefined/","excerpt":"","text":"引子描述下当我们在浏览器输入一个url网址，比如说www,jd.com, 然后显示整个页面的过程1. 当输入http://www.jd.com的时候，先把请求发送到本地DNS服务器里找www.jd.com对应的Ip地址和端口，如果有，返回ip地址和端口，2. 如果本地DNS服务器里面没有字符串 www.jd.com对应的ip地址和端口，则会去DNS根域服务器去找（root-server.net）,根域会把字符串交给顶级域服务器.com DNS服务器，然后会 将字符串交个权威DNS服务器找到jd.com,然后再去二级域名服务器找到www.jd.com3. 当客户端(浏览器)获得了ip地址和端口，客户端发送请求到响应的服务器，服务器响应需求，客户端拿到响应结果，渲染页面。 字符串和字节的转换\\&gt;&gt;&gt; s=\"hello\"\\&gt;&gt;&gt; s'hello'\\&gt;&gt;&gt; bytes(s,encoding=\"utf-8\")b'hello'\\&gt;&gt;&gt; b=bytes(s,encoding=\"utf-8\")\\&gt;&gt;&gt; bb'hello'\\&gt;&gt;&gt; str(b,encoding='utf-8')'hello' 模拟一个简单的web请求from socket import *sock = socket(AF_INET, SOCK_STREAM)sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)sock.bind(('127.0.0.1', 8800))sock.listen(5)while True: # 不断地等待接收客户端的链接,保证服务器不中断 print('\\033[32mserver waiting...\\033[0m') client, addr = sock.accept() # 客户端套接字对象，客户端地址端口 data = client.recv(1024) print('data', data) # client.send(b'hello world') # 浏览器端会显示 127.0.0.1 发送的响应无效 # 浏览器要访问数据必须加上HTTP/1.1 状态码 # HTTP/1.1 200 OK 响应首行 hello world 响应体 响应首行和响应体之前用\\r\\n\\r\\n，否则响应体无法渲染显示 with open('index.html','rb') as f: data=f.read() client.send(b'HTTP/1.1 200 OK\\r\\n\\r\\n%s'%data) client.close() # index.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 style=\"color: red;\"&gt;宝贝 我来了&lt;/h1&gt;&lt;img src=\"http://s14.sinaimg.cn/middle/4b955cd7xcb1739815c4d&amp;690\" alt=\"\"&gt;&lt;a href=\"http://www.w3school.com.cn/\"&gt;click&lt;/a&gt;&lt;div style=\"height: 200px\"&gt;&lt;/div&gt;&lt;div&gt; &lt;h1 style=\"color: yellow; background-color: gray\"&gt;张帆喜欢的类型&lt;/h1&gt; &lt;img src=\"http://s8.sinaimg.cn/bmiddle/005DIuBKgy6KewCX5iv97&amp;690\" alt=\"\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; /usr/local/bin/python3.6 /Users/cjw/Desktop/pycharm_project/Django/Weby应用程序/JDserver.pyserver waiting...data b'GET / HTTP/1.1\\r\\nHost: 127.0.0.1:8800\\r\\nConnection: keep-alive\\r\\nCache-Control: max-age=0\\r\\nUpgrade-Insecure-Requests: 1\\r\\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36\\r\\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\\r\\nAccept-Encoding: gzip, deflate, br\\r\\nAccept-Language: zh-CN,zh;q=0.9\\r\\n\\r\\n'server waiting...data b'GET /favicon.ico HTTP/1.1\\r\\nHost: 127.0.0.1:8800\\r\\nConnection: keep-alive\\r\\nPragma: no-cache\\r\\nCache-Control: no-cache\\r\\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36\\r\\nAccept: image/webp,image/apng,image/*,*/*;q=0.8\\r\\nReferer: http://127.0.0.1:8800/\\r\\nAccept-Encoding: gzip, deflate, br\\r\\nAccept-Language: zh-CN,zh;q=0.9\\r\\n\\r\\n'server waiting... 浏览器会解释url请求发生了什么response: 从客户端接收过来的一堆HTML字符串(要放到页面的一堆字符串)Preview: 浏览器解析服务端发送的的HTML字符串，将这些字符串解析成用户能看到的格式，preview能够看到一个这样的结果所以浏览器也可以看成一个解释期，解释HTML标记语言 HTTP协议主要由请求协议和响应协议构成 请求协议：浏览器给服务器发的格式的限定 响应协议：服务器给浏览器发的格式的限定 HTTP请求协议结构：请求首行+请求头+\\r\\n\\r\\n+请求体服务器通过\\r\\n来识别请求首行，请求头以及请求体请求首行和请求头之间，多个请求体之间用一个\\r\\n分割，最后一个请求头和请求体之间用两个\\r\\n分割请求方法主要分get和postget 没有请求体 post 有请求体 get 和 post请求1. GET请求提交的数据会放在url之后，以？分割URL和传输的数据，参数之间用&amp;相连，比如http://127.0.0.1:8800/?name=changwei&amp;pwd=GET2. GET 提交的数据大小有限制(因为浏览器对URL长度有限制)，而POST方法提交的数据没有限制3. GET与POST都是提交数据的方式，当需要对服务器所在的数据库的数据进行查询的时候提交GET请求，添加或删除提交POST请求 案例1 （get请求）'GET / HTTP/1.1\\r\\nHost: 127.0.0.1:8800\\r\\nConnection: keep-alive\\r\\nCache-Control: max-age=0\\r\\nUpgrade-Insecure-Requests: 1\\r\\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36\\r\\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\\r\\nAccept-Encoding: gzip, deflate, br\\r\\nAccept-Language: zh-CN,zh;q=0.9\\r\\n\\r\\n' 请求首行GET / HTTP/1.1\\r\\nHost: 127.0.0.1:8800格式： 方法(get/post)+发送请求的服务器的路径（URI /form/entry)+协议版本(HTTP/1.1) 请求头请求头 Connection: keep-alive请求头 Pragma: no-cache请求头 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36请求头 Accept: image/webp,image/apng,image/*,*/*;q=0.8请求头 Referer: http://127.0.0.1:8800请求头 Accept-Encoding: gzip, deflate, br请求头 Accept-Language: zh-CN,zh;q=0.9 请求体1. get请求没有请求体 所以最后的请求体部分是空的2. get请求提交的数据会放在url之后，以？分割URL和传输的数据，参数之间用&amp;相连，比如http://127.0.0.1:8800/?name=changwei&amp;pwd=123'GET /?name=changwei&amp;pwd=123 HTTP/1.1\\r\\nHost: 127.0.0.1:8800\\r\\nConnection: keep-alive\\r\\nUpgrade-Insecure-Requests: 1\\r\\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36\\r\\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\\r\\nAccept-Encoding: gzip, deflate, br\\r\\nAccept-Language: zh-CN,zh;q=0.9\\r\\n\\r\\n' 案例2 （post请求）# 服务端from socket import *sock = socket(AF_INET, SOCK_STREAM)sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)sock.bind(('127.0.0.1', 8800))sock.listen(5)while True: # 不断地等待接收客户端的链接,保证服务器不中断 print('\\033[32mserver waiting...\\033[0m') client, addr = sock.accept() # 客户端套接字对象，客户端地址端口 data = client.recv(1024) print('data', data) # client.send(b'hello world') # 浏览器端会显示 127.0.0.1 发送的响应无效 # 浏览器要访问数据必须加上HTTP/1.1 状态码 # HTTP/1.1 200 OK 响应首行 hello world 响应体 响应首行和响应体之前用\\r\\n\\r\\n，否则响应体无法渲染显示 with open('login.html','rb') as f: data=f.read() client.send(b'HTTP/1.1 200 OK\\r\\n\\r\\n%s'%data) client.close()# index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"http://127.0.0.1:8800/\" method=\"post\"&gt; 用户名 &lt;input type=\"text\" name=\"user\"&gt; 密码 &lt;input type=\"password\" name=\"pwd\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 'POST / HTTP/1.1\\r\\nHost: 127.0.0.1:8800\\r\\nConnection: keep-alive\\r\\nContent-Length: 21\\r\\nCache-Control: max-age=0\\r\\nOrigin: http://127.0.0.1:8800\\r\\nUpgrade-Insecure-Requests: 1\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36\\r\\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\\r\\nReferer: http://127.0.0.1:8800/\\r\\nAccept-Encoding: gzip, deflate, br\\r\\nAccept-Language: zh-CN,zh;q=0.9\\r\\n\\r\\nuser=changwei&amp;pwd=123' 请求首行POST / HTTP/1.1\\r\\nHost: 127.0.0.1:8800Cache-Control: max-age=0\\r\\nOrigin: http://127.0.0.1:8800Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Referer: http://127.0.0.1:8800/\\r\\nAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9 请求头Connection: keep-alive\\r\\nContent-Length: 21 请求体user=changwei&amp;pwd=123 HTTP响应协议和请求协议一样，主要由响应首行，响应头，响应体组成 常见的响应状态码1xx Informational(信息性状态码) 接受的请求正在处理2xx Success(成功状态码) 请求正常处理完毕3xx Redirection(重定向状态码) 需要进行附加操作以完成请求 (域名地址变了了,跳转到新的域名地址，这种情况浏览器发2次请求)4xx Client Error (客户端错误状态码) 服务器无法处理请求 404 (not found) 403(forbidden 禁止访问) 5xx Server Error(服务器错误状态码) 服务器处理请求出错 500(服务端代码错误) 502(网关错误 bad gateway) 通过socket实现web框架server.pyimport timefrom socket import *def f1(): # 静态网站 fp = open('index.html', 'r', encoding='utf-8') data = fp.read() fp.close() return bytes(data, encoding='utf-8')def f2(): fp = open('article.html', 'r', encoding='utf-8') data = fp.read() ctime = time.time() data = data.replace(\"@@content@@\", str(ctime)) fp.close() return bytes(data, encoding='utf-8')def f3(): import pymysql conn = pymysql.connect(host='127.0.0.1', user='root', password='123', db='youku', charset='utf8') cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) sql = \"select id,name,password,register_time from user\" cursor.execute(sql) res = cursor.fetchall() print(res) ''' [&#123;'id': 1, 'name': 'lxx', 'password': '202cb962ac59075b964b07152d234b70', 'register_time': '2019-06-26 21:48:47'&#125;, &#123;'id': 2, 'name': '111', 'password': '698d51a19d8a121ce581499d7b701668', 'register_time': '2019-06-26 21:49:10'&#125;] ''' res_list = [] for user in res: res_str = '&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;' % ( user['id'], user['name'], user['password'], user['register_time']) res_list.append(res_str) s = ''.join(res_list) fp = open('content.html', 'r', encoding='utf-8') data = fp.read() data = data.replace(\"@@content@@\", s) return bytes(data, encoding='utf-8') ### 需要将html代码和mysql结果融合def f4(): pass# 路由系统routes = [ ('/xxx', f1), ('/ooo', f2), ('/hhh', f3), ('/kkk', f4)]def run(): sk = socket() sk.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) sk.bind(('127.0.0.1', 8081)) sk.listen(5) while True: conn, addr = sk.accept() buf = conn.recv(8096) data = str(buf, encoding='utf-8') header_list = data.split('\\r\\n\\r\\n')[0].split('\\r\\n')[0] print(header_list) uri = header_list.split(' ')[1] func_name = None for items in routes: if items[0] == uri: func_name = items[1] break if func_name: res = func_name() else: res = b'404 not found' conn.send(b'HTTP/1.1 200 OK\\r\\nCache-Control: private\\r\\n\\r\\n') conn.send(res)if __name__ == '__main__': run() index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;this is index&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; content.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=\"1px\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;password&lt;/th&gt; &lt;th&gt;register_time&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; @@content@@ &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; article.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; @@content@@&lt;/body&gt;&lt;/html&gt; 通过wsgiref实现web框架step 1访问不同的url路径可以跳转到不同的网页from wsgiref.simple_server import make_serverdef application(environ, start_response): # 按着httpd协议解析数据（将所有请求存到一个字典里）: environ # 按着httpd协议组装数据（生成数据 响应首行，响应头）： start_response # 当前的请求路径 path = environ.get('PATH_INFO') start_response('200 OK', [('Content-Type', 'text/html')]) # 生成数据 请求首行，请求头，请求体 if path == \"/login\": with open('login.html', 'rb') as f: global data data = f.read() if path == '/index': with open('index.html', 'rb') as f: data = f.read() return [data]# 封装sockethttped = make_server(\"127.0.0.1\", 8060, application)# 等待客户连接: conn,addr=sock.accept()httped.serve_forever()# login.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"http://127.0.0.1:8800/\" method=\"post\"&gt; 用户名 &lt;input type=\"text\" name=\"user\"&gt; 密码 &lt;input type=\"password\" name=\"pwd\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;# index.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 style=\"color: red;\"&gt;宝贝 我来了&lt;/h1&gt;&lt;img src=\"http://s14.sinaimg.cn/middle/4b955cd7xcb1739815c4d&amp;690\" alt=\"\"&gt;&lt;a href=\"http://www.w3school.com.cn/\"&gt;click&lt;/a&gt;&lt;div style=\"height: 200px\"&gt;&lt;/div&gt;&lt;div&gt; &lt;h1 style=\"color: yellow; background-color: gray\"&gt;张帆喜欢的类型&lt;/h1&gt; &lt;img src=\"http://s8.sinaimg.cn/bmiddle/005DIuBKgy6KewCX5iv97&amp;690\" alt=\"\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 设置页面图标为京东图标from wsgiref.simple_server import make_serverdef application(environ: dict, start_response): start_response('200 ok', [('Content-Type','text/html')]) print(\"PATH\",environ.get('PATH_INFO')) path=environ.get('PATH_INFO') if path=='/favicon.ico': with open('favicon.ico','rb') as f: data=f.read() return [data] return [b'&lt;h1&gt;Hello,web!&lt;/h1&gt;']httped = make_server(\"127.0.0.1\", 8080, application)httped.serve_forever() step 2通过列表的映射来使得访问不同的url路径可以跳转到不同的网页 from wsgiref.simple_server import make_serverdef login(): with open('login.html', 'rb') as f: data = f.read() return datadef index(): with open('index.html', 'rb') as f: data = f.read() return datadef favi(): with open('favicon.ico', 'rb') as f: data = f.read() return datadef application(environ: dict, start_response): start_response('200 ok', [('Content-Type', 'text/html')]) print(\"PATH\", environ.get('PATH_INFO')) # 当前请求路径 global path path = environ.get('PATH_INFO') url_patterns = [ (\"/login\", login), (\"/index\", index), (\"/favicon.ico\", favi) ] func = None for item in url_patterns: print(item) if path == item[0]: func = item[1] break print(func) if func: return [func()] else: return [b'404!']httped = make_server(\"127.0.0.1\", 8080, application)httped.serve_forever()# login.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;登录页面&lt;/h4&gt;&lt;form action=\"http://127.0.0.1:8080/\" method=\"post\"&gt; 用户名 &lt;input type=\"text\" name=\"user\"&gt; 密码&lt;input type=\"password\" name=\"pwd\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;# index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;welcome to here&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"}]}]}