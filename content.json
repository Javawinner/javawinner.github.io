{"meta":{"title":"Gorg Chen","subtitle":"","description":null,"author":"Gorg Chen","url":"http://cjwnb.top","root":"/"},"pages":[{"title":"分类","date":"2019-07-14T14:54:31.000Z","updated":"2019-07-15T18:00:03.036Z","comments":true,"path":"categories/index.html","permalink":"http://cjwnb.top/categories/index.html","excerpt":"","text":""},{"title":"链接","date":"2019-07-14T14:46:05.000Z","updated":"2019-07-15T18:00:29.456Z","comments":true,"path":"link/index.html","permalink":"http://cjwnb.top/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-14T14:30:38.000Z","updated":"2019-07-15T18:00:40.178Z","comments":true,"path":"tags/index.html","permalink":"http://cjwnb.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"模板层","slug":"模板层","date":"2019-07-17T13:25:13.623Z","updated":"2019-07-18T11:15:53.173Z","comments":true,"path":"2019/07/17/模板层/","link":"","permalink":"http://cjwnb.top/2019/07/17/模板层/","excerpt":"","text":"面向对象复习class Foo(object): def __init__(self, name, age): self.name = name self.age = age def func(self): return self.name @classmethod def cls(cls): return 'cls' @staticmethod def Bar(): return 'bar'obj=Foo(name='lyysb',age=38)print(obj.__dict__) # &#123;'name': 'lyysb', 'age': 38&#125;print(obj.cls()) # clsprint(obj.Bar()) # bar 语法传参 只需要记两种特殊符号： &#123;&#123; &#125;&#125;和 &#123;% %&#125;变量相关的用&#123;&#123;&#125;&#125;，逻辑相关的用&#123;%%&#125;。 后端朝前端页面传递数据的方式# 第一种return render(request,'index.html',&#123;'n':n&#125;)# 第二种return render(request,'index.html',locals()) # 将当前所在的名称空间中的名字全部传递给前端页面 后端传函数名到前端，会自动加括号调用，但是不支持传参后端传对象到前端，就相当于打印了这个对象前端获取后端传过来的容器类型的内部元素 统一采用句点符(.)前端能够调用python后端数据类型的一些不需要传参的内置方法,如果有参数，则前端无法调用 urls.py` from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index',views.index)] views.py from django.shortcuts import render, HttpResponse# Create your views here.def index(request): name = \"lyysb\" i = 10 l = [111, 22, 333] info = &#123;'name': 'lyysb', 'age': 38&#125; b = True def abc(): return 'abc' class Foo(object): def __init__(self, name, age): self.name = name self.age = age def func(self): return self.name @classmethod def cls(cls): return 'cls' @staticmethod def Bar(): return 'bar' obj = Foo(name='lyysb', age=38) return render(request, 'index.html', locals()) index.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&#123;&#123; name &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; i &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; l &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; info &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; b &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; abc &#125;&#125;&lt;/p&gt;&#123;# 取出类对象以及其属性 #&#125;&lt;p&gt;&#123;&#123; obj &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; obj.name &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; obj.age &#125;&#125;&lt;/p&gt;&#123;# 取出列表中的某个元素 #&#125;&lt;p&gt;&#123;&#123; l.0 &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; l.1 &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; l.2 &#125;&#125;&lt;/p&gt;&#123;# 取出字典中的key,value #&#125;&lt;p&gt;&#123;&#123; info.keys &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; info.values &#125;&#125;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 过滤器在Django的模板语言中，通过使用 过滤器 来改变变量的显示。 过滤器的语法： &#123;&#123; value|filter_name:参数 &#125;&#125;使用管道符\"|\"来应用过滤器。例如：&#123;&#123; name|lower &#125;&#125;会将name变量应用lower过滤器之后再显示它的值。lower在这里的作用是将文本全都变成小写。 注意事项 1.过滤器支持“链式”操作。即一个过滤器的输出作为另一个过滤器的输入。2.过滤器可以接受参数，例如：&#123;&#123; sss|truncatewords:30 &#125;&#125;，这将显示sss的前30个词。3.过滤器参数包含空格的话，必须用引号包裹起来。比如使用逗号和空格去连接一个列表中的元素，如：&#123;&#123; list|join:', ' &#125;&#125;4.'|'左右没有空格没有空格没有空格 Django的模板语言中提供了大约六十个内置过滤器 default 如果一个变量是false或者为空，使用给定的默认值。 否则，使用变量的值 &#123;&#123; value|default:\"nothing\"&#125;&#125; 如果value没有传值或者值为空的话就显示nothing length 返回值的长度，作用于字符串和列表。 &#123;&#123; value|length &#125;&#125; 返回value的长度，如 value=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]的话，就显示4. filesizeformat 将值格式化为一个 “人类可读的” 文件尺寸 （例如 &#39;13 KB&#39;, &#39;4.1 MB&#39;, &#39;102 bytes&#39;, 等等 &#123;&#123; value|filesizeformat &#125;&#125; 如果 value 是 123456789，输出将会是 117.7 MB slice 切片 &#123;&#123;value|slice:\"2:-1\"&#125;&#125; date 格式化 &#123;&#123; value|date:\"Y-m-d H:i:s\"&#125;&#125; safe Django的模板中会对HTML标签和JS等语法标签进行自动转义，原因显而易见，这样是为了安全。但是有的时候我们可能不希望这些HTML元素被转义，比如我们做一个内容管理系统，后台添加的文章中是经过修饰的，这些修饰可能是通过一个类似于FCKeditor编辑加注了HTML修饰符的文本，如果自动转义的话显示的就是保护HTML标签的源文件。为了在Django中关闭HTML的自动转义有两种方式，如果是一个单独的变量我们可以通过过滤器“|safe”的方式告诉Django这段代码是安全的不必转义。 &#123;&#123; value|safe&#125;&#125; truncatechars 如果字符串字符多于指定的字符数量，那么会被截断。截断的字符串将以可翻译的省略号序列（“…”）结尾。 参数：截断的字符数 &#123;&#123; value|truncatechars:9&#125;&#125; truncatewords 在一定数量的字后截断字符串。 &#123;&#123; value|truncatewords:9&#125;&#125; cut 移除value中所有的与给出的变量相同的字符串 &#123;&#123; value|cut:' ' &#125;&#125; 如果value为&#39;i love you&#39;，那么将输出&#39;iloveyou&#39;. join 使用字符串连接列表，例如Python的str.join(list) 时间模块复习from time import strptimeblog_date = strptime('2018-1-1', \"%Y-%m-%d\")comment_date = strptime('2018-1-1', \"%Y-%m-%d\")print(blog_date,comment_date)# time.struct_time(tm_year=2018, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=0, tm_yday=1, tm_isdst=-1) # time.struct_time(tm_year=2018, tm_mon=1, tm_mday=1, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=0, tm_yday=1, tm_isdst=-1)import datetimeblog_date = datetime.date(2018, 1, 1)comment_date = datetime.date(2019, 1, 1)print(blog_date,comment_date)# 2018-01-01 # 2019-01-01 timesince 将日期格式设为自该日期起的时间（例如，“4天，6小时”） 采用一个可选参数，它是一个包含用作比较点的日期的变量（不带参数，比较点为现在) 例如，如果blog_date是表示2006年6月1日午夜的日期实例，并且comment_date是2006年6月1日08:00的日期实例，则以下将返回“8小时”： &#123;&#123; blog_date|timesince:comment_date &#125;&#125;在后端blog_data,comment_data必须是日期对象,使用datetime模块中的datetime.date()生成 分钟是所使用的最小单位，对于相对于比较点的未来的任何日期，将返回“0分钟”。 timeuntil对于timesince，除了它测量从现在开始直到给定日期或日期时间的时间。 例如，如果今天是2006年6月1日，而conference_date是保留2006年6月29日的日期实例，则&#123;&#123; conference_date | timeuntil &#125;&#125;将返回“4周”。使用可选参数，它是一个包含用作比较点的日期（而不是现在）的变量。 如果from_date包含2006年6月22日，则以下内容将返回“1周”： &#123;&#123; conference_date|timeuntil:from_date &#125;&#125; 案例urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index',views.index)] views.py from django.shortcuts import render# Create your views here.def index(request): n = 6969 s = '您好 我是 23 号技 师 很高兴 为您 服务，希望您 能满意!（不带换的' file_size = 1113 from datetime import datetime ctime = datetime.now() res = 'hello big baby baby baby baby' ht = '&lt;h1&gt;我是h1标签&lt;/h1&gt;' cut = 'i love you' join_str = 'lyysupersb' join_list = [1, 2, 3, '33333'] # 返回日期格式给前端 import datetime blog_date = datetime.date(2018,1,1) comment_date = datetime.date(2019,1,1) # 后端解析为HTML格式的数据传给前端 from django.utils.safestring import mark_safe xxx = mark_safe('&lt;h1&gt;我是h1标签&lt;/h1&gt;') return render(request, 'index.html', locals()) index.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;index&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;前端统计字符串的长度 &#123;&#123; s|length &#125;&#125;&lt;/p&gt;&lt;p&gt;前端获取数据，如果是空就返回default后面默认的参数值 &#123;&#123; flag|default:'none' &#125;&#125;&lt;/p&gt;&lt;p&gt;将数字格式化成表示文件大小的单位 &#123;&#123; file_size|filesizeformat &#125;&#125;&lt;/p&gt;&lt;p&gt;格式化事件（不要加%号）&#123;&#123; ctime|date:'Y-m-d' &#125;&#125;&lt;/p&gt;&lt;p&gt;字符串的切片操作 &#123;&#123; res|slice:'0:8' &#125;&#125;&lt;/p&gt;&lt;p&gt;带步长的字符串切片操作 &#123;&#123; res|slice:'0:8:2' &#125;&#125;&lt;/p&gt;&lt;p&gt;截取固定长度的字符串 加上三个点 &#123;&#123; s|truncatechars:5 &#125;&#125;&lt;/p&gt;&lt;p&gt;按照空格截取文本内容 &#123;&#123; res|truncatewords:'4' &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; n|add:1 &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; 'hahaha'|add:'hehehehehe' &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; cut|cut:' ' &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;join_list|join:join_str&#125;&#125;&lt;/p&gt;&lt;p&gt;blog_date和comment_date两个时间的间隔&#123;&#123; blog_date|timesince:comment_date &#125;&#125;&lt;/p&gt;&lt;p&gt;blog_date和现在的时间的间隔&#123;&#123; blog_date|timesince &#125;&#125;&lt;/p&gt;&lt;p&gt;comment_date和blog_date的时间间隔&#123;&#123; comment_date | timeuntil:blog_date &#125;&#125;&lt;/p&gt;&#123;# 重点 #&#125;&lt;p&gt;渲染成HTML标签格式的字符串&#123;&#123; ht &#125;&#125;&lt;/p&gt;&lt;p&gt;渲染成HTML格式&#123;&#123; ht|safe &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; xxx &#125;&#125;&lt;/p&gt; # xxx是后端处理为HTML格式的数据传给前端，前端拿到这个数据直接 &lt;/body&gt;&lt;/html&gt; 标签views.py from django.shortcuts import renderdef index(request): emp=[] s = [111, 222, 3333, 4444] flag = None d = &#123;'name': 'jason', 'password': '222', 'hobby': ['看书', '写字', '琴棋书画']&#125; return render(request, 'index.html', locals()) urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index',views.index)] FOR 语法： &gt; &lt;body&gt;&gt; &#123;% for 自定义变量名 in 后端可迭代对象 %&#125;&gt; &gt; &lt;p&gt;&#123;&#123; 自定义变量名 &#125;&#125;&lt;/p&gt;&gt; &gt; &#123;% endfor %&#125;&gt; &lt;/body&gt;&gt; 循环可迭代对象渲染到前端循环列表index.html &lt;body&gt;&#123;% for i in s %&#125; &lt;p&gt;&#123;&#123; i &#125;&#125;&lt;/p&gt;&#123;% endfor %&#125;&lt;/body&gt; 浏览器查看结果 循环字典index.html &lt;body&gt;&#123;% for i in d.keys %&#125; &lt;p&gt;&#123;&#123; i &#125;&#125;&lt;/p&gt;&#123;% endfor %&#125;&#123;% for i in d.values %&#125; &lt;p&gt;&#123;&#123; i &#125;&#125;&lt;/p&gt;&#123;% endfor %&#125;&#123;% for i in d.items %&#125; &lt;p&gt;&#123;&#123; i &#125;&#125;&lt;/p&gt;&#123;% endfor %&#125;&lt;/body&gt; Forloopindex.html &lt;body&gt;&#123;% for i in s %&#125; &lt;p&gt;&#123;&#123; forloop &#125;&#125;&lt;/p&gt;&#123;% endfor %&#125;&lt;/body&gt; for循环了多少次，页面上就会渲染多少个forloop对象 forloop字段 first: for循环第一次得到的fooloop对象中的first字段肯定是True,其他均为flase last: for循环最后一次得到的fooloop对象中的last字段肯定是True,其他均为flase empty for循环中如果数据是空的，则走empty下面的语句 &lt;body&gt;&#123;% for foo in emp %&#125; &#123;% if forloop.first %&#125; &lt;p&gt;第一次循环&lt;/p&gt; &#123;% elif forloop.last %&#125; &lt;p&gt;第二次循环&lt;/p&gt; &#123;% else %&#125; &lt;p&gt;&#123;&#123; foo &#125;&#125;&lt;/p&gt; &#123;% endif %&#125;&#123;% empty %&#125; &lt;p&gt;数据是空的&lt;/p&gt;&#123;% endfor %&#125;&lt;/body&gt; IFindex.html &lt;body&gt;&#123;% if flag %&#125; &lt;p&gt;flag不为空&lt;/p&gt; &#123;% else %&#125; &lt;p&gt;flag是空&lt;/p&gt;&#123;% endif %&#125;&lt;/body&gt; 关联使用index.html &lt;body&gt;&#123;% for i in s %&#125; &#123;% if forloop.first %&#125; &lt;p&gt;这是第一次for循环&lt;/p&gt; &#123;% elif forloop.last %&#125; &lt;p&gt;这是最后一次for循环&lt;/p&gt; &#123;% else %&#125; &lt;p&gt;&#123;&#123; i &#125;&#125;&lt;/p&gt; &#123;% endif %&#125;&#123;% endfor %&#125;&lt;/body&gt; withindex.html &lt;body&gt;&lt;p&gt;&#123;&#123; d.hobby &#125;&#125;&lt;/p&gt;&#123;% with d.hobby as v %&#125; &lt;p&gt;&#123;&#123; v.0 &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; v.1 &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; v.2 &#125;&#125;&lt;/p&gt;&#123;% endwith %&#125;&lt;/body&gt; 自定义过滤器,标签前提 必须在应用名下新建一个名为templatetags的package文件夹（必须叫这个名字） 在该新建的文件夹内新建一个任意名称的py文件 在该py文件中需要固定写两句代码： from django import template register=template.Library() 注意 自定义过滤器和自定义标签都是来解决复用性问题 自定义过滤器最多只能传2个参数，标签随意 自定义过滤器可以写进条件语句，自定义标签不可以写进条件语句 &gt;&#123;% if 10|multi_filter:20 &gt; 100 %&#125;&gt;&lt;p&gt;100&lt;/p&gt;&gt; &#123;% else %&#125;&gt; &lt;p&gt;200&lt;/p&gt;&gt;&#123;% endif %&#125;&gt; 案例app01/templatetags/my_tag_filter.py from django import templateregister = template.Library()# 自定义过滤器@register.filterdef multi_filter(x, y): return x * y# 自定义标签@register.simple_tagdef multi_tag(x, y): return x * y index.html &lt;body&gt;&lt;h4&gt;自定义过滤器,标签&lt;/h4&gt;&#123;% load my_tag_filter %&#125;&lt;p&gt;&#123;&#123; 10|multi_filter:20 &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;% multi_tag 7 9 %&#125;&lt;/p&gt;&lt;/body&gt; 模板的继承和导入 首先需要在被继承的模板中划分多个区域 &#123;% block 给区域起的名字 %&#125;&#123;% endblock %&#125; 通常情况下一个模板中应该至少有三块 &#123;% block css %&#125;页面css代码块&#123;% endblock %&#125;&#123;% block js %&#125;页面js代码块&#123;% endblock %&#125;&#123;% block content %&#125;页面主体内容&#123;% endblock %&#125; 子板继承模板 先继承模板所有的内容 &#123;% extends 'home.html' %&#125; 然后根据block块的名字修改指定区域的内容 &#123;% block content %&#125; &lt;h1&gt;登录页面&lt;/h1&gt; &lt;form action=\"\"&gt; &lt;p&gt;username:&lt;input type=\"text\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;password:&lt;input type=\"text\" class=\"form-control\"&gt;&lt;/p&gt; &lt;input type=\"submit\" class=\"btn btn-success\"&gt; &lt;/form&gt;&#123;% endblock %&#125; 模板的导入 模板的导入:将一段html当做模块的方式导入到另一个html展示 &#123;% include '想导入的html文件名' %&#125; 静态文件配置&#123;% load static %&#125; &lt;link rel='stylesheet' href=\"&#123;% static 'css/mycss.css'%&#125;\"&gt; # 第一种方式&lt;link rel='stylesheet' href=\"&#123;% get_static_prefix %&#125;css/mycss.css\"&gt; # 第二种方式 案例urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index/', views.index), url(r'^home/',views.home), url(r'^login/',views.login), url(r'^reg/',views.reg),] views.py from django.shortcuts import renderdef home(request): return render(request,'home.html')def login(request): return render(request,'login1.html')def reg(request): return render(request,'reg.html') home.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;link href=\"https://cdn.bootcss.com/twitter-bootstrap/3.4.0/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;script src=\"https://cdn.bootcss.com/twitter-bootstrap/3.4.0/js/bootstrap.min.js\"&gt;&lt;/script&gt; &#123;% block css %&#125; &#123;% endblock %&#125;&lt;/head&gt;&lt;body&gt;&lt;nav class=\"navbar navbar-default\"&gt; &lt;div class=\"container-fluid\"&gt; &lt;!-- Brand and toggle get grouped for better mobile display --&gt; &lt;div class=\"navbar-header\"&gt; &lt;button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#bs-example-navbar-collapse-1\" aria-expanded=\"false\"&gt; &lt;span class=\"sr-only\"&gt;Toggle navigation&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=\"navbar-brand\" href=\"#\"&gt;Brand&lt;/a&gt; &lt;/div&gt; &lt;!-- Collect the nav links, forms, and other content for toggling --&gt; &lt;div class=\"collapse navbar-collapse\" id=\"bs-example-navbar-collapse-1\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"#\"&gt;Link &lt;span class=\"sr-only\"&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\" role=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\"&gt;Dropdown &lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=\"separator\" class=\"divider\"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;li role=\"separator\" class=\"divider\"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;One more separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;form class=\"navbar-form navbar-left\"&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"Search\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;ul class=\"nav navbar-nav navbar-right\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Link&lt;/a&gt;&lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\" role=\"button\" aria-haspopup=\"true\" aria-expanded=\"false\"&gt;Dropdown &lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=\"separator\" class=\"divider\"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!-- /.navbar-collapse --&gt; &lt;/div&gt;&lt;!-- /.container-fluid --&gt;&lt;/nav&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-3\"&gt; &lt;div class=\"list-group\"&gt; &lt;a href=\"/login\" class=\"list-group-item active\"&gt; login &lt;/a&gt; &lt;a href=\"/reg\" class=\"list-group-item\"&gt;reg&lt;/a&gt; &lt;a href=\"#\" class=\"list-group-item\"&gt;Morbi leo risus&lt;/a&gt; &lt;a href=\"#\" class=\"list-group-item\"&gt;Porta ac consectetur ac&lt;/a&gt; &lt;a href=\"#\" class=\"list-group-item\"&gt;Vestibulum at eros&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-md-9\"&gt; &#123;% block content %&#125; &lt;div class=\"jumbotron\"&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;p&gt;...&lt;/p&gt; &lt;p&gt;&lt;a class=\"btn btn-primary btn-lg\" href=\"#\" role=\"button\"&gt;Learn more&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &#123;% include 'hualihushao.html' %&#125; &#123;% endblock %&#125; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&#123;% block js %&#125;&#123;% endblock %&#125;&lt;/body&gt;&lt;/html&gt; login1.html &#123;% extends 'home.html' %&#125;&#123;% block content %&#125;&lt;h1&gt;登录页面&lt;/h1&gt; &lt;form action=\"\"&gt; &lt;p&gt;username:&lt;input type=\"text\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;password:&lt;input type=\"text\" class=\"form-control\"&gt;&lt;/p&gt; &lt;input type=\"submit\" class=\"btn btn-success\"&gt; &lt;/form&gt; &#123;% include 'hualihushao.html' %&#125;&#123;% endblock %&#125; reg.html &#123;% extends 'home.html' %&#125;&#123;% block content %&#125;&lt;h1&gt;注册页面&lt;/h1&gt; &lt;form action=\"\"&gt; &lt;p&gt;username:&lt;input type=\"text\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;password:&lt;input type=\"text\" class=\"form-control\"&gt;&lt;/p&gt; &lt;input type=\"submit\" class=\"btn btn-danger pull-right\"&gt; &lt;/form&gt;&#123;% endblock %&#125; hualihushao.html &lt;h1&gt;我是这条gai最靓的仔&lt;/h1&gt;&lt;form action=\"\"&gt; &lt;p&gt;&lt;input type=\"text\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"text\"&gt;&lt;/p&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"模板层","slug":"模板层","permalink":"http://cjwnb.top/tags/模板层/"}]},{"title":"视图层","slug":"视图层","date":"2019-07-17T08:26:12.757Z","updated":"2019-07-17T18:00:32.713Z","comments":true,"path":"2019/07/17/视图层/","link":"","permalink":"http://cjwnb.top/2019/07/17/视图层/","excerpt":"","text":"FBV与CBV FBV 基于函数的视图 CBV 基于类的视图 FBVurlpatterns = [ path('admin/', admin.site.urls), path('index/&lt;yyyy:id&gt;', views.index),]def index(request, id): print(id, type(id)) # 222 &lt;class 'str'&gt; return HttpResponse('index') CBV​ 无论是FBV还是CBV路由层都是路由对应视图函数内存地址 urlpatterns = [ # url(r'^mycls/',views.view) url(r'^mycls/',views.MyCls.as_view())]class MyCls(View): def get(self,request): return render(request,'index.html') def post(self,request): return HttpResponse('post') urls.py from django.contrib import adminfrom django.urls import path, re_pathfrom app01 import viewsurlpatterns = [ url('^admin/', admin.site.urls), url('^test', views.MyCls.as_view())] views.py from django.shortcuts import render, HttpResponse# Create your views here.class MyCls(View): def get(self, request): return render(request, 'test.html') def post(self, request): return HttpResponse('post') test.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;欢迎访问&lt;/h1&gt;&lt;form action=\"/test/\" method=\"post\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 请求对象request 当一个页面被请求时，Django就会创建一个包含本次请求原信息的HttpRequest对象。Django会将这个对象自动传递给响应的视图函数，一般视图函数约定俗成地使用 request 参数承接这个对象。 请求地址格式http://127.0.0.1/index url:协议://IP:port/路径？get请求数据 request方法 常用方法request.get_full_path() 路径加参数，如果输入URL请求是http://127.0.0.1:8000/index/?a=1， 则输出为index/?a=1 request.path() 只输出路径，如果输入URL请求是http://127.0.0.1:8000/index/?a=1， 则输出为index/ urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index',views.index)] views.py from django.shortcuts import render,HttpResponse# Create your views here.def index(request): print(request) print(request.get_full_path()) # /index/?a=1 print(request.path) # /index/ return HttpResponse('ok') 响应对象response 与由Django自动创建的HttpRequest对象相比，HttpResponse对象是我们的职责范围了。我们写的每个视图都需要实例化，填充和返回一个HttpResponse。 HttpResponse类位于django.http模块中。 urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^index',views.index)] views.py from django.shortcuts import render,HttpResponse# Create your views here.def index(request): print(request) print(request.get_full_path()) # /index/?a=1 print(request.path) # /index/ return HttpResponse('ok') 浏览器返回Json格式 希望在浏览器返回一个大字典，我们想到了Httpresponse({‘name’:’lyysb’,’password’:123344}) 在django中，通过JsonResponse这个类来完成 测试1urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'test',views.Test.as_view()),] views.py from django.views import Viewfrom django.shortcuts import HttpResponse, render, redirectclass Test(View): def get(self, request): data=&#123;'name': 'lyysb', 'password': 123332&#125; return HttpResponse(data) def post(self, request): pass 浏览器输入http://127.0.0.1:8000/test/ 只是返回来字典的键值 所以如果要这个字典完整在浏览器上渲染，尝试使用json格式字符串 测试2修改views.py里的代码 views.py from django.views import Viewfrom django.shortcuts import HttpResponseimport jsonclass Test(View): def get(self, request): data = &#123;'name': 'lyy傻缺', 'password': 123332&#125; return HttpResponse(json.dumps(data, ensure_ascii=False)) # ensure_ascii=False参数的作用是使得中文能够在浏览器上渲染 def post(self, request): pass 浏览器输入http://127.0.0.1:8000/test/ 测试3 使用 JsonResponse 返回json字符串 JsonResponse 源码 内部调用的也是Json模块，封装了json.dumps() 如果需要传递参数，通过 json_dumps_params 关键字传参，传参的值以字典的形式传值,因为这样 json_dumps_params的值就打散成key=value的形式为json.dumps()传递 比如说 json.dumps(data, ensure_ascii=False)，要使用JsonResponse得到同样的效果 就这么用: JsonResponse(data,json_dumps_params={‘ensure_ascii’:False}) class JsonResponse(HttpResponse): def __init__(self, data, encoder=DjangoJSONEncoder, safe=True, json_dumps_params=None, **kwargs): if safe and not isinstance(data, dict): raise TypeError( 'In order to allow non-dict objects to be serialized set the ' 'safe parameter to False.' ) if json_dumps_params is None: json_dumps_params = &#123;&#125; kwargs.setdefault('content_type', 'application/json') data = json.dumps(data, cls=encoder, **json_dumps_params) super(JsonResponse, self).__init__(content=data, **kwargs) views.py from django.http import JsonResponsefrom django.views import Viewclass Test(View): def get(self, request): data = &#123;'name': 'lyy傻缺', 'password': 123332&#125; return JsonResponse(data,json_dumps_params=&#123;'ensure_ascii':False&#125;) def post(self, request): pass urls.py from django.contrib import adminfrom django.urls import path, re_pathfrom app01 import viewsurlpatterns = [ url('^admin/', admin.site.urls), url('^test', views.MyCls.as_view())] 文件上传实现简单的文件上传 urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'upload', views.Upload_file.as_view()),] views.py from django.views import Viewfrom django.shortcuts import HttpResponse, renderclass Upload_file(View): def get(self, request): return render(request, 'test.html') def post(self, request): file_obj = request.FILES.get('myfile') with open(file_obj.name, 'wb') as f: for line in file_obj.chunks(): f.write(line) return HttpResponse('ok') test.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;上传文件&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"myfile\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"视图层","slug":"视图层","permalink":"http://cjwnb.top/tags/视图层/"}]},{"title":"虚拟环境","slug":"虚拟环境","date":"2019-07-17T06:09:46.748Z","updated":"2019-07-17T08:14:02.937Z","comments":true,"path":"2019/07/17/虚拟环境/","link":"","permalink":"http://cjwnb.top/2019/07/17/虚拟环境/","excerpt":"","text":"虚拟环境不同的项目配置不同的python解释器 django1.0与django2.0之间的区别 django2.0里面的path第一个参数不支持正则，你写什么就匹配，100%精准匹配 django2.0里面的re_path对应着django1.0里面的url urls.py from django.contrib import adminfrom django.urls import path,re_pathfrom app01 import viewsurlpatterns = [ path('admin/', admin.site.urls), re_path('^index/',views.index)] views.py from django.shortcuts import render,HttpResponse# Create your views here.def index(request): return HttpResponse('index') 虽然django2.0里面的path不支持正则表达式，但是它提供五个默认的转换器 str,匹配除了路径分隔符（/）之外的非空字符串，这是默认的形式int,匹配正整数，包含0。slug,匹配字母、数字以及横杠、下划线组成的字符串。uuid,匹配格式化的uuid，如 075194d3-6885-417e-a8a8-6c931e272f00。path,匹配任何非空字符串，包含了路径分隔符（/）（不能用？） urls.py from django.contrib import adminfrom django.urls import path,re_pathfrom app01 import viewsurlpatterns = [ path('admin/', admin.site.urls), path('index/&lt;str:id&gt;', views.index),] views.py from django.shortcuts import HttpResponsedef index(request, id): print(id, type(id)) # 222 &lt;class 'str'&gt; return HttpResponse('index') 自定义转换器 正则表达式 类 注册 class FourDigitYearConverter: regex = '[0-9]&#123;4&#125;' def to_python(self, value): return int(value) def to_url(self, value): return '%04d' % value # 占四位，不够用0填满，超了则就按超了的位数来！ register_converter(FourDigitYearConverter, 'yyyy') PS:路由匹配到的数据默认都是字符串形式 urls.py from django.contrib import adminfrom django.urls import path,re_pathfrom app01 import viewsfrom django.urls import path,re_path,register_converter# 自定义转换器，将浏览器输入路径的最后一个名字转换为4位数字，如果不够用0填充class FourDigitYearConverter: regex = '[0-9]&#123;4&#125;' def to_python(self, value): return int(value) def to_url(self, value): return '%04d' % value # 占四位，不够用0填满，超了则就按超了的位数来！register_converter(FourDigitYearConverter, 'yyyy')urlpatterns = [ path('admin/', admin.site.urls), path('index/&lt;yyyy:id&gt;', views.index),] views.py from django.shortcuts import HttpResponsedef index(request, id): print(id, type(id)) # 2222 &lt;class 'int'&gt; return HttpResponse('index') 浏览器输入http://127.0.0.1:8000/index/2222 测试","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"路由层","slug":"路由层","permalink":"http://cjwnb.top/tags/路由层/"}]},{"title":"django 路由层之反向解析","slug":"Django路由层之反向解析","date":"2019-07-17T05:01:02.257Z","updated":"2019-07-17T05:40:29.656Z","comments":true,"path":"2019/07/17/Django路由层之反向解析/","link":"","permalink":"http://cjwnb.top/2019/07/17/Django路由层之反向解析/","excerpt":"","text":"反向解析根据名字动态获取到对应的路径 可以给每一个路由与视图函数对应关系起一个名字这个名字能够唯一标识出对应的路径注意这个名字不能重复是唯一的 from django.shortcuts import reverseurl(r'^index6668888/$',views.index,name='index') 前端使用 &#123;% url 'index' %&#125;&#123;% url '你给路由与视图函数对应关系起的别名' %&#125; 后端使用 reverse('index')reverse('你给路由与视图函数对应关系起的别名') 有名分组反向解析后端使用 # 后端有名分组和无名分组都可以用这种形式 print(reverse('list',args=(10,))) # 下面这个了解即可 print(reverse('list',kwargs=&#123;'year':10&#125;)) 前端使用 # 前端有名分组和无名分组都可以用这种形式 &#123;% url 'list' 10 %&#125; # 下面这个了解即可 &#123;% url 'list' year=10 %&#125; 无名分组反向解析后端使用 reverse('list',args=(10,)) # 这里的数字通常都是数据的主键值 前端使用 &#123;% url 'list' 10 %&#125; 总结 针对有名分组与无名分组的反向解析统一采用一种格式即可 反向解析的本质:就是获取到一个能够访问名字所对应的视图函数 应用场景 通过别名来传递路径给到前端或者后端，好处是更加灵活，因为是通过别名进行传递，所以只要修改源路径，其他的层都不需要更改，否则如果直接通过源路径传递，则耦合度较高，不够灵活，维护成本太高 案例1前端通过蒙版语法&#123;% url &apos;定义的别名&apos; %&#125;取值 login.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1&gt;登录界面&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\"&gt; &lt;form action=\"&#123;% url 'log' %&#125;/\" method=\"post\"&gt; &lt;p&gt;用户名 &lt;input type=\"text\" name=\"user\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;密码 &lt;input type=\"password\" name=\"pwd\" class=\"form-control\"&gt;&lt;/p&gt; &lt;input type=\"submit\" value=\"登录\" class=\"btn btn-primary\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; views.py from django.shortcuts import render, HttpResponse# Create your views here.# 只要是和请求相关的事情，都需要用到requestdef login(request): if request.method == 'GET': return render(request, 'login.html') else: user = request.POST.get('user') pwd = request.POST.get('pwd') if user == \"lxx\" and pwd == '123': return HttpResponse('登录成功') else: return HttpResponse('用户名或者密码错误') urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login.html/', views.login,name='log'), 案例2后端通过reverse函数取值 urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login.html/', views.login, name='log'), url(r'^test/', views.test, name='t1'),] views.py from django.shortcuts import render, HttpResponse,redirect,reverse# 只要是和请求相关的事情，都需要用到requestdef login(request): if request.method == 'GET': return render(request, 'login.html') else: user = request.POST.get('user') pwd = request.POST.get('pwd') if user == \"lxx\" and pwd == '123': return HttpResponse('登录成功') else: return redirect(reverse('t1')) # 跳转到别名为t1的路径/test/def test(request): return HttpResponse('用户名或者密码错误') 案例3有名分组反向解析 urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login.html/', views.login, name='log'), url(r'^test/([0-9]+)', views.test, name='t1'),] views.py from django.shortcuts import render, HttpResponse, redirect, reversedef test(request, group): # 当输入 http://127.0.0.1:8000/test/2018/， group接收的值就是2018 print(reverse('t1', args=(group,))) # /test/2018 if request.method == 'GET': return render(request, 'group.html', &#123;'group': group&#125;) else: return HttpResponse('test') group.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1&gt;有名分组反向解析测试&lt;/h1&gt; &lt;div class=\"col-md-2 col-md-offset-4\"&gt; &lt;form action=\"&#123;% url 't1' group %&#125;/\" method=\"post\"&gt; &lt;p&gt;用户名 &lt;input type=\"text\" name=\"user\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;密码 &lt;input type=\"password\" name=\"pwd\" class=\"form-control\"&gt;&lt;/p&gt; &lt;input type=\"submit\" class=\"btn btn-success\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; 案例4无名分组反向解析, 和有名分组一模一样 urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login.html/', views.login, name='log'), url(r'^test/(?P&lt;xxx&gt;\\d+)', views.test, name='t1'),] views.py def test(request, xxx): print(reverse('t1', args=(xxx,))) if request.method == 'GET': return render(request, 'group.html', &#123;'group': xxx&#125;) else: return HttpResponse('test') group.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1&gt;无名分组反向解析测试&lt;/h1&gt; &lt;div class=\"col-md-2 col-md-offset-4\"&gt; &lt;form action=\"&#123;% url 't1' group %&#125;/\" method=\"post\"&gt; # 从后端取得url的别名和路径最后的数字 &lt;p&gt;用户名 &lt;input type=\"text\" name=\"user\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;密码 &lt;input type=\"password\" name=\"pwd\" class=\"form-control\"&gt;&lt;/p&gt; &lt;input type=\"submit\" class=\"btn btn-success\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; 名称空间即使不同的APP使用相同的URL名称，URL的命名空间模式也可以让你唯一反转命名的URL。 不使用名称空间，两个app出现同名的路由名字，则匹配到就会匹配，这样的话两个app访问的是同一个网页，并不是不同的 先创建一个新的app manage.py@dj4 &gt; startapp app02 注册app settings.py INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'app01.apps.App01Config', 'app02.apps.App02Config',] 案例1urls.py from django.conf.urls import url, includeurlpatterns = [ url(r'app01/',include('app01.urls')), url(r'app02/',include('app02.urls')),] app01.urls from django.conf.urls import urlfrom app01 import viewsurlpatterns = [ url('^index/',views.index)] app01.views def index(request): return HttpResponse('index1') app02.urls` from django.conf.urls import urlfrom app01 import viewsurlpatterns = [ url('^index/',views.index)] app02.views def index(request): return HttpResponse('index2') 测试 输入 http://127.0.0.1:8000/app01/index/ 输入 http://127.0.0.1:8000/app02/index/ 两个url访问的都是app01下的index的内容，这种是有问题的，如果需要每个app访问的都是自己的网页内容，但是路由名字又和其他app里的是一样的，这种用名称空间解决 案例2给两个app的URL路由关系创建一个名称空间 urls.py from django.conf.urls import url, includeurlpatterns = [ # 第一种写法 # url(r'app01/', include(\"app01.urls\", namespace=\"app01\")), # url(r'app02/', include(\"app02.urls\", namespace=\"app02\")), # 第二种写法 url(r'app01/', include((\"app01.urls\", \"app01\"))), url(r'app02/', include((\"app02.urls\", \"app02\"))),] app01.urls.py from django.conf.urls import urlfrom app01 import viewsurlpatterns = [ url('^index/', views.index)] app02.urls.py from django.conf.urls import urlfrom app02 import viewsurlpatterns = [ url('^index/',views.index)] app01.views.py def index(request): return HttpResponse('index1') app02.views.py def index(request): return HttpResponse('index2')","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"路由层","slug":"路由层","permalink":"http://cjwnb.top/tags/路由层/"}]},{"title":"pycharm快捷键","slug":"pycharm快捷键","date":"2019-07-16T13:40:50.273Z","updated":"2019-07-16T13:43:59.574Z","comments":true,"path":"2019/07/16/pycharm快捷键/","link":"","permalink":"http://cjwnb.top/2019/07/16/pycharm快捷键/","excerpt":"","text":"自动导入模块 默认是ctrl+alt+enter, 但是有时候没用，需要去pycharm里的快捷键配置菜单查看 默认系统配置了2个快捷键，第一个是没用的 第二个设置的快捷键才有用","categories":[{"name":"工具","slug":"工具","permalink":"http://cjwnb.top/categories/工具/"}],"tags":[{"name":"pycharm","slug":"pycharm","permalink":"http://cjwnb.top/tags/pycharm/"}]},{"title":"图书管理系统","slug":"图书管理系统","date":"2019-07-16T05:46:49.629Z","updated":"2019-07-16T07:15:15.038Z","comments":true,"path":"2019/07/16/图书管理系统/","link":"","permalink":"http://cjwnb.top/2019/07/16/图书管理系统/","excerpt":"","text":"图书管理系统表设计书籍表id title price 作者表id name age 出版社id name email 一对多映射关系一本书只能由一个出版社出版，一个出版社可以出版多本书，出版社-书籍 为一对多的关系,所以对书籍表做一个外键 id title price publish_id 多对多映射关系表id book_id author_id 代码实现连接数据库并设置pymysql来连接settings.py 配置数据库并注释中间件’django.middleware.csrf.CsrfViewMiddleware’ MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',]DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'book', 'HOST': '127.0.0.1', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123' &#125;&#125; __init__.py 告诉django用pymysql替换它默认mysql_db模块来连接数据库 import pymysqlpymysql.install_as_MySQLdb() 定义表的字段from django.db import models# Create your models here.class Book(models.Model): # id字段可以不写，默认会帮你创建一个主键id字段 title = models.CharField(max_length=32) price = models.DecimalField(max_digits=8, decimal_places=2) # 一对多外键字段的建立 publish = models.ForeignKey(to='Publish') # 默认是与publish的id字段建立关联 # 多对多外键字段建在关联的两张表的任何一张都可以，建议建在查询评率比较高的那张表里 author = models.ManyToManyField(to='Author') # django orm会自动帮你创建book与author的第三张表 # 注意： 多对多字段不会显示到表的字段中class Publish(models.Model): name = models.CharField(max_length=32) email = models.CharField(max_length=32)class Author(models.Model): name = models.CharField(max_length=32) age = models.IntegerField() 创建表命令行工具执行命令 manage.py@book_mgmt &gt; makemigrationsmanage.py@book_mgmt &gt; migrate 注意外键字段名 orm会自动在字段名后面加_id, 无论你的字段名有没有_id","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"项目","slug":"项目","permalink":"http://cjwnb.top/tags/项目/"}]},{"title":"Django 请求生命周期","slug":"Django 请求生命周期","date":"2019-07-16T03:31:49.436Z","updated":"2019-07-16T07:57:01.277Z","comments":true,"path":"2019/07/16/Django 请求生命周期/","link":"","permalink":"http://cjwnb.top/2019/07/16/Django 请求生命周期/","excerpt":"","text":"简易版本","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"}]},{"title":"django小项目","slug":"django小项目","date":"2019-07-15T14:25:52.854Z","updated":"2019-07-17T04:28:58.307Z","comments":true,"path":"2019/07/15/django小项目/","link":"","permalink":"http://cjwnb.top/2019/07/15/django小项目/","excerpt":"","text":"最后需要实现的效果登录，注册，简单的增删改查 后端数据库models.py from django.db import models# Create your models here.class User(models.Model): # User表的主键字段名就是id id = models.AutoField(primary_key=True) # varchar(32) name字段是varchar(32) CharField在定义的时候必须要加max_length参数，不加直接报错 name = models.CharField(max_length=32) # varchar(32) password字段是varchar(32) CharField在定义的时候必须要加max_length参数，不加直接报错 password = models.CharField(max_length=32) def __str__(self): return self.name 路由分发urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login/', views.login), url(r'^reg/', views.reg), url(r'^userlist/', views.userlist), url(r'^delete_user/', views.delete_user), url(r'^edit_user/', views.edit_user), 视图函数views.py from django.shortcuts import render, HttpResponse, redirect# Create your views here.from app01 import modelsdef login(request): if request.method == 'POST': import pymysql # 获取用户输入的用户名和密码 username = request.POST.get('username') password = request.POST.get('password') conn = pymysql.connect( host='127.0.0.1', user=\"root\", password=\"123\", database='django', port=3306, charset='utf8', autocommit=True ) cursors = conn.cursor(pymysql.cursors.DictCursor) cursors.execute('select * from userinfo where name=%s and password=%s', args=(username, password)) user_info = cursors.fetchone() # 如果只查询到一个结果，fetchone直接返回一个字典，而fetchall还是返回一个列表，里面套个字典 if user_info: return HttpResponse('登录成功') return HttpResponse('用户名或密码错误') return render(request, \"login.html\")def reg(request): # 必须要加if判断，如果加的话，永远访问不了网页 # IntegrityError at /reg/ (1048, \"Column 'name' cannot be null\") if request.method == 'POST': # 接收前台通过form表单发送的数据 username = request.POST.get('username') password = request.POST.get('password') print(username, password) # 操作数据库 # 方式1 user_obj = models.User.objects.create(name=username, password=password) # User_obj=User object print(user_obj.pk) # pk获取主键字段对应的值 无论的你主键叫上面名字 print(user_obj.id) # 获取用户数据的id值,可以看到和pk的属性是一样的 print(user_obj.name) # 获取用户数据的name值 print(user_obj.password) # 获取用户数据的password值 # 方式2 # user_obj = models.User(name=username, password=password) # User_obj=User object # models.User.save(user_obj) # 对象调用save方法保存到数据库 # print(user_obj.pk) # pk获取主键字段对应的值 无论的你主键叫上面名字 # print(user_obj.id) # 获取用户数据的id值,可以看到和pk的属性是一样的 # print(user_obj.name) # 获取用户数据的name值 # print(user_obj.password) # 获取用户数据的password值 return redirect('/userlist/') return render(request, 'reg.html')def userlist(request): # 操作数据库 user_obj = models.User.objects.all() # # 获取user表所有的数据 # print(user_obj) # &lt;QuerySet [&lt;User: lyysb&gt;, &lt;User: lyysb&gt;, 。。。&gt; # 只要是QuerySet就可以点query查看获取到当前QuerySet对象的内部sql语句 # print(user_obj.query) # SELECT `app01_user`.`id`, `app01_user`.`name`, `app01_user`.`password` FROM `app01_user` return render(request, 'userlist.html', locals())def delete_user(request): # 删除时候执行的是GET请求，所以在前端提交的时候携带参数传给后端（http://127.0.0.1:8000/delete_user/?id=4） # print(request.GET) id = request.GET.get('id') # 查询操作 最后查询到的是一个queryset对象，里面是一个列表，可以通过first()方法取列表中的第一个元素 # user_obj2 = models.User.objects.filter(id=id) # print(user_obj2) #&lt;QuerySet [&lt;User: luowensg&gt;]&gt; # print(user_obj2.first()) # luowensg models.User.objects.filter(id=id).delete() return redirect('/userlist/')def edit_user(request): ''' [15/Jul/2019 13:35:26] \"GET /userlist/ HTTP/1.1\" 200 3784 访问userlist [15/Jul/2019 13:35:28] \"GET /edit_user/?id=5 HTTP/1.1\" 200 753 通过userlist.html上的修改用户按钮进入edit.html [15/Jul/2019 13:35:33] \"POST /edit_user/?id=5 HTTP/1.1\" 302 0 执行edit.html上的按钮，如果提交的话，就会重定向，因为函数里定义的返回值 return redirect('/userlist/') [15/Jul/2019 13:35:33] \"GET /userlist/ HTTP/1.1\" 200 3780 最后重定向到userlist.html上查看结果，所以是GET请求 :param request: :return: ''' # 4. 我们要操作数据库，更改一条数据，需要拿到表中的id字段的值 # 当用户点击修改用户按钮，跳转到edit.html,这个行为是GET，然后修改完数据之后提交，这个动作是POST # 我们在前端在form表单里面配置form表单中的路径参数携带?id=xx，所以可以通过request.GET.get('id')拿到id的值 # 我们也可以新建一个input标签，type设置为hidden,然后配置value这个属性，value这个属性的值由后台的数据库对象user_obj.id获得 if request.method == 'POST': username = request.POST.get('username') password = request.POST.get('password') # 方式1 新建一个input标签，type设置为hidden,然后配置value这个属性，value这个属性的值由后台的数据库对象user_obj.id获得 id=request.POST.get('id') # 方式2 在前端在form表单里面配置form表单中的路径参数携带?id=xx，通过request.GET.get('id')拿到id的值 # id = request.GET.get('id') # 操作数据库修改数据 # 方式1 # models.User.objects.filter(id=id).update(name=username,password=password) # 方式2 user_obj=models.User.objects.filter(id=id) user=user_obj.first() # lyysb 输出lyysb而不是一个对象，因为在ORM中类定义的时候定义了__str__，限定输出对象的name字段 # lxxsb &lt;class 'app01.models.User'&gt; # user_obj就是一个通过数据库查询到的一个queryset对象，queryset这个对象是一个列表，first方法就是把列表中的第一个元素user取出来了 # 这里通过id进行匹配，id这个字段在数据库中是唯一的，所以最后匹配到的就是只有一行数据对应的一个对象user # 我们可以通过user的.语法对查询到的这一行的数据库的字段进行修改 user.name=username user.password=password user.save() # 操作完数据库重定向到userlist网页查看用户列表，查看是否操作成功 return redirect('/userlist/') # 1.获取用户想要修改的id id = request.GET.get('id') # 2. 将该数据查询出来渲染到一个编辑页面 # 查询数据方式1 # filter当条件不存在的情况下会返回None # 比如说 user_obj = models.User.objects.filter(id=8888).first()，返回None user_obj = models.User.objects.filter(id=id).first() # 查询数据方式2 # 弊端: 如果查询不到数据对象就会报错，所有已不推荐使用 # 比如说 user_obj = models.User.objects.get(id=2222) # 就会报 500的错误 # app01.models.DoesNotExist: User matching query does not exist. # [15/Jul/2019 12:31:27] \"GET /edit_user/?id=5 HTTP/1.1\" 500 69867 # user_obj = models.User.objects.get(id=id) # owensb,这里直接显示name， # 因为在models类里面定义了__str__定义输出为对象的name字段的值（User object.name)， # 如果不设置，输出为对象 User object # print(user_obj) # print(type(user_obj)) # &lt;class 'app01.models.User'&gt; # 3. 将当前数据渲染到一个编辑页面上，只要是渲染页面相关的操作，就应该想到用render return render(request, 'edit.html', &#123;'user_obj': user_obj&#125;) 设置settings.py # 注册app01INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'app01.apps.App01Config',]# 暂时取消'django.middleware.csrf.CsrfViewMiddleware',MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',]# 数据库配置DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'django2', 'HOST': '127.0.0.1', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123' &#125;&#125;# 静态文件配置 (static主要存放bootstrap,css,fonts,img,js等目录)STATIC_URL = '/static/'STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static') __init__.py应用和项目目录都有这个文件，建在任何一个文件里都可以 import pymysqlpymysql.install_as_MySQLdb() # 告诉django用pymysql代替mysqldb连接数据库 前端userlist.html &lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1&gt;用户列表&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\"&gt; &lt;a href=\"/reg/\" class=\"btn btn-success\"&gt;注册用户&lt;/a&gt; &lt;a href=\"/login/\" class=\"btn btn-warning\"&gt;用户登录&lt;/a&gt; &lt;table class=\"table table-hover table-bordered table-striped table-condensed\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;password&lt;/th&gt; &lt;th&gt;action&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;% for user in user_obj %&#125; &lt;tr&gt; &lt;td&gt; &#123;&#123; user.pk &#125;&#125;&lt;/td&gt; &lt;td&gt; &#123;&#123; user.name &#125;&#125;&lt;/td&gt; &lt;td&gt; &#123;&#123; user.password &#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=\"/delete_user/?id=&#123;&#123; user.pk &#125;&#125;\" class=\"btn btn-danger\"&gt;删除用户&lt;/a&gt; &lt;a href=\"/edit_user/?id=&#123;&#123; user.pk &#125;&#125;\" class=\"btn btn-primary\"&gt;修改用户&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; reg.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;注册&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1&gt;注册页面&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\"&gt; &lt;form action=\"\" method=\"post\"&gt; &lt;p&gt;用户名&lt;input type=\"text\" name=\"username\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;密码&lt;input type=\"password\" name=\"password\" class=\"form-control\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" class=\"btn btn-primary\"&gt;&lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; login.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1 class=\"h2\"&gt;登录页面&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\" &gt; &lt;form action=\"/login/\" method=\"post\"&gt; &lt;p&gt;用户名: &lt;input type=\"text\" class=\"form-control\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;密码: &lt;input type=\"password\" class=\"form-control\" name=\"password\"&gt; &lt;/p&gt; &lt;input type=\"submit\" value=\"登录\" class=\"btn btn-primary\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; edit.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;编辑&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1&gt;修改数据&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\"&gt; &lt;form action=\"/edit_user/?id=&#123;&#123; user_obj.id &#125;&#125;\" method=\"post\"&gt; &lt;p&gt;&lt;input type=\"hidden\" value=\"&#123;&#123; user_obj.id &#125;&#125;\" name=\"id\"&gt;&lt;/p&gt; &lt;p&gt;username&lt;input type=\"text\" name=\"username\" value=\"&#123;&#123; user_obj.name &#125;&#125;\"&gt;&lt;/p&gt; &lt;p&gt;password&lt;input type=\"password\" name=\"password\" value=\"&#123;&#123; user_obj.password&#125;&#125;\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" value=\"修改\" class=\"btn btn-warning\"&gt;&lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"}]},{"title":"django 路由层之分组","slug":"Django路由层之分组","date":"2019-07-09T16:59:06.950Z","updated":"2019-07-17T13:14:14.996Z","comments":true,"path":"2019/07/10/Django路由层之分组/","link":"","permalink":"http://cjwnb.top/2019/07/10/Django路由层之分组/","excerpt":"","text":"正则匹配urls.py urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^test', views.test), url(r'^testadd',views.testadd)] django项目目录中, 路由层就是urls.py这个文件来进行控制 urlpatterns这个变量定义的一个列表，列表中通过url这个函数进行路由分发到视图层 url函数中是通过正则匹配浏览器中输入的网址中的路径中的最后一位,最后一位的字符串就是admin,test,testadd. 证明urls.pyfrom django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url('test', views.test), url('testadd',views.testadd)] views.pydef test(request): return HttpResponse('test')def testadd(request): return HttpResponse('testadd') 浏览器测试 输入 http://127.0.0.1:8000/test/， 返回test 输入 http://127.0.0.1:8000/testadd/， 也是返回test 总结上面的结果并不是我们想要的，我们希望的结果是: 输入 http://127.0.0.1:8000/testadd/，页面返回testadd 输入 http://127.0.0.1:8000/test/，页面返回test 而从上面的结果验证可知道： 路由文件中url函数后面跟着的第一个参数是正则表达式,匹配规则按照从上往下一次匹配,匹配到一个之后立即匹配。 当我们输入 http://127.0.0.1:8000/testadd/, url(‘test’, views.test),这一个元素先匹配到了testadd,就相当于re.findall(‘test’,’testall’),这样就匹配到了test这个字符串，对应的会执行视图层中的test函数，所以最后返回来test &gt;&gt;&gt; import re&gt;&gt;&gt; re.findall('test','testall')['test'] 解决方案1:urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url('test/', views.test), url('testadd/',views.testadd)] 浏览器测试 输入 http://127.0.0.1:8000/test/， 返回test 输入 http://127.0.0.1:8000/testadd/，页面返回testadd 但是这里有个问题： 当我们输入 http://127.0.0.1:8000/test/sdsddsdsfsdf， 正常返回test 当我们输入 http://127.0.0.1:8000/dsdsdsdssdtest/sdsddsdsfsdf, 正常返回test 当我们输入 http://127.0.0.1:8000/testadd/sdsddsdsfsdf， 正常返回testadd 当我们输入 http://127.0.0.1:8000/dsdsdsdssdtestadd/sdsddsdsfsdf， 正常返回testadd 解决方案2因为路由匹配是正则匹配的规律，所以使用正则表达式进行精准匹配 urls.py urlpatterns = [ url(r'^admin/', admin.site.urls), url('^test/$', views.test), url('^testadd/$',views.testadd)] 新需求希望主页也有内容, 用户输错网址给个提示信息 urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^$',views.home), url('^test/$', views.test), url('^testadd/$',views.testadd), url(r'', views.error),] views.py from django.shortcuts import render,redirect,HttpResponse# Create your views here.def home(request): return HttpResponse('这是首页')def error(request): return HttpResponse('你输了什么鬼')def test(request): return HttpResponse('test')def testadd(request): return HttpResponse('testadd') 浏览器测试 路由分发url(&#39;正则表达式&#39;,&#39;视图函数内存地址&#39;) django每一个app下面都可以有自己的url.py 路由层，templates文件夹，static文件夹 项目名下urls.py(总路由)不再做路由与视图函数的匹配关系而是做路由的分发 from django.conf.urls import include# 路由分发 注意路由分发总路由千万不要$结尾url(r'^app01/',include(app01_urls)),url(r'^app02/',include(app02_urls))# 在应用下新建urls.py文件，在该文件内写路由与视图函数的对应关系即可from django.conf.urls import urlfrom app01 import viewsurlpatterns = [ url(r'^index/',views.index)] 案例urls.py from django.conf.urls import url, includeurlpatterns = [ url(r'app01/',include('app01.urls')), url(r'app02/',include('app02.urls')),] app01.urls from django.conf.urls import urlfrom app01 import viewsurlpatterns = [ url('^index/',views.index)] app01.views def index1(request): return HttpResponse('index1') app02.urls` from django.shortcuts import render,HttpResponse# Create your views here.def index(request): return HttpResponse('index2') app02.views def index2(request): return HttpResponse('index2') 分组无名分组将加括号的正则表达式匹配到的内容当做位置参数自动传递给对应的视图函数 默认匹配到后，默认把request一定会传给视图函数，因为url函数是采取正则匹配，正则匹配中如果匹配到分组的内容，则输出分组，所以我们可以通过正则表达式分组的特点将匹配到的分组的内容传递给视图函数，但是视图函数需要增加一个形参来接收正则匹配匹配到的分组的内容 &gt;&gt;&gt; re.findall('test/([0-9]+)','test/2018')['2018']&gt;&gt;&gt; re.findall('test/([0-9]+)','test/20183333333')['20183333333'] url(r'^test/(\\d+)/', views.test), # 匹配一个或多个数字def test(request,xxx): print(xxx) return HttpResponse('test') url.py urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^$', views.home), # url(r'^test/[0-9]&#123;4&#125;/', views.test), url(r'^test/(\\d+)/', views.test), # 匹配一个或多个数字 url(r'^testadd/', views.testadd), # url(r'',views.error)] views.py from django.shortcuts import render,HttpResponse,redirectdef test(request): return HttpResponse('test')def testadd(request): return HttpResponse('testadd')def home(request): return HttpResponse('首页')def error(request): return HttpResponse('广告位招租') 显示的页面 修改代码views.py from django.shortcuts import render,HttpResponse,redirectdef test(request,xxx): print(xxx) return HttpResponse('test') 有名分组将加括号的正则表达式的内容当做关键字参数自动传递给响应的视图函数 正则表达式复习&gt;&gt;&gt; a=re.match('test/(?P&lt;name&gt;[0-9]+)','test/123')&gt;&gt;&gt; a.group('name')'123'&gt;&gt;&gt; a=re.match('test/(?P&lt;name&gt;\\d+)','test/123')&gt;&gt;&gt; a.group('name')'123' 使用 url(r’^test/(?P\\d+)/‘, views.test) urls.py urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^$', views.home), # url(r'^test/[0-9]&#123;4&#125;/', views.test), # 无名分组 # url(r'^test/(\\d+)/', views.test), # 匹配一个或多个数字 # 有名分组 url(r'^test/(?P&lt;year&gt;\\d+)/', views.test), # 匹配一个或多个数字，并可以通过year取值 url(r'^testadd/', views.testadd), # url(r'',views.error) views.py def test(request,year): # 这里的形参year必须和路由层中正则匹配的名字是一样的 print(year) return HttpResponse('test') 注意 有名分组和无名分组不能混着用,但是多个有名分组和多个无名分组可以连用 测试 同时使用无名分组和有名分组, 报错 urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ # 测试 同时使用无名分组和有名分组 url(r'test/(?P&lt;year&gt;\\d+)/[0-9](\\d+)',views.test),] views.py def test(request,xxx,year): print(year) return HttpResponse('test') 使用多个有名分组 urls.py urlpatterns = [ # 测试 使用多个无名分组 url(r'test/(?P&lt;year&gt;\\d+)/(?P&lt;month&gt;\\d+)/(?P&lt;day&gt;\\d+)',views.test),] views.py from django.shortcuts import render,HttpResponse,redirectdef test(request,month,day,year): print(year) return HttpResponse('test')","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"路由层","slug":"路由层","permalink":"http://cjwnb.top/tags/路由层/"}]},{"title":"django基础","slug":"Django基础","date":"2019-07-09T06:13:20.537Z","updated":"2019-07-16T02:08:20.451Z","comments":true,"path":"2019/07/09/Django基础/","link":"","permalink":"http://cjwnb.top/2019/07/09/Django基础/","excerpt":"","text":"MTVDjango是一种MTV的设计模式，各组件之间保持松耦合关系 M 代表模型 (Model): 负责业务对象和数据库的关系映射(ORM)T 代表模板(Template): 负责如何把页面展示给用户(html)V 代表视图(View): 负责业务逻辑，并在适当时候调用Model和Template除了以上三层外，还需要一个URL分发器，它的作用是将一个个URL的页面分发给不同的view处理，View再调用响应的Model和Template 下载Django# pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple django==1.11.10 查看Django$ python&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.path['', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/lib-dynload', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages']&gt;&gt;&gt; exit()$ cd /Library/Frameworks/Python.framework/Versions$ open 3.6/ 更快速的方法django-admin $ django-adminType 'django-admin help &lt;subcommand&gt;' for help on a specific subcommand.Available subcommands:[django] check compilemessages createcachetable dbshell diffsettings dumpdata flush inspectdb loaddata makemessages makemigrations migrate runserver sendtestemail shell showmigrations sqlflush sqlmigrate sqlsequencereset squashmigrations startapp startproject test testserverNote that only Django core commands are listed as settings are not properly configured (error: Requested setting INSTALLED_APPS, but settings are not configured. You must either define the environment variable DJANGO_SETTINGS_MODULE or call settings.configure() before accessing settings.). Django的创建和启动命令行方式# 创建项目$ cd My_pro/$ django-admin.py startproject mysites# 创建应用$ cd mysites/$ python3 manage.py startapp blog# 启动项目$ python3 manage.py runserver 访问 http://127.0.0.1:8000 pycharm Django目录介绍first_pro:&gt;&gt;&gt; app01: 应用相关的目录 migrations: 数据库迁移相关数据 admin.py: Django后台管理相关 models.py: 模型表相关（数据库） views.py: 视图函数相关&gt;&gt;&gt; first_pro: 项目相关的目录 settings.py: 包含了项目的默认配置，包括数据库信息，调试标志以及其他一些工作的变量 urls.py: 路由文件（控制器）负责把URL模式映射到应用程序 wsgi.py: 启动socket 服务端的文件&gt;&gt;&gt; templates: 项目用到的所有html文件&gt;&gt;&gt;manage.py: Django项目里面的工具，通过它可以调用Django shell和数据库等 案例通过Django查看时间的一个简单页面 后端 url.py 当执行timer函数时候，会把request都传给函数views.timer(request),所以views的函数必须加形参request urlpatterns = [ url('^admin/', admin.site.urls), url('^timer/', views.timer), ] views.py def timer(request): import time ctime = time.time() return render(request, \"timer.html\", &#123;'ctime': ctime&#125;) 前端 timer.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;当前时间:&#123;&#123; ctime &#125;&#125;&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt; Django 静态文件配置通过路径访问 http://127.0.0.1:8000/static/bootstrap.js 无法访问 配置settings.py STATIC_URL = '/static/'STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static'),] time.html &lt;script src=\"/static/bootstrap.js\"&gt;&lt;/script&gt; 地址栏 http://127.0.0.1:8000/static/bootstrap.js， 可以直接访问js文件 注意 在settings.py 中的STATIC_URL定义了什么别名，script标签中导入的路径的根就从哪里开始 # settings.py 配置STATIC_URL = '/xxx/'STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static'),]# time.html&lt;script src=\"/static/bootstrap.js\"&gt;&lt;/script&gt; 以上的情况，地址栏输入什么都会有异常信息。 输入 http://127.0.0.1:8000/static/bootstrap.js映射关系是xxx,访问static当然会报404错误，路径根本就是不存在的 输入 http://127.0.0.1:8000/xxx/bootstrap.js可以正常访问bootstrap.js，但是还是有问题的 当输入 http://127.0.0.1:8000/timer/在network中看到bootstrap.js是飘红的,因为在前端的script标签引入bootstrap的路径写错了 &lt;script src=\"/static/bootstrap.js\"&gt;&lt;/script&gt;# 这个时候映射 /static/bootstrap.js的别名是xxx,所以路径写成 &lt;script src=\"/xxx/bootstrap.js\"&gt;&lt;/script&gt; 就没问题 Django三剑客from django.shortcuts import render,HttpResponse,redirectHttpResponse 返回字符串render 返回一个HTML页面redirect 重定向到一个HTML页面 登录功能form表单触发提交数据的动作的两种方式&gt;&lt;input type=\"submit\"&gt;&gt; &lt;button type=\"submit\"&gt;&lt;/button&gt; form表单提交数据的地址如何指定及方式 action属性控制提交的地址，比如说http://127.0.0.1:8080/login 1. 全路径 &lt;form action=\"http://127.0.0.1:8000/login/\"&gt;2. 只写路径后缀 &lt;form action=\"/login\"&gt;3. 不写 &lt;form action=\"\"&gt; 默认往当前路径提交,当前路径指的是打开页面所在的路径，也就是http://127.0.0.1:8080/login） 获取用户端提交的请求方式request.method 根据客户端请求方式的不同执行不同的逻辑代码views.py def login(request): # 获取用户端提交的请求方式 print(request.method) # 拿到的请求方式是全大写的字符串 if request.method=='GET': return render(request,'login.html') return HttpResponse('接收成功') urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login/', views.login),] login.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1 class=\"h2\"&gt;登录页面&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\" &gt; &lt;form action=\"/login/\" method=\"post\"&gt; &lt;p&gt;用户名: &lt;input type=\"text\" class=\"form-control\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;密码: &lt;input type=\"password\" class=\"form-control\" name=\"password\"&gt; &lt;/p&gt; &lt;input type=\"submit\" value=\"登录\" class=\"btn btn-primary\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; 获取提交的表单的value列表里面所有的元素request.POST.getlist(key) 我们通过input标签提交的表单返回给后台的是一个字典类似于 &lt;QueryDict: &#123;'username': ['lxxsb','lyysb'], 'password': ['123']&#125;&gt;字典中的key就是input标签中name属性定义的名字而value则是用户输入的内容，value是通过一个列表的方式展现给后台默认后台通过request.POST.get 只会取到value列表的最后一个元素如果想要取到所有元素，要使用getlist views.py def login(request): # 获取用户端提交的请求方式 print(request.method) # 拿到的请求方式是全大写的字符串 if request.method == 'POST': print(request.POST) # 把它当成一个大字典，里面存放了客户端post提交的所有数据 # &lt;QueryDict: &#123;'username': ['lxxsb', 'lyysb'], 'password': ['123']&#125;&gt; print(request.POST.get('username')) # value虽然是个列表，但是获取value时候拿到的却是单个元素 # 默认只会取value里面的最后一个元素 print(request.POST.getlist('username')) #要想一次性获取value列表里面所有的数据需要用getlist() # ['lxxsb', 'lyysb'] print(request.POST['password']) # 不推荐使用该方法取数据，如果不存在就直接报错了 return HttpResponse('ok') return render(request, \"login.html\") urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login/', views.login),] login.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1 class=\"h2\"&gt;登录页面&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\" &gt; &lt;form action=\"/login/\" method=\"post\"&gt; &lt;p&gt;用户名: &lt;input type=\"text\" class=\"form-control\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;用户名: &lt;input type=\"text\" class=\"form-control\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;密码: &lt;input type=\"password\" class=\"form-control\" name=\"password\"&gt; &lt;/p&gt; &lt;input type=\"submit\" value=\"登录\" class=\"btn btn-primary\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; 获取get 请求的数据规则和POST请求一模一样 浏览器输入 http://127.0.0.1:8000/login/?username=lyysb&amp;password=123&amp;password=456 views.py (其他文件如上) def login(request): # 获取用户端提交的请求方式 print(request.method) # 拿到的请求方式是全大写的字符串 print(request.GET) # &lt;QueryDict: &#123;'username': ['lyysb'], 'password': ['123', '456']&#125;&gt; print(request.GET.get('password')) # 456 print(request.GET.getlist('password')) # ['123', '456'] return render(request, \"login.html\") pymysql 完成登录功能urls.py from django.conf.urls import urlfrom django.contrib import adminfrom app01 import viewsurlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^login/', views.login),] views.py from django.shortcuts import render, HttpResponse, redirect# Create your views here.def login(request): if request.method == 'POST': import pymysql # 获取用户输入的用户名和密码 username = request.POST.get('username') password = request.POST.get('password') conn = pymysql.connect( host='127.0.0.1', user=\"root\", password=\"123\", database='django', port=3306, charset='utf8', autocommit=True ) cursors = conn.cursor(pymysql.cursors.DictCursor) cursors.execute('select * from userinfo where name=%s and password=%s', args=(username, password)) user_info = cursors.fetchone() # 如果只查询到一个结果，fetchone直接返回一个字典，而fetchall还是返回一个列表，里面套个字典 if user_info: return HttpResponse('登录成功') return HttpResponse('用户名或密码错误') return render(request, \"login.html\") login.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"/static/bootstrap-3.3.7-dist/css/bootstrap.css\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;h1 class=\"h2\"&gt;登录页面&lt;/h1&gt; &lt;div class=\"col-md-6 col-md-offset-3\" &gt; &lt;form action=\"/login/\" method=\"post\"&gt; &lt;p&gt;用户名: &lt;input type=\"text\" class=\"form-control\" name=\"username\"&gt;&lt;/p&gt; &lt;p&gt;密码: &lt;input type=\"password\" class=\"form-control\" name=\"password\"&gt; &lt;/p&gt; &lt;input type=\"submit\" value=\"登录\" class=\"btn btn-primary\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"http://code.jquery.com/jquery-3.4.1.js\" integrity=\"sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"/static/bootstrap-3.3.7-dist/js/bootstrap.js\"&gt;&lt;/script&gt;&lt;/html&gt; pycharm 连接数据库 查看pycharm支持的数据库 下载驱动 测试用户名是否正确 勾选需要显示的库 查看到MYSQL数据库已经在pycharm的数据库列表中 添加数据后同步到数据库 Django 连接数据库 需要修改配置文件settings.py DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': os.path.join(BASE_DIR, 'app01'), 'HOST': '127.0.0.1', 'PORT': 3306, 'USER': 'root', 'PASSWORD': '123' &#125;&#125; 告诉django用pymysql替换它默认mysql_db模块来连接数据库 方式1: 在项目文件夹下面的init.py方式2: 在应用文件夹下面的init.py __init__.py import pymysqlpymysql.install_as_MySQLdb() # 告诉django用pymysql代替mysqldb连接数据库","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"}]},{"title":"模拟一个简单的web请求","slug":"模拟一个简单的web请求","date":"2019-07-08T14:42:06.275Z","updated":"2019-07-16T05:03:37.373Z","comments":true,"path":"2019/07/08/模拟一个简单的web请求/","link":"","permalink":"http://cjwnb.top/2019/07/08/模拟一个简单的web请求/","excerpt":"","text":"引子描述下当我们在浏览器输入一个url网址，比如说www,jd.com, 然后显示整个页面的过程1. 当输入http://www.jd.com的时候，先把请求发送到本地DNS服务器里找www.jd.com对应的Ip地址和端口，如果有，返回ip地址和端口，2. 如果本地DNS服务器里面没有字符串 www.jd.com对应的ip地址和端口，则会去DNS根域服务器去找（root-server.net）,根域会把字符串交给顶级域服务器.com DNS服务器，然后会 将字符串交个权威DNS服务器找到jd.com,然后再去二级域名服务器找到www.jd.com3. 当客户端(浏览器)获得了ip地址和端口，客户端发送请求到响应的服务器，服务器响应需求，客户端拿到响应结果，渲染页面。 字符串和字节的转换\\&gt;&gt;&gt; s=\"hello\"\\&gt;&gt;&gt; s'hello'\\&gt;&gt;&gt; bytes(s,encoding=\"utf-8\")b'hello'\\&gt;&gt;&gt; b=bytes(s,encoding=\"utf-8\")\\&gt;&gt;&gt; bb'hello'\\&gt;&gt;&gt; str(b,encoding='utf-8')'hello' 模拟一个简单的web请求from socket import *sock = socket(AF_INET, SOCK_STREAM)sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)sock.bind(('127.0.0.1', 8800))sock.listen(5)while True: # 不断地等待接收客户端的链接,保证服务器不中断 print('\\033[32mserver waiting...\\033[0m') client, addr = sock.accept() # 客户端套接字对象，客户端地址端口 data = client.recv(1024) print('data', data) # client.send(b'hello world') # 浏览器端会显示 127.0.0.1 发送的响应无效 # 浏览器要访问数据必须加上HTTP/1.1 状态码 # HTTP/1.1 200 OK 响应首行 hello world 响应体 响应首行和响应体之前用\\r\\n\\r\\n，否则响应体无法渲染显示 with open('index.html','rb') as f: data=f.read() client.send(b'HTTP/1.1 200 OK\\r\\n\\r\\n%s'%data) client.close() # index.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 style=\"color: red;\"&gt;宝贝 我来了&lt;/h1&gt;&lt;img src=\"http://s14.sinaimg.cn/middle/4b955cd7xcb1739815c4d&amp;690\" alt=\"\"&gt;&lt;a href=\"http://www.w3school.com.cn/\"&gt;click&lt;/a&gt;&lt;div style=\"height: 200px\"&gt;&lt;/div&gt;&lt;div&gt; &lt;h1 style=\"color: yellow; background-color: gray\"&gt;张帆喜欢的类型&lt;/h1&gt; &lt;img src=\"http://s8.sinaimg.cn/bmiddle/005DIuBKgy6KewCX5iv97&amp;690\" alt=\"\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; /usr/local/bin/python3.6 /Users/cjw/Desktop/pycharm_project/Django/Weby应用程序/JDserver.pyserver waiting...data b'GET / HTTP/1.1\\r\\nHost: 127.0.0.1:8800\\r\\nConnection: keep-alive\\r\\nCache-Control: max-age=0\\r\\nUpgrade-Insecure-Requests: 1\\r\\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36\\r\\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\\r\\nAccept-Encoding: gzip, deflate, br\\r\\nAccept-Language: zh-CN,zh;q=0.9\\r\\n\\r\\n'server waiting...data b'GET /favicon.ico HTTP/1.1\\r\\nHost: 127.0.0.1:8800\\r\\nConnection: keep-alive\\r\\nPragma: no-cache\\r\\nCache-Control: no-cache\\r\\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36\\r\\nAccept: image/webp,image/apng,image/*,*/*;q=0.8\\r\\nReferer: http://127.0.0.1:8800/\\r\\nAccept-Encoding: gzip, deflate, br\\r\\nAccept-Language: zh-CN,zh;q=0.9\\r\\n\\r\\n'server waiting... 浏览器会解释url请求发生了什么response: 从客户端接收过来的一堆HTML字符串(要放到页面的一堆字符串)Preview: 浏览器解析服务端发送的的HTML字符串，将这些字符串解析成用户能看到的格式，preview能够看到一个这样的结果所以浏览器也可以看成一个解释期，解释HTML标记语言 HTTP协议主要由请求协议和响应协议构成 请求协议：浏览器给服务器发的格式的限定 响应协议：服务器给浏览器发的格式的限定 HTTP请求协议结构：请求首行+请求头+\\r\\n\\r\\n+请求体服务器通过\\r\\n来识别请求首行，请求头以及请求体请求首行和请求头之间，多个请求体之间用一个\\r\\n分割，最后一个请求头和请求体之间用两个\\r\\n分割请求方法主要分get和postget 没有请求体 post 有请求体 get 和 post请求1. GET请求提交的数据会放在url之后，以？分割URL和传输的数据，参数之间用&amp;相连，比如http://127.0.0.1:8800/?name=changwei&amp;pwd=GET2. GET 提交的数据大小有限制(因为浏览器对URL长度有限制)，而POST方法提交的数据没有限制3. GET与POST都是提交数据的方式，当需要对服务器所在的数据库的数据进行查询的时候提交GET请求，添加或删除提交POST请求 案例1 （get请求）'GET / HTTP/1.1\\r\\nHost: 127.0.0.1:8800\\r\\nConnection: keep-alive\\r\\nCache-Control: max-age=0\\r\\nUpgrade-Insecure-Requests: 1\\r\\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36\\r\\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\\r\\nAccept-Encoding: gzip, deflate, br\\r\\nAccept-Language: zh-CN,zh;q=0.9\\r\\n\\r\\n' 请求首行GET / HTTP/1.1\\r\\nHost: 127.0.0.1:8800格式： 方法(get/post)+发送请求的服务器的路径（URI /form/entry)+协议版本(HTTP/1.1) 请求头请求头 Connection: keep-alive请求头 Pragma: no-cache请求头 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36请求头 Accept: image/webp,image/apng,image/*,*/*;q=0.8请求头 Referer: http://127.0.0.1:8800请求头 Accept-Encoding: gzip, deflate, br请求头 Accept-Language: zh-CN,zh;q=0.9 请求体1. get请求没有请求体 所以最后的请求体部分是空的2. get请求提交的数据会放在url之后，以？分割URL和传输的数据，参数之间用&amp;相连，比如http://127.0.0.1:8800/?name=changwei&amp;pwd=123'GET /?name=changwei&amp;pwd=123 HTTP/1.1\\r\\nHost: 127.0.0.1:8800\\r\\nConnection: keep-alive\\r\\nUpgrade-Insecure-Requests: 1\\r\\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36\\r\\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\\r\\nAccept-Encoding: gzip, deflate, br\\r\\nAccept-Language: zh-CN,zh;q=0.9\\r\\n\\r\\n' 案例2 （post请求）# 服务端from socket import *sock = socket(AF_INET, SOCK_STREAM)sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)sock.bind(('127.0.0.1', 8800))sock.listen(5)while True: # 不断地等待接收客户端的链接,保证服务器不中断 print('\\033[32mserver waiting...\\033[0m') client, addr = sock.accept() # 客户端套接字对象，客户端地址端口 data = client.recv(1024) print('data', data) # client.send(b'hello world') # 浏览器端会显示 127.0.0.1 发送的响应无效 # 浏览器要访问数据必须加上HTTP/1.1 状态码 # HTTP/1.1 200 OK 响应首行 hello world 响应体 响应首行和响应体之前用\\r\\n\\r\\n，否则响应体无法渲染显示 with open('login.html','rb') as f: data=f.read() client.send(b'HTTP/1.1 200 OK\\r\\n\\r\\n%s'%data) client.close()# index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"http://127.0.0.1:8800/\" method=\"post\"&gt; 用户名 &lt;input type=\"text\" name=\"user\"&gt; 密码 &lt;input type=\"password\" name=\"pwd\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 'POST / HTTP/1.1\\r\\nHost: 127.0.0.1:8800\\r\\nConnection: keep-alive\\r\\nContent-Length: 21\\r\\nCache-Control: max-age=0\\r\\nOrigin: http://127.0.0.1:8800\\r\\nUpgrade-Insecure-Requests: 1\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36\\r\\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\\r\\nReferer: http://127.0.0.1:8800/\\r\\nAccept-Encoding: gzip, deflate, br\\r\\nAccept-Language: zh-CN,zh;q=0.9\\r\\n\\r\\nuser=changwei&amp;pwd=123' 请求首行POST / HTTP/1.1\\r\\nHost: 127.0.0.1:8800Cache-Control: max-age=0\\r\\nOrigin: http://127.0.0.1:8800Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Referer: http://127.0.0.1:8800/\\r\\nAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9 请求头Connection: keep-alive\\r\\nContent-Length: 21 请求体user=changwei&amp;pwd=123 HTTP响应协议和请求协议一样，主要由响应首行，响应头，响应体组成 常见的响应状态码1xx Informational(信息性状态码) 接受的请求正在处理2xx Success(成功状态码) 请求正常处理完毕3xx Redirection(重定向状态码) 需要进行附加操作以完成请求 (域名地址变了了,跳转到新的域名地址，这种情况浏览器发2次请求)4xx Client Error (客户端错误状态码) 服务器无法处理请求 404 (not found) 403(forbidden 禁止访问) 5xx Server Error(服务器错误状态码) 服务器处理请求出错 500(服务端代码错误) 502(网关错误 bad gateway) 通过socket实现web框架server.pyimport timefrom socket import *def f1(): # 静态网站 fp = open('index.html', 'r', encoding='utf-8') data = fp.read() fp.close() return bytes(data, encoding='utf-8')def f2(): fp = open('article.html', 'r', encoding='utf-8') data = fp.read() ctime = time.time() data = data.replace(\"@@content@@\", str(ctime)) fp.close() return bytes(data, encoding='utf-8')def f3(): import pymysql conn = pymysql.connect(host='127.0.0.1', user='root', password='123', db='youku', charset='utf8') cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) sql = \"select id,name,password,register_time from user\" cursor.execute(sql) res = cursor.fetchall() print(res) ''' [&#123;'id': 1, 'name': 'lxx', 'password': '202cb962ac59075b964b07152d234b70', 'register_time': '2019-06-26 21:48:47'&#125;, &#123;'id': 2, 'name': '111', 'password': '698d51a19d8a121ce581499d7b701668', 'register_time': '2019-06-26 21:49:10'&#125;] ''' res_list = [] for user in res: res_str = '&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;' % ( user['id'], user['name'], user['password'], user['register_time']) res_list.append(res_str) s = ''.join(res_list) fp = open('content.html', 'r', encoding='utf-8') data = fp.read() data = data.replace(\"@@content@@\", s) return bytes(data, encoding='utf-8') ### 需要将html代码和mysql结果融合def f4(): pass# 路由系统routes = [ ('/xxx', f1), ('/ooo', f2), ('/hhh', f3), ('/kkk', f4)]def run(): sk = socket() sk.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1) sk.bind(('127.0.0.1', 8081)) sk.listen(5) while True: conn, addr = sk.accept() buf = conn.recv(8096) data = str(buf, encoding='utf-8') header_list = data.split('\\r\\n\\r\\n')[0].split('\\r\\n')[0] print(header_list) uri = header_list.split(' ')[1] func_name = None for items in routes: if items[0] == uri: func_name = items[1] break if func_name: res = func_name() else: res = b'404 not found' conn.send(b'HTTP/1.1 200 OK\\r\\nCache-Control: private\\r\\n\\r\\n') conn.send(res)if __name__ == '__main__': run() index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;this is index&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; content.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=\"1px\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;password&lt;/th&gt; &lt;th&gt;register_time&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; @@content@@ &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; article.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; @@content@@&lt;/body&gt;&lt;/html&gt; 通过wsgiref实现web框架step 1访问不同的url路径可以跳转到不同的网页from wsgiref.simple_server import make_serverdef application(environ, start_response): # 按着httpd协议解析数据（将所有请求存到一个字典里）: environ # 按着httpd协议组装数据（生成数据 响应首行，响应头）： start_response # 当前的请求路径 path = environ.get('PATH_INFO') start_response('200 OK', [('Content-Type', 'text/html')]) # 生成数据 请求首行，请求头，请求体 if path == \"/login\": with open('login.html', 'rb') as f: global data data = f.read() if path == '/index': with open('index.html', 'rb') as f: data = f.read() return [data]# 封装sockethttped = make_server(\"127.0.0.1\", 8060, application)# 等待客户连接: conn,addr=sock.accept()httped.serve_forever()# login.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"http://127.0.0.1:8800/\" method=\"post\"&gt; 用户名 &lt;input type=\"text\" name=\"user\"&gt; 密码 &lt;input type=\"password\" name=\"pwd\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;# index.html &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 style=\"color: red;\"&gt;宝贝 我来了&lt;/h1&gt;&lt;img src=\"http://s14.sinaimg.cn/middle/4b955cd7xcb1739815c4d&amp;690\" alt=\"\"&gt;&lt;a href=\"http://www.w3school.com.cn/\"&gt;click&lt;/a&gt;&lt;div style=\"height: 200px\"&gt;&lt;/div&gt;&lt;div&gt; &lt;h1 style=\"color: yellow; background-color: gray\"&gt;张帆喜欢的类型&lt;/h1&gt; &lt;img src=\"http://s8.sinaimg.cn/bmiddle/005DIuBKgy6KewCX5iv97&amp;690\" alt=\"\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 设置页面图标为京东图标from wsgiref.simple_server import make_serverdef application(environ: dict, start_response): start_response('200 ok', [('Content-Type','text/html')]) print(\"PATH\",environ.get('PATH_INFO')) path=environ.get('PATH_INFO') if path=='/favicon.ico': with open('favicon.ico','rb') as f: data=f.read() return [data] return [b'&lt;h1&gt;Hello,web!&lt;/h1&gt;']httped = make_server(\"127.0.0.1\", 8080, application)httped.serve_forever() step 2通过列表的映射来使得访问不同的url路径可以跳转到不同的网页 from wsgiref.simple_server import make_serverdef login(): with open('login.html', 'rb') as f: data = f.read() return datadef index(): with open('index.html', 'rb') as f: data = f.read() return datadef favi(): with open('favicon.ico', 'rb') as f: data = f.read() return datadef application(environ: dict, start_response): start_response('200 ok', [('Content-Type', 'text/html')]) print(\"PATH\", environ.get('PATH_INFO')) # 当前请求路径 global path path = environ.get('PATH_INFO') url_patterns = [ (\"/login\", login), (\"/index\", index), (\"/favicon.ico\", favi) ] func = None for item in url_patterns: print(item) if path == item[0]: func = item[1] break print(func) if func: return [func()] else: return [b'404!']httped = make_server(\"127.0.0.1\", 8080, application)httped.serve_forever()# login.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;登录页面&lt;/h4&gt;&lt;form action=\"http://127.0.0.1:8080/\" method=\"post\"&gt; 用户名 &lt;input type=\"text\" name=\"user\"&gt; 密码&lt;input type=\"password\" name=\"pwd\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;# index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt;welcome to here&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://cjwnb.top/tags/django/"},{"name":"前端","slug":"前端","permalink":"http://cjwnb.top/tags/前端/"}]}]}